#! /usr/bin/env node
/**
 *  @file       mkad.js
 *              Manipulate Keystore/Address Data.
 *
 *  @author     Ryan Rossiter, ryan@kingsds.network
 *  @date       April 2020
 */

const path = require('path');
const fs = require('fs');
const os = require('os');
const process = require('process');
const consts = require('constants');
const expandTilde = require('expand-tilde');

function wrapHandler(handler) {
  return async function (argv) {
    try {
      await handler(argv);
      process.exit(0);
    } catch (e) {
      console.error(`Error in '${argv._[0]}' command handler:`);
      console.error(e);
      process.exit(1);
    }
  }
}

async function main() {

  await require('dcp-client').init(process.argv);
  const { dotDcpDir } = require('dcp/dot-dcp-dir');

  require('dcp/dcp-cli')
  .base('Manipulate Keystore/Address Data.')
  .hide('identity')
  .hide('identity-file')
  .hide('default-bank-account')
  .hide('default-bank-account-file')
  .command(['create [label]', 'new'],
    'Create a new keystore', (yargs) => {
      yargs
      .positional('label', {
        describe: 'Label for the keystore, used for the filename',
        default: 'default',
      })
      .options({
        passphrase: {
          alias: 'p',
          describe: 'Passphrase used to encrypt the keystore',
          default: '',
        },
        emptyPassphrase: {
          alias: 'e',
          describe: 'This flag must be set to create a keystore without a passphrase',
          type: 'boolean',
          default: false,
        },
        privateKey: {
          alias: 'pk',
          describe: 'Create a keystore from a private key, will be randomly generated if not provided',
          default: null,
        },
        dir: {
          describe: 'Directory to save the generated keystore to',
          default: dotDcpDir,
        },
      });
    },
    wrapHandler((argv) => createKeystore(argv)))
  .command(['show <keystore>', 'unlock'],
    'Unlocks the keystore and displays its information', (yargs) => {
      yargs
      .positional('keystore', {
        describe: 'A label, filepath, or private key',
      })
      .options({
        dir: {
          alias: 'd',
          describe: 'Directory to load the keystore from, if a label was provided',
          default: dotDcpDir,
        },
        passphrase: {
          alias: 'p',
          describe: 'Passphrase to unlock the keystore with, will prompt if not provided',
          default: '',
        },
        showPrivateKey: {
          describe: 'Set this flag to include the private key in the output',
          type: 'boolean',
          default: false,
        }
      })
    },
    wrapHandler((argv) => unlockKeystore(argv)))
    .command('change-passphrase <keystore>',
    "Change a keystore's passphrase", (yargs) => {
      yargs
      .positional('keystore', {
        describe: 'A label or filepath',
      })
      .options({
        dir: {
          alias: 'd',
          describe: 'Directory to load the keystore from, if a label was provided',
          default: dotDcpDir,
        },
        oldPassphrase: {
          alias: 'o',
          describe: 'Passphrase to unlock the original keystore with, will prompt if not provided',
          default: null,
        },
        newPassphrase: {
          alias: 'p',
          describe: 'Passphrase to lock the new keystore with, will prompt if not provided',
          default: null,
        }
      })
    },
    wrapHandler((argv) => changeKeystorePassphrase(argv)))
  .demandCommand(1)
  .strict().argv;
}

main()
.catch(e => {
  console.error("Failed to execute command:");
  console.error(e);
  process.exit(1);
});

/**
 * Create a new keystore from the provided options
 * @param {object} argv
 * @param {string}  argv.label
 * @param {string}  argv.passphrase
 * @param {boolean} argv.emptyPassphrase
 * @param {string}  argv.privateKey
 * @param {string}  argv.dir
 */
async function createKeystore(argv) {
  const { passphrase, emptyPassphrase, privateKey, dir } = argv;
  let { label } = argv;

  if (!passphrase && !emptyPassphrase) {
    console.log('The --emptyPassphrase flag must be set to create a keystore with no passphrase.');
    return;
  }

  label = label.match(/^(.*?)(\.keystore)?$/)[1]; // remove .keystore from label

  const { Keystore } = require('dcp/wallet');
  const ks = await new Keystore(privateKey, passphrase);

  const ksObj = ks.toJSON();
  ksObj.label = label;

  const filename = `${label}.keystore`;
  const fullpath = path.resolve(expandTilde(dir), filename);
  const dirname = path.dirname(fullpath);
  if (!fs.existsSync(dirname)) {
    console.error(`Failed to save keystore: Directory ${dirname} does not exist`);
  } else if (fs.existsSync(fullpath)) {
    console.error(`Failed to save keystore: A file named ${filename} already exists in ${dirname}`);
  } else {
    fs.writeFileSync(fullpath, JSON.stringify(ksObj));
    console.log(`Created keystore ${filename} in ${dirname}`);
  }
}

/**
 * Unlocks a keystore
 * @param {object} argv
 * @param {string}  argv.keystore
 * @param {string}  argv.dir
 * @param {string}  argv.passphrase
 * @param {boolean} argv.showPrivateKey
 */
async function unlockKeystore(argv) {
  const { keystore, dir, passphrase, showPrivateKey } = argv;
  const wallet = require('dcp/wallet');

  let ks;
  if (wallet.isPrivateKey(keystore)) {
    ks = await new wallet.Keystore(keystore, '');
  } else {
    const loadResult = await wallet.load({
      name: keystore,
      dir,
    });
    ks = loadResult.keystore;
  }
  
  console.log(`Keystore "${keystore}":`);
  console.group();
    console.log("Label:", ks.label);
    console.log("Address:", ks.address.toString());
    if (showPrivateKey) {
      if (passphrase) await ks.unlock(passphrase);
      console.log("Private Key:", (await ks.getPrivateKey()).toString());
    }
  console.groupEnd();
}

/**
 * Changes a keystore's passphrase
 * @param {object} argv
 * @param {string}  argv.keystore
 * @param {string}  argv.dir
 * @param {string}  argv.oldPassphrase
 * @param {string}  argv.newPassphrase
 */
async function changeKeystorePassphrase(argv) {
  const { keystore, dir, oldPassphrase, newPassphrase } = argv;
  const wallet = require('dcp/wallet');

  const {
    keystore: oldKeystore,
    filename: oldFilename,
  } = await wallet.load({
    name: keystore,
    dir,
  });

  console.log(`Changing passphrase for keystore in "${oldFilename}"...`);
  
  const unlockArgs = [];
  if (oldPassphrase) unlockArgs.push(oldPassphrase);
  await oldKeystore.unlock(...unlockArgs);

  const newKeystoreArgs = [await oldKeystore.getPrivateKey()];
  if (newPassphrase) newKeystoreArgs.push(newPassphrase);
  const newKeystore = await new wallet.Keystore(...newKeystoreArgs);
  newKeystore.label = oldKeystore.label;

  const oldStats = fs.statSync(oldFilename);
  const tempFilename = `${oldFilename}.temp-${os.hostname()}-${process.pid}`;
  const flags = consts.O_CREAT | consts.O_EXCL | consts.O_WRONLY;
  const mode = oldStats.mode & 0777;

  // Open a temp file in the same location as the old keystore
  //  - Must be a new file, in write-only mode (from flags)
  //  - Preserve permissions of old file (from mode)
  //  - Preserve ownership of old file (from oldStats uid/gid)
  const fd = fs.openSync(tempFilename, flags, mode);
  fs.fchownSync(fd, oldStats.uid, oldStats.gid);
  fs.writeSync(fd, JSON.stringify(newKeystore));
  fs.closeSync(fd);

  try {
    // Finally, replace the old keystore with the new one
    fs.renameSync(tempFilename, oldFilename);
    console.log("Successfully changed keystore passphrase.");
  } catch (e) {
    console.error(e);
    fs.unlinkSync(tempFilename); // delete the temp file on fail
  }
}