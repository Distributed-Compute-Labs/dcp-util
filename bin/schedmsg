#! /usr/bin/env node
/**
 * @file schedmsg.js
 * 
 * Schedmsg provides a system to interact with the workers.
 * 
 * schedmsg.js will convert info from command line arguments to objects. The
 * objects will be sent to protocol.js to sign and send the message
 * 
 * @author Ryan Rossiter, ryan@kingsds.network,
 *         Sam Cantor, samcantor@kingsds.network
 *         Duncan Mays, duncan@kingds.network
 * @date May 2019
 */

const process = require('process');

async function main() {
  require('dcp/dcp-cli')
  .base('Send control messages to a DCP service.')
  .command('announce <message>',
    'Send an announcement to workers, will display a modal or log to console', {},
    (argv) => sendMessage(argv, 'announce', { message: argv.message }))
  .command('remove <jobAddress>', 
    'Removes any active slices for job address', {},
    (argv) => sendMessage(argv, 'remove', { jobAddress: argv.jobAddress }))
  .command('openPopup <href>',
    'Opens a new tab on browser workers', {},
    (argv) => sendMessage(argv, 'openPopup', { href: argv.href }))
  .command('kill [temporary]',
    'Immediately stops workers', (yargs) => {
      yargs.positional('temporary', {
        describe: 'if false the worker will be permanently disabled, requiring manual intervention to be restarted',
        default: false,
        type: 'boolean',
      });
    },
    (argv) => sendMessage(argv, 'kill', { temporary: argv.temporary }))
  .command('reload',
    'Forces a reload of the worker', {},
    (argv) => sendMessage(argv, 'reload'))
  .command('restart',
    'Stop and refreshes workers without reloading the entire worker', {},
    (argv) => sendMessage(argv, 'restart'))
  .options({
    broadcast: {
      alias: 'b',
      describe: 'when true, command will be sent to all workers connected to the scheduler (provided keystore must be in the scheduler\'s schedMsgAdmins list). When false, command will be sent to workers that use the provided keystore as their identity',
      type: 'boolean',
      default: false,
    },
    persistent: {
      describe: '(not implemented) Whether the message should be persistent',
      type: 'boolean',
      default: false,
    }
  })
  .demandCommand(1, 'A command must be specified')
  .strict().argv;
}


/**
 * Send the message to the scheduler
 * @param {object} argv - yarg options
 * @param {string} command
 * @param {object} payload
 */
async function sendMessage (argv, command, payload={}) {
  const protocolV4 = require('dcp/protocol-v4');
  const { URL } = require('dcp/dcp-url');
  const wallet = require('dcp/wallet');

  const accountKeystore = await wallet.get();

  const schedulerURL = new URL(argv.scheduler);
  const schedulerConnection = new protocolV4.Connection(schedulerURL.resolve('/DCPv4'));

  const message = {
    owner: accountKeystore.address,
    broadcast: argv.broadcast,
    command,
    payload,
  }

  console.log(`Sending SchedMsg to scheduler ${argv.scheduler}:`, message);
  await schedulerConnection.send('sendSchedMsg', message, accountKeystore);
  console.log(`\nCommand '${command}' sent successfully.`);

  await schedulerConnection.close();
  process.exit(0);
}

require('dcp-client').init()
.then(main)
.catch(e => {
  console.error("Failed to execute command:");
  console.error(e);
  process.exit(1);
});
