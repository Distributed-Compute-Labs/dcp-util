#!/usr/bin/env node
/**
 * @file schedmsg.js
 *
 * Schedmsg provides a system to interact with the workers.
 *
 * schedmsg.js will convert info from command line arguments to objects. The
 * objects will be sent to protocol.js to sign and send the message
 *
 * @author Ryan Rossiter, ryan@kingsds.network,
 *         Sam Cantor, samcantor@kingsds.network
 *         Duncan Mays, duncan@kingds.network
 * @date May 2019
 */

const process = require('process');

require('dcp-client').initSync();

const { base } = require('dcp/dcp-cli');
const { Connection } = require('dcp/protocol-v4');
const { DcpURL } = require('dcp/dcp-url');
const { load, getId } = require('dcp/wallet');

/**
 * Provides a system to interact with the workers by converting info from
 * command line arguments to objects. The objects will be sent to protocol.js to
 * sign and send the message.
 */
async function main() {
  base('Send control messages to a DCP service.')
    .command(
      'announce <message>',
      'Send an announcement to workers, will display a modal or log to console',
      {},
      (argv) => sendMessage(argv, 'announce', { message: argv.message }),
    )
    .command(
      'remove <jobAddress>',
      'Removes any active slices for job address',
      {},
      (argv) => sendMessage(argv, 'remove', { jobAddress: argv.jobAddress }),
    )
    .command(
      'openPopup <href>',
      'Opens a new tab on browser workers',
      {},
      (argv) => sendMessage(argv, 'openPopup', { href: argv.href }),
    )
    .command(
      'kill [temporary]',
      'Immediately stops workers',
      (yargs) => {
        yargs.positional('temporary', {
          describe:
            'if false the worker will be permanently disabled, requiring manual intervention to be restarted',
          default: false,
          type: 'boolean',
        });
      },
      (argv) => sendMessage(argv, 'kill', { temporary: argv.temporary }),
    )
    .command('reload', 'Forces a reload of the worker', {}, (argv) =>
      sendMessage(argv, 'reload'),
    )
    .command(
      'restart',
      'Stop and refreshes workers without reloading the entire worker',
      {},
      (argv) => sendMessage(argv, 'restart'),
    )
    .options({
      broadcast: {
        alias: 'b',
        describe:
          "when true, command will be sent to all workers connected to the scheduler (provided keystore must be in the scheduler's schedMsgAdmins list). When false, command will be sent to workers that use the provided keystore as their identity",
        type: 'boolean',
        default: false,
      },
      targetIdentity: {
        alias: 't',
        describe:
          'Expects a keystore label. When provided, non-broadcast commands will be sent to workers using this target identity keystore label. Defaults to the identity used to send the command.',
      },
      targetIdentityFile: {
        alias: 'T',
        describe:
          'Expects a keystore path. Path-based variant of targetIdentity.',
      },
      persistent: {
        describe: '(not implemented) Whether the message should be persistent',
        type: 'boolean',
        default: false,
      },
    })
    .demandCommand(1, 'A command must be specified')
    .strict()
    .parse();
}

/**
 * Send the message to the scheduler
 *
 * @param {object} argv - yarg options
 * @param {string} command
 * @param {object} payload
 */
async function sendMessage(argv, command, payload = {}) {
  const targetIdentity = await getTargetIdentity(argv);

  const schedulerURL = new DcpURL(argv.scheduler);
  const schedulerConnection = new Connection(schedulerURL.resolve('/DCPv4'));

  const message = {
    target: targetIdentity.address,
    broadcast: argv.broadcast,
    command,
    payload,
  };

  console.log(`Sending SchedMsg to scheduler ${argv.scheduler}:`, message);
  await schedulerConnection.send('sendSchedMsg', message, targetIdentity);
  console.log(`\nCommand '${command}' sent successfully.`);

  await schedulerConnection.close();
  process.exit(0);
}

/**
 * @param argv
 * @returns {object} The target identity
 */
function getTargetIdentity(argv) {
  const { targetIdentity, targetIdentityFile } = argv;

  if (targetIdentityFile) {
    return load(targetIdentityFile).then((loaded) => {
      if (!loaded.safe)
        console.warn(
          `Warning! The keystore file ${targetIdentityFile} has unsafe permissions!`,
        );

      return loaded.keystore;
    });
  }
  if (targetIdentity) {
    return getId(targetIdentity);
  }
  return getId();
}

main().catch((e) => {
  console.error('Failed to execute command:');
  console.error(e);
  process.exit(1);
});
