#!/usr/bin/env node
/**
 * @file   job-utility.js - Utility to inspect and manipulate running jobs.
 *
 * @author Ryan Rossiter <ryan@kingsds.network>
 * @author Karen Batch <karen@kingsds.network>
 * @date   April 2019
 */

const process = require('process');
const { green, red } = require('chalk');
const ora = require('ora');
const debug = require('debug');

require('dcp-client').initSync();

const { base } = require('dcp/dcp-cli');
const { Connection } = require('dcp/protocol-v4');
const { DcpURL } = require('dcp/dcp-url');
const { getId } = require('dcp/wallet');

const log = debug('job-utility');
const getSchedulerConnection = (schedulerURL) =>
  new Connection(schedulerURL.resolve('job-submit'));

let idKeystore = null;
let schedulerConnection = null;

/**
 * Uses dcp-cli to help manage sending requests to routes/operations.
 */
async function main() {
  idKeystore = await getId();
  const argv = base('Inspect and manipulate running jobs on the command line.')
    .command(
      'listJobs [jobOwner]',
      'List jobs owned by an identity, or list all of them if jobOwner is omitted',
      (yargs) => {
        yargs.positional('jobOwner', {
          describe: 'The identity address of the owner of the jobs to list',
          type: 'string',
        });
      },
    )
    .command(
      'countJobs [jobOwner]',
      'Count jobs owned by an identity, or list all of them if jobOwner is omitted',
      (yargs) => {
        yargs.positional('jobOwner', {
          describe: 'The identity address of the owner of the jobs to count',
          type: 'string',
        });
      },
    )
    // FIXME(bryan-hoang): countTasks is not implemented currently.
    .command(
      'countTasks <jobId>',
      'Count tasks belonging to the specified job.',
    )
    .command(
      'elapsedJobTime <jobId>',
      'Display how long each slice belonging to the specified job has been running.',
      (yargs) => {
        yargs.positional('jobId', {
          describe: 'The id of the job',
          type: 'string',
        });
      },
    )
    // FIXME(bryan-hoang): cancelJob is not implemented currently.
    .command(
      'cancelJob <jobId>',
      'Cancels the specified job, halting execution.',
    )
    // FIXME(bryan-hoang): cancelAllJobs is not implemented currently.
    .command('cancelAllJobs', 'Cancels all jobs')
    // FIXME(bryan-hoang): fetchJobReport is not implemented currently.
    .command(
      'fetchJobReport <jobId>',
      'Returns information and status of the specified job',
    )
    // FIXME(bryan-hoang): fetchSliceReport is not implemented currently.
    .command(
      'fetchSliceReport <jobId>',
      'Returns status and history of slices for a specified job',
    )
    .options({
      debug: {
        alias: 'd',
        type: 'boolean',
        default: false,
        describe: 'Show debugging information',
      },
      json: {
        alias: 'j',
        type: 'boolean',
        default: false,
        describe: 'Show the output in JSON format',
      },
    })
    .demandCommand(1, 'A command must be specified')
    .strict()
    .parse();

  const [command] = argv._;
  await sendRequest(command, argv);
}

/**
 * Sends the request to the route specified. Manipulates the owner's jobs
 * accordingly.
 *
 * @param {string} requestRoute
 * @param {object} argv
 * @returns {Promise<object>}
 */
async function sendRequest(requestRoute, argv) {
  if (argv.debug) {
    debug.enable('job-utility');
  }

  let requestPayload;
  switch (requestRoute) {
    case 'cancelJob':
    case 'countTasks':
    case 'elapsedJobTime':
    case 'fetchJobReport':
    case 'fetchSliceReport':
      requestPayload = {
        jobOpaqueId: argv.jobId,
      };
      break;
    case 'countJobs':
    case 'listJobs': {
      const { jobOwner } = argv;
      if (typeof jobOwner === 'undefined') {
        requestPayload = {
          isSelectingAll: true,
          jobOwner: String(idKeystore.address),
        };
      } else {
        requestPayload = {
          isSelectingAll: false,
          jobOwner,
        };
      }
      break;
    }
    default:
  }

  log('requestPayload:', requestPayload);

  let spinner;
  if (!argv.json) {
    spinner = ora(
      `Sending request ${green(requestRoute)} to ${green(argv.scheduler)}`,
    ).start();
  }

  const schedulerURL = new DcpURL(argv.scheduler);
  schedulerConnection = getSchedulerConnection(schedulerURL);
  const { success, payload: responsePayload } = await schedulerConnection.send(
    requestRoute,
    requestPayload,
    idKeystore,
  );

  if (argv.json) {
    console.log(JSON.stringify(responsePayload, null, 2));
  } else if (!success) {
    spinner.fail();
    log('responsePayload', responsePayload);
    console.error(
      red(
        `Response Error${
          typeof responsePayload.code !== 'undefined'
            ? ` (${responsePayload.code})`
            : ''
        }:`,
      ),
      responsePayload.message,
    );

    process.exitCode = 1;
  } else {
    spinner.succeed();
    console.log('Response:', JSON.stringify(responsePayload, null, 2));
  }
}

main()
  .catch((e) => {
    console.error('Failed to execute command:');
    console.error(e);
    process.exitCode = 1;
  })
  .finally(async () => {
    if (typeof schedulerConnection.close === 'function') {
      await schedulerConnection.close();
    }

    process.exit();
  });
