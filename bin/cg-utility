#!/usr/bin/env node
/**
 * @file cg-utility
 *
 * This utility is used to manage compute groups.
 *
 * The following operations are supported:
 * - create compute group
 * - change compute group
 * - delete compute group
 * - list jobs in group
 *
 * Future versions of this utility will also adding/removing jobs from the
 * group, maybe performance-related queries, etc.
 *
 * Eventually, the portal will have a "Compute Groups" page that will also do
 * this with a web interface, but that will come later.
 *
 * @author Ryan Rossiter, ryan@kingsds.network
 * @date Oct 2020
 */

const process = require('process');
const { green } = require('chalk');
const ora = require('ora');
const { init: initDCPClient } = require('dcp-client');

let spinner;
let computeGroupsLocation;

const wrapAPICall = (callback) => async ({
  _: [command],
  debug: isDebugging,
  json: isOutputJSON,
  ...argv
}) => {
  if (isDebugging) {
    process.env.DCP_DEBUG = 'dcp-client:compute-groups';
  }

  spinner = ora({
    isSilent: isOutputJSON || isDebugging,
  }).start(
    `Sending request ${green(command)} to ${green(computeGroupsLocation)}`,
  );

  try {
    const response = await callback(argv);
    const responseJSON = JSON.stringify(response, null, 2);
    if (isOutputJSON) {
      console.log(responseJSON);
    } else {
      spinner.succeed();
      console.log('Response:', responseJSON);
    }
  } catch (error) {
    if (isOutputJSON) {
      console.error(
        JSON.stringify(error, Object.getOwnPropertyNames(error), 2),
      );
    } else {
      spinner.fail();
      console.error(error);
    }
    process.exitCode = 1;
  } finally {
    process.exit();
  }
};

/**
 * Wraps the Compute API using the cli API.
 */
async function main() {
  const { base } = require('dcp/cli');
  const {
    cancelJob,
    cancelAllJobs,
    create,
    changeGroup,
    deleteGroup,
    listJobs,
  } = require('dcp/compute-groups');

  ({
    scheduler: {
      services: {
        computeGroups: { location: computeGroupsLocation },
      },
    },
  } = require('dcp/dcp-config'));

  base('Manage compute groups.')
    .command(
      'create <name> [description]',
      'Create a new compute group',
      (yargs) =>
        yargs
          .positional('name', {
            type: 'string',
            description: 'The name of the compute group to create',
          })
          .option('description', {
            alias: 'D',
            type: 'string',
            description: 'The description of the compute group to create',
          })
          .option('joinKey', {
            alias: 'K',
            type: 'string',
            description:
              'The join key used to join the created compute group. Can be specified by itself.',
          })
          .option('joinSecret', {
            alias: 'S',
            type: 'string',
            description:
              'The join secret used to join the created compute group. Must be specified along with a join key.',
          }),
      wrapAPICall((argv) =>
        create(argv.name, {
          description: argv.description,
          joinKey: argv.joinKey,
          joinSecret: argv.joinSecret,
        }),
      ),
    )
    .command(
      'change <id> <joinKey> [options]',
      'Change a compute group',
      (yargs) =>
        yargs
          .options({
            name:                   { type: 'string' },
            description:            { type: 'string' },
            joinHash:               { type: 'string'},    
            joinAddress:            { type: 'string' | 'Address'},   
            commissionRate:         { type: 'number' | 'BigNumber'},      
            commissionAccount:      { type: 'string' | 'Address'},    
            deployFee:              { type: 'number' | 'BigNumber'}, 
            deployAccess:           { type: 'string'},
            addJobFee:              { type: 'number' | 'BigNumber'},
            maxTotalPayment:        { type: 'number' | 'BigNumber'},
            maxConcurrentJobs:      { type: 'number'},
            maxConcurrentWorkers:   { type: 'number'},
            maxConcurrentSandboxes: { type: 'number'},
            maxConcurrentCPUs:      { type: 'number'},
            maxConcurrentGPUs:      { type: 'number'},
            maxConcurrentEscrow:    { type: 'number' | 'BigNumber'},
          })
          .positional('id', {
            type: 'string',
            description: 'The opaqueId of the compute group',
          })
          .positional('joinKey', {
            type: 'string',
            description: 'The joinKey of the compute group',
          }),
      wrapAPICall((argv) =>
        changeGroup(argv.id, argv.joinKey, {
          name: argv.name,
          description: argv.description,
          joinHash: argv.joinHash,
          joinAddress: argv.joinAddress,
          commissionRate: argv.commissionRate,
          commissionAccount: argv.commissionAccount,
          deployFee: argv.deployFee,
          deployAccess: argv.deployAccess,
          addJobFee: argv.addJobFee,
          maxTotalPayment: argv.maxTotalPayment,
          maxConcurrentJobs: argv.maxConcurrentJobs,
          maxConcurrentWorkers: argv.maxConcurrentWorkers,
          maxConcurrentSandboxes: argv.maxConcurrentSandboxes,
          maxConcurrentCPUs: argv.maxConcurrentCPUs,
          maxConcurrentGPUs: argv.maxConcurrentGPUs,
          maxConcurrentEscrow: argv.maxConcurrentEscrow,
        }),
      ),
    )
    .command(
      'delete <id> <joinKey>',
      'Delete a compute group',
      (yargs) =>
        yargs.positional('id', {
          type: 'string',
          description: 'The opaqueId of the compute group to delete',
        })
        .positional('joinKey', {
          type: 'string',
          description: 'The joinKey of the compute group to delete',
        }),
      wrapAPICall((argv) => deleteGroup(argv.id, argv.joinKey)),
    )
    .command(
      'listJobs [options]',
      'List jobs in a compute group',
      (yargs) =>
      yargs.options({
        id:           { type: 'string'},  
        joinKey:      { type: 'string'},
      }),
      wrapAPICall(argv =>
        listJobs({
          id: argv.id,
          joinKey: argv.joinKey,
          }
        )
      )
    )
    .command(
      'cancelJob <job> [options]',
      "Cancel the specified job that's in the specified compute-group. It needs to be provided with at least one of the options!",
      (yargs) =>
        yargs
          .positional('job', {
            type: 'string',
            description: 'The job address of the job to cancel',
          })
          .options({
            id:           { type: 'string'},  
            joinKey:      { type: 'string'},
            joinSecret:   { type: 'string'},
            joinHash:     { type: 'string'},
            joinAddress:  { type: 'string'},
          }),
      wrapAPICall(argv =>
        cancelJob(argv.job, {
          id: argv.id,
          joinKey: argv.joinKey,
          joinSecret: argv.joinSecret,
          joinHash: argv.joinHash,
          joinAddress: argv.joinAddress
          }
        ),
      ),
    )
    .command(
      'cancelAllJobs [options]',
      'Cancel all jobs in the specified compute-group. It needs to be provided with at least one of the options!',
      (yargs) =>
        yargs.options({
          id:           { type: 'string'},  
          joinKey:      { type: 'string'},
          joinSecret:   { type: 'string'},
          joinHash:     { type: 'string'},
          joinAddress:  { type: 'string'},
        }),
        wrapAPICall(argv =>
          cancelAllJobs({
            id: argv.id,
            joinKey: argv.joinKey,
            joinSecret: argv.joinSecret,
            joinHash: argv.joinHash,
            joinAddress: argv.joinAddress
            })
          )
      ).options({
        json: {
          alias: 'j',
          type: 'boolean',
          default: false,
          describe: 'Show the output in JSON format',
        },
        debug: {
          alias: 'd',
          type: 'boolean',
          default: false,
          describe: 'Show debugging information',
        },
      })
    .demandCommand(1, 'A command must be specified')
    .strict()
    .parse();
}

initDCPClient()
  .then(main)
  .catch((e) => {
    console.error('Failed to execute command:');
    console.error(e);
    process.exit(1);
  });
