#!/usr/bin/env node
/**
 *  Bank Utility - CLI for common bank operations
 *
 *  @author     Eddie Roosenmaallen <eddie@kingsds.network>
 *  @date       August 2020
 */

const { argv } = require('process');

const debug = require('debug');

require('dcp-client').initSync(argv);

const { base, getAccountKeystore } = require('dcp/dcp-cli');
const { Address } = require('dcp/wallet');
const { Connection } = require('dcp/protocol-v4');
const {
  bank: { location: bankLocation },
} = require('dcp/dcp-config');

const getBankConnection = () =>
  new Connection(bankLocation.resolve('bank-teller'));
let bankConnection;

const log = debug('bank-utility');

/**
 * Handle CLI and dispatch commands to appropriate handlers
 */
function main() {
  return new Promise((resolve, _reject) => {
    base('CLI for common Bank operations')
      .command('balance', 'Request account balances', {}, getBalance)
      .command(
        'viewFeeStructure <feeStructureAddress>',
        'View details about a FeeStructure',
        {},
        viewFeeStructure,
      )
      .command(
        'transfer <amount> <toAddress>',
        'Transfer credits',
        {},
        transferCredits,
      )
      .option('quiet', {
        alias: 'q',
        description: 'Less output',
        type: 'boolean',
        default: false,
      })
      .option('json', {
        alias: 'j',
        description: 'Provide output in JSON format',
        type: 'boolean',
        default: false,
      })
      .demandCommand(1)
      /**
       * Yargs doesn't seem to play well with async command handlers; this
       * onFinishCommand hook will resolve main() with the result value from the
       * command function.
       */
      .onFinishCommand((resultValue) => {
        resolve(resultValue);
      })
      .parse();
  });
}

/**
 * Fetch balance information for the default account
 *
 * @param {object} options Yargs options from CLI
 * @returns {Promise<object>}  Resolves to the Account block from the bank
 */
async function getBalance(options) {
  const ks = await getAccountKeystore();

  if (!options.quiet && !options.json)
    console.log(
      `Fetching account balance for address ${ks.address} at bank ${bankLocation}`,
    );

  bankConnection = getBankConnection();

  const { payload } = await bankConnection.send(
    'viewAccount',
    { address: ks.address },
    ks,
  );

  if (options.json) {
    console.log(JSON.stringify(payload, null, 2));
  } else {
    const { address, balance, escrow } = payload;
    console.log(`Account info for ${address}:`);
    console.log(`  Balance: ${balance}`);

    if (escrow && parseInt(escrow.num, 10)) {
      console.log(`  Escrow count: ${escrow.num}`);
      console.log(`  Escrow total: ${escrow.total}`);
    }
  }

  log(payload);

  return payload;
}

/**
 * Fetch details about a FeeStructure from the bank
 *
 * @param {object} options - Parsed Yargs options .feeStructureAddress: Fee
 * structure to fetch
 * @returns {Promise<object>} Resolves to the requested FeeStructure
 */
async function viewFeeStructure(options) {
  const ks = await getAccountKeystore();
  const feeStructureAddress = String(
    new Address(String(options.feeStructureAddress)),
  );

  if (!options.quiet && !options.json) {
    console.log('Fetching FeeStructure:', feeStructureAddress);
    console.log(`  (owned by ${ks.address})`);
  }

  bankConnection = getBankConnection();

  const { payload } = await bankConnection.send(
    'viewFeeStructure',
    { feeStructureAddress },
    ks,
  );

  if (options.json) {
    console.log(JSON.stringify(payload, null, 2));
  } else {
    const {
      address,
      fromAddress,
      escrow,
      balance,
      moved,
      maxTotal,
      maxPerRequest,
    } = payload;

    if (payload.name === 'Error') {
      console.error('Unable to view fee structure for the following reason:');
      console.error(payload.message);
      return payload;
    }

    console.log('Fee Structure:');
    console.log('  Address:      ', address);
    console.log('  From Account: ', fromAddress);
    console.log('  Type:         ', escrow ? 'Escrow' : 'Dynamic');
    console.log('  Slice Price:  ', maxPerRequest.padStart(22));
    console.log('  Total amount: ', maxTotal.padStart(22));
    console.log('  Moved:        ', moved.padStart(22));
    console.log('  Balance:      ', balance.padStart(22));
  }

  return payload;
}

/**
 * Transfer credits to another account
 *
 * @param {object} options - Parsed Yargs options
 * @param {number} options.amount - Amount to transfer
 * @param {string} options.toAddress - Address to transfer to. If mixed case,
 * checksum will be validated
 * @returns {Promise<object>} Resolves to the requested FeeStructure
 */
async function transferCredits(options) {
  const amount = options.amount || options._[1];
  const toAccount = String(new Address(String(options.toAddress)));
  const ks = await getAccountKeystore();

  if (!options.quiet && !options.json) {
    console.log('Sending transfer');
    console.log(`  From Address: ${ks.address}`);
    console.log(`  To Address:   ${toAccount}`);
    console.log(`  Amount:       ${amount}`);
  }

  bankConnection = getBankConnection();

  try {
    const { payload } = await bankConnection.send(
      'transferCredits',
      {
        fromAccount: ks.address,
        toAccount,
        amount,
      },
      ks,
    );

    log(payload);

    if (options.json) {
      console.log(JSON.stringify(payload, null, 2));
    } else if (payload.name === 'Error') {
      console.error('Unable to complete transfer for the following reason:');
      console.error(payload.message);
    } else if (!options.quiet) {
      console.log('Transfer successful!');
    }

    return payload;
  } catch (error) {
    if (error.code === 'ENOFUNDS') {
      console.error('Error: Not enough credits in source account.');
      return error;
    }

    if (error.message.includes('Bad checksum for address')) {
      console.error(
        `Error: Address ${toAccount} has an invalid checksum. Please verify the address and try again.`,
      );

      return error;
    }

    throw error;
  }
}

main()
  .catch((error) => {
    console.error('045: Unexpected error:', error);
  })
  .finally(() => {
    if (
      typeof bankConnection === 'object' &&
      (bankConnection.usable || !bankConnection.closed)
    ) {
      log('Disconnecting from Bank...');
      bankConnection.close();
    }
  });
