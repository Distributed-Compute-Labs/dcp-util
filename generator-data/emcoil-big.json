{"request":"main","data":{"ranges":[[0,500],{"start":0,"end":100,"step":0.0002,"group":1},[1],[9460000],[0.01],[0.01],[0.01],[0.05],[0.01],[59000000],[1],[0.01],[32000000],[1]]},"arguments":[1,0.000004,50],"public":{"name":"Electrodynamics@home","description":"Moving EM Coil in a Conducting Tube","link":"distributed.computer"},"worker":"module.declare([], (require, exports, module) => {\n          \n          function progress(n) {\n            if (typeof n === 'string' && n !== 'indeterminate') {\n              n = parseFloat(n) / 100\n            }\n            postMessage({\n              request: 'progress',\n              value: n\n            })\n            return true\n          }\n          exports.progress = progress\n          \n          addEventListener(\"message\", async (message) => {\n            const data = Array.isArray(message.data.data) ? message.data.data : [message.data.data]\n            const arguments = Array.isArray(message.data.arguments) ? message.data.arguments : [message.data.arguments]\n            switch (message.data.request) {\n              case 'main':\n              try {\n                const result = await (\n    function workerfn(...args) {\n      (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n// import SparcMath from './sparc-math/es6/sparc-math.js'\n// const { Complex, quad, struve: {struveL}, amos: {besselI, besselK} } = SparcMath\n\n// // window.SparcMath = SparcMath\n\n// Import from SparcMath\nlet SparcMath = require('../sparc-math/_es2015/sparc-math.js');\n// console.log(SparcMath);\nlet besselI = SparcMath.default.besseli;\nlet struveL = SparcMath.default.struvel;\nlet Complex = SparcMath.default.Complex;\nlet quad = SparcMath.default.quad;\nlet amos = SparcMath.default.amos;\nlet besselK = amos.besselK;\n\nif (typeof window !== 'undefined') {\n  window.SparcMath = SparcMath.default\n}\n\nif (typeof window === 'undefined' && typeof self !== 'undefined'){\n  window = self\n}\n\nconst _$_mu0 = 0;\nconst _$_n = 0;\nconst _$_i = 0;\nconst _$_wc = 0;\nconst _$_wa = 0;\nconst _$_R = 0;\nconst _$_mu1 = 0;\nconst _$_sigma1 = 0;\nconst _$_w1 = 0;\nconst _$_mu2 = 0;\nconst _$_sigma2 = 0;\nconst _$_w2 = 0;\nconst _$_f = 0;\nconst _$_v = 0;\n\nconst mu0 = _$_mu0 || 1.25663706e-6 //          - Vacuum permeability\n// const n = _$_n || 9.46e6            // m^-2     - Coil wire turn density\n// const i = _$_i || 1;                // A        - Coil current\n// const wc = _$_wc || 0.005;          // m        - Coil width\n// const wa = _$_wa || 0.005;          // m        - Air gap between coil and OUTER tube\n// const R = _$_R || 0.05;             // m        - Outer radius of OUTER tube\n// const mu1 = _$_mu1 || 200;          //          - Relative magnetic permeability of OUTER tube\n// const sigma1 = _$_sigma1 || 1.04e7; // S * m^-1 - Conductivity of OUTER tube\n// const w1 = _$_w1 || 0.005;          // m        - Thickness of OUTER tube\n// const mu2 = _$_mu2 || 0.9996        //          - Relative magnetic permeability of INNER tube\n// const sigma2 = _$_sigma2 || 2.22;   // S * m^-1 - Conductivity of INNER tube\n// const w2 = _$_w2 || 0.005;          // m        - Thickness of INNER tube\n// const f = _$_f || 1000;             // Hz       - Frequency of alternating current\n// const v = _$_v || 10;               // m * s^-1 - Coil velocity\n\n\n// Coil function sub-functions\n// function length(R, wa, wc) {\n//   return (0.000013 / (wc * (2 * (R + wa) + wc)))\n// }\n\nfunction struveL_besselK(k, ri, ro) {\n  let term1 = Complex.mul(besselK(1, k * ro), struveL(0, k * ro) * ro);\n  let term2 = Complex.mul(besselK(0, k * ro), struveL(1, k * ro) * ro);\n  let term3 = Complex.mul(besselK(1, k * ri), struveL(0, k * ri) * ri);\n  let term4 = Complex.mul(besselK(0, k * ri), struveL(1, k * ri) * ri);\n  return Complex.sub(Complex.add(term1, term2), Complex.add(term3, term4));\n}\n\n//Tube function sub-functions\nfunction Lambda1(k, sign, mu1, sigma1, f, v) {\n  return Complex.sqrt([k**2, (2 * Math.PI * f + sign * k * v) * mu0 * mu1 * sigma1]);\n}\n\nfunction Lambda2(k, sign, mu2, sigma2, f, v) {\n  return Complex.sqrt([k**2, (2 * Math.PI * f + sign * k * v) * mu0 * mu2 * sigma2]);\n}\n\nfunction scriptA(k, Lambda1, R, mu1) {\n  let Lambda1_a = Complex.mul(Lambda1, R);\n  let term1 = Complex.prod([k, besselK(0, k * R), besselI(1, Lambda1_a)]);\n  let term2 = Complex.prod([mu1, Lambda1, besselI(0, Lambda1_a), besselK(1, k * R)]);\n  return Complex.add(term1, term2);\n}\n\nfunction scriptB(k, Lambda1, R, mu1) {\n  let Lambda1_a = Complex.mul(Lambda1, R);\n  let term1 = Complex.prod([k, besselK(0, k * R), besselK(1, Lambda1_a)]);\n  let term2 = Complex.prod([mu1, Lambda1, besselK(0, Lambda1_a), besselK(1, k * R)]);\n  return Complex.sub(term1, term2);\n}\n\nfunction scriptC(k, Lambda1, R, mu1) {\n  let Lambda1_a = Complex.mul(Lambda1, R);\n  let term1 = Complex.prod([k, besselI(0, k * R), besselI(1, Lambda1_a)]);\n  let term2 = Complex.prod([mu1, Lambda1, besselI(0, Lambda1_a), besselI(1, k * R)]);\n  return Complex.sub(term1, term2);\n}\n\nfunction scriptD(k, Lambda1, R, mu1) {\n  let a = R\n  let Lambda1_a = Complex.mul(Lambda1, a);\n  let term1 = Complex.prod([k, besselI(0, k * a), besselK(1, Lambda1_a)]);\n  let term2 = Complex.prod([mu1, Lambda1, besselK(0, Lambda1_a), besselI(1, k * a)]);\n  return Complex.add(term1, term2);\n}\n\nfunction scriptE(k, Lambda1, Lambda2, R, w1, mu1, mu2) {\n  let b = R - w1;\n  let Lambda1_b = Complex.mul(Lambda1, b);\n  let Lambda2_b = Complex.mul(Lambda2, b);\n  let term1 = Complex.prod([mu1, Lambda1, besselK(0, Lambda1_b), besselI(1, Lambda2_b)]);\n  let term2 = Complex.prod([mu2, Lambda2, besselI(0, Lambda2_b), besselK(1, Lambda1_b)]);\n  return Complex.add(term1, term2);\n}\n\nfunction scriptF(k, Lambda1, Lambda2, R, w1, mu1, mu2) {\n  let b = R - w1;\n  let Lambda1_b = Complex.mul(Lambda1, b);\n  let Lambda2_b = Complex.mul(Lambda2, b);\n  let term1 = Complex.prod([mu1, Lambda1, besselK(0, Lambda1_b), besselK(1, Lambda2_b)]);\n  let term2 = Complex.prod([mu2, Lambda2, besselK(0, Lambda2_b), besselK(1, Lambda1_b)]);\n  return Complex.sub(term1, term2);\n}\n\nfunction scriptG(k, Lambda1, Lambda2, R, w1, mu1, mu2) {\n  let b = R - w1;\n  let Lambda1_b = Complex.mul(Lambda1, b);\n  let Lambda2_b = Complex.mul(Lambda2, b);\n  let term1 = Complex.prod([mu1, Lambda1, besselI(0, Lambda1_b), besselK(1, Lambda2_b)]);\n  let term2 = Complex.prod([mu2, Lambda2, besselK(0, Lambda2_b), besselI(1, Lambda1_b)]);\n  return Complex.add(term1, term2);\n}\n\nfunction scriptH(k, Lambda1, Lambda2, R, w1, mu1, mu2) {\n  let b = R - w1;\n  let Lambda1_b = Complex.mul(Lambda1, b);\n  let Lambda2_b = Complex.mul(Lambda2, b);\n  let term1 = Complex.prod([mu1, Lambda1, besselI(0, Lambda1_b), besselI(1, Lambda2_b)]);\n  let term2 = Complex.prod([mu2, Lambda2, besselI(0, Lambda2_b), besselI(1, Lambda1_b)]);\n  return Complex.sub(term1, term2);\n}\n\nfunction scriptI(k, Lambda1, Lambda2, R, w1, w2, mu2) {\n  let c = R - (w1 + w2);\n  let Lambda2_c = Complex.mul(Lambda2, c);\n  let term1 = Complex.prod([mu2, Lambda2, besselK(0, Lambda2_c), besselI(1, k * c)]);\n  let term2 = Complex.prod([k, besselI(0, k * c), besselK(1, Lambda2_c)]);\n  return Complex.add(term1, term2);\n}\n\nfunction scriptK(k, Lambda1, Lambda2, R, w1, w2, mu2) {\n  let c = R - (w1 + w2);\n  let Lambda2_c = Complex.mul(Lambda2, c);\n  let term1 = Complex.prod([mu2, Lambda2, besselI(0, Lambda2_c), besselI(1, k * c)]);\n  let term2 = Complex.prod([k, besselI(0, k * c), besselI(1, Lambda2_c)]);\n  return Complex.sub(term1, term2);\n}\n\n\nfunction Gamma(k, Lambda1, Lambda2, R, w1, w2, mu1, mu2) {\n  let scriptE_scriptI = Complex.mul(scriptE(k, Lambda1, Lambda2, R, w1, mu1, mu2), scriptI(k, Lambda1, Lambda2, R, w1, w2, mu2));\n  let scriptF_scriptK = Complex.mul(scriptF(k, Lambda1, Lambda2, R, w1, mu1, mu2), scriptK(k, Lambda1, Lambda2, R, w1, w2, mu2));\n  let termEIFK = Complex.add(scriptE_scriptI, scriptF_scriptK);\n\n  let scriptG_scriptK = Complex.mul(scriptG(k, Lambda1, Lambda2, R, w1, mu1, mu2), scriptK(k, Lambda1, Lambda2, R, w1, w2, mu2));\n  let scriptH_scriptI = Complex.mul(scriptH(k, Lambda1, Lambda2, R, w1, mu1, mu2), scriptI(k, Lambda1, Lambda2, R, w1, w2, mu2));\n  let termGKHI = Complex.add(scriptG_scriptK, scriptH_scriptI);\n\n  let term1 = Complex.mul(scriptC(k, Lambda1, R, mu1), termEIFK);\n  let term2 = Complex.mul(scriptD(k, Lambda1, R, mu1), termGKHI);\n  let numerator = Complex.add(term1, term2)\n\n  let term3 = Complex.mul(scriptA(k, Lambda1, R, mu1), termEIFK);\n  let term4 = Complex.mul(scriptB(k, Lambda1, R, mu1), termGKHI);\n  let denominator = Complex.add(term3, term4)\n\n  return Complex.div(numerator, denominator);\n}\n\n\n//Axial Force\n// Integrand\nfunction axialForce(f,v,i,n,wc,l,wa,radius,w1,sigma1,mu1,w2,sigma2,mu2){\n  let func = function(k) {\n    let TubeFunc = Complex.sub(Gamma(k, Lambda1(k, 1, mu1, sigma1, f, v), Lambda2(k, 1, mu2, sigma2, f, v), radius, w1, w2, mu1, mu2),\n                               Gamma(k, Lambda1(k, -1, mu1, sigma1, f, v), Lambda2(k, -1, mu2, sigma2, f, v), radius, w1, w2, mu1, mu2)) [1];\n\n    let CoilFunc = -mu0 * (n * i * Math.PI * Math.sin(k * l / 2) * struveL_besselK(k, radius + wa, radius + wa + wc) / k) ** 2 / (2 * k);\n    return CoilFunc * TubeFunc;\n  }\n  // Integration\n  let epsabs = 1e-5;\n  let epsrel = 1e-5;\n  let limit = 1000;\n  let key = 1;\n  let min = 0;\n  // let max = Infinity;\n  let max = 500;  // Check that this int range makes sense.\n  let intResult = [];\n  let err1 = [];\n  let [result, absErr] = quad(func, min, max)\n\n  return -result;\n}\nwindow.axialForce = axialForce\n\n//Radial Force\n// Integrand\nfunction radialForce(f, v, i, n, wc, l, wa, radius, w1, sigma1, mu1, w2, sigma2, mu2){\n  let func = function(k) {\n    let TubeFunc = Complex.add(Gamma(k, Lambda1(k, 1, mu1, sigma1, f, v), Lambda2(k, 1, mu2, sigma2, f, v), radius, w1, w2, mu1, mu2),\n                               Gamma(k, Lambda1(k, -1, mu1, sigma1, f, v), Lambda2(k, -1, mu2, sigma2, f, v), radius, w1, w2, mu1, mu2)) [0];\n    let besselFunc = Complex.sub(Complex.mul((radius + wa + wc), besselK(1, k * 0.05)), Complex.mul((radius + wa), besselK(1, k * (radius + wa))));\n    let CoilFunc = -mu0 *  Math.PI * ((n * i * Math.sin(k * l / 2) / k) ** 2 ) * besselFunc * struveL_besselK(k, radius + wa, radius + wa + wc) / k;\n    return CoilFunc * TubeFunc;\n  }\n  // Integration\n  let epsabs = 1e-5;\n  let epsrel = 1e-5;\n  let limit = 1000;\n  let key = 1;\n  let min = 0;\n  // let max = Infinity;\n  let max = 500;  // Check that this int range makes sense.\n  let intResult = [];\n  let err1 = [];\n  let [result, absErr] = quad(func, min, max)\n\n  return result;\n}\nwindow.radialForce = radialForce\n\n// This function requires more work for the other inputs/loops.\nfunction main(df, dv) {\n  let results = [];\n  for (let f of df) {\n    for (let v of dv) {\n      //console.log(f,v);\n      results.push([R, wa, wc, mu1, sigma1, w1, mu2, sigma2, w2, f, v, Thrust(R, wa, wc, mu1, sigma1, w1, mu2, sigma2, w2, f, v)]);\n    }\n  }\n  return results;\n}\nwindow.main = main\n\n// let t0 = performance.now()\n// //  Thrust(radi,   wa,   wc, mu, sig,   w1, mu, sig,    w2,   f, v)\n// console.log(Thrust(0.05, 0.01, 0.01, 10, 5e6, 0.01, 25, 9e6, 0.01, 20, 5))\n// let t1 = performance.now()\n// console.log(\"Calculation took \" + (t1 - t0) + \" milliseconds.\")\n\nlet df = [];\nlet dv = [];\nfor (let f = 0; f <= 2000; f += 200){\n  df.push(f)\n}\nfor (let v = 0; v <= 100; v += 10){\n  dv.push(v)\n}\n\n// console.log(main(df,dv));\n\n// // Note to Dan, this is another variable that I search and replace\n// var $$body;\n//\n// global._main = main;\n// module.exports = { main };\n\n},{\"../sparc-math/_es2015/sparc-math.js\":95}],2:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.quad = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _dqagse3 = require('./quadpack/dqagse.js');\n\nvar _dqagie3 = require('./quadpack/dqagie.js');\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n// Compute a definite integral.\n//    Integrate func from `a` to `b` (possibly infinite interval) using a\n//    technique from the Fortran library QUADPACK.\n\nfunction quad(func, a, b) {\n  var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  var flip = void 0,\n      defaultOpts = void 0,\n      o = void 0,\n      retval = void 0,\n      ier = void 0,\n      msg = void 0,\n      msgs = void 0,\n      minPoint = void 0,\n      maxPoint = void 0,\n      condition = void 0,\n      limit = void 0;\n\n  defaultOpts = {\n    fullOutput: 0,\n    epsabs: 1.49e-8,\n    epsrel: 1.49e-8,\n    limit: 50,\n    points: null,\n    weight: null,\n    wvar: null,\n    wopts: null,\n    maxp1: 50,\n    limlst: 50\n  };\n  o = Object.assign(defaultOpts, opts);\n\n  var _ref = [b < a, Math.min(a, b), Math.max(a, b)];\n  flip = _ref[0];\n  a = _ref[1];\n  b = _ref[2];\n\n\n  if (o.weight === null) {\n    retval = _quad(func, a, b, o.fullOutput, o.epsabs, o.epsrel, o.limit, o.points);\n  } else {\n    // retval = _quad_weight(func, a, b, args, fullOutput, epsabs, epsrel, limlst, limit, maxp1, weight, wvar, wopts)\n    throw new Error('SciPy functionality not supported yet: weighted quad');\n  }\n\n  if (flip) retval[0] = -retval[0];\n  ier = retval.pop();\n  if (ier === 0) return retval;\n\n  // Non-zero exit code, throw descriptive error\n  msgs = {\n    '1': 'The maximum number of subdivisions (' + o.limit + ') has been achieved.\\n  If increasing the limit yields no improvement it is advised to analyze\\n  the integrand in order to determine the difficulties.  If the position of a\\n  local difficulty can be determined (singularity, discontinuity) one will\\n  probably gain from splitting up the interval and calling the integrator\\n  on the subranges.  Perhaps a special-purpose integrator should be used.',\n    '2': 'The occurrence of roundoff error is detected, which prevents\\n  the requested tolerance from being achieved.  The error may be\\n  underestimated.',\n    '3': 'Extremely bad integrand behavior occurs at some points of the\\n  integration interval.',\n    '4': 'The algorithm does not converge.  Roundoff error is detected\\n  in the extrapolation table.  It is assumed that the requested tolerance\\n  cannot be achieved, and that the returned result (if full_output = 1) is\\n  the best which can be obtained.',\n    '5': 'The integral is probably divergent, or slowly convergent.',\n    '6': 'The input is invalid.',\n    '7': 'Abnormal termination of the routine.  The estimates for result\\n  and error are less reliable.  It is assumed that the requested accuracy\\n  has not been achieved.',\n    'unknown': 'Unknown error.'\n\n    // TODO: implement weighted stuff\n    // if weight in ['cos','sin'] and (b===Inf or a===-Inf):\n    //     msgs[1] = \"The maximum number of cycles allowed has been achieved., e.e.\\n  of subintervals (a+(k-1)c, a+kc) where c = (2*int(abs(omega)+1))\\n  *pi/abs(omega), for k = 1, 2, ..., lst.  One can allow more cycles by increasing the value of limlst.  Look at info['ierlst'] with full_output=1.\"\n    //     msgs[4] = \"The extrapolation table constructed for convergence acceleration\\n  of the series formed by the integral contributions over the cycles, \\n  does not converge to within the requested accuracy.  Look at \\n  info['ierlst'] with full_output=1.\"\n    //     msgs[7] = \"Bad integrand behavior occurs within one or more of the cycles.\\n  Location and type of the difficulty involved can be determined from \\n  the vector info['ierlist'] obtained with full_output=1.\"\n    //     explain = {1: \"The maximum number of subdivisions (= limit) has been \\n  achieved on this cycle.\",\n    //                2: \"The occurrence of roundoff error is detected and prevents\\n  the tolerance imposed on this cycle from being achieved.\",\n    //                3: \"Extremely bad integrand behavior occurs at some points of\\n  this cycle.\",\n    //                4: \"The integral over this cycle does not converge (to within the required accuracy) due to roundoff in the extrapolation procedure invoked on this cycle.  It is assumed that the result on this interval is the best which can be obtained.\",\n    //                5: \"The integral over this cycle is probably divergent or slowly convergent.\"}\n\n  };msg = msgs[ier];\n  if (msg === undefined) msg = msgs['unknown'];\n  if ([1, 2, 3, 4, 5, 7].includes(ier)) {\n    if (o.fullOutput) {\n      // if weight in ['cos', 'sin'] and (b===Inf or a===Inf):\n      // return retval[:-1] + (msg, explain)\n      // else:\n      return retval.concat(msg);\n    } else {\n      console.warn('Integration Warning: ', msg);\n      return retval;\n    }\n  } else if (ier === 6) {\n    // # Forensic decision tree when QUADPACK throws ier=6\n    if (o.epsabs <= 0) {\n      // # Small error tolerance - applies to all methods\n      if (o.epsrel < Math.max(50 * Number.EPSILON, 5e-29)) {\n        msg = 'If \\'errabs\\'<=0, \\'epsrel\\' must be greater than both' + ('5e-29 and 50*(machine epsilon)[=' + 50 * Number.EPSILON + '].');\n      }\n      // elif weight in ['sin', 'cos'] and (abs(a) + abs(b)===Inf):\n      // msg = (\"Sine or cosine weighted intergals with infinite domain\" \" must have 'epsabs'>0.\")\n    } else if (o.weight === null) {\n      if (o.points === null) {\n        // QAGSE/QAGIE\n        msg = 'Invalid \\'limit\\' argument. There must be at least one subinterval';\n      } else {\n        // QAGPE\n        minPoint = Math.min.apply(Math, _toConsumableArray(o.points));\n        maxPoint = Math.max.apply(Math, _toConsumableArray(o.points));\n        condition = !(Math.min(a, b) <= minPoint && minPoint <= maxPoint && maxPoint <= Math.max(a, b));\n        if (condition) {\n          msg = 'All break points in \\'points\\' must lie within the integration limits.';\n        } else if (o.points.length >= limit) {\n          msg = 'Number of break points (' + o.points.length + ') must be less\\n                than subinterval limit (' + o.limit + ')';\n        }\n      }\n    } else {\n      if (o.maxp1 < 1) {\n        msg = 'Chebyshev moment limit maxp1 must be >=1.';\n      } else if (['cos', 'sin'].includes(o.weight) && Math.abs(a + b) === Infinity) {\n        // QAWFE\n        msg = 'Cycle limit limlst must be >=3.';\n      } else if (o.weight.startswith('alg')) {\n        // QAWSE\n        if (Math.min(o.wvar) < -1) {\n          msg = 'wvar parameters (alpha, beta) must both be >= -1.';\n        }\n        if (b < a) {\n          msg = 'Integration limits a, b must satistfy a<b.';\n        }\n      } else if (o.weight === 'cauchy' && [a, b].includes(o.wvar)) {\n        msg = 'Parameter \\'wvar\\' must not equal integration limits \\'a\\' or \\'b\\'.';\n      }\n    }\n  }\n  throw new Error(msg);\n}\n\n// RETURN: fullOutput ? [result, abserr, infoObj, ier] : [result, abserr, ier]\nfunction _quad(func, a, b, fullOutput, epsabs, epsrel, limit, points) {\n  var infbounds = void 0,\n      bound = void 0,\n      thePoints = void 0;\n\n  infbounds = 0;\n  if (b !== Infinity && a !== -Infinity) {\n    // pass   # standard integration\n  } else if (b === Infinity && a !== -Infinity) {\n    infbounds = 1;\n    bound = a;\n  } else if (b === Infinity && a === -Infinity) {\n    infbounds = 2;\n    bound = 0; // ignored\n  } else if (b !== Infinity && a === -Infinity) {\n    infbounds = -1;\n    bound = b;\n  } else {\n    // this is the python message, pretty sure we'll never hit it but we should have\n    // an error message in the else anyways\n    throw new Error('Infinity comparisons don\\'t work for you.');\n  }\n\n  if (points === null) {\n    if (infbounds === 0) {\n      return _qagse(func, a, b, fullOutput, epsabs, epsrel, limit);\n    } else {\n      return _qagie(func, bound, infbounds, fullOutput, epsabs, epsrel, limit);\n    }\n  } else {\n    if (infbounds !== 0) {\n      throw new Error('Infinity inputs cannot be used with break points.');\n    } else {\n      // Duplicates force function evaluation at singular points\n      thePoints = sortUnique(points);\n      thePoints = thePoints.filter(function (point) {\n        return point > a;\n      });\n      thePoints = thePoints.filter(function (point) {\n        return point < b;\n      });\n      thePoints = thePoints.concat([0, 0]);\n      return _qagpe(func, a, b, thePoints, fullOutput, epsabs, epsrel, limit);\n    }\n  }\n}\n\nfunction _qagse(func, a, b, fullOutput, epsabs, epsrel, limit) {\n  var iord = void 0,\n      alist = void 0,\n      blist = void 0,\n      rlist = void 0,\n      elist = void 0,\n      infoObj = void 0;\n  var neval = 0;\n  var ier = 6;\n  var last = 0;\n  var result = 0.0;\n  var abserr = 0.0;\n\n  /* Need to check that limit is bigger than 1 */\n  if (limit < 1) return [result, abserr, ier];\n\n  /* Setup iwork and work arrays */\n  iord = new Int32Array(limit);\n  alist = new Float64Array(limit);\n  blist = new Float64Array(limit);\n  rlist = new Float64Array(limit);\n  elist = new Float64Array(limit);\n\n  var _dqagse = (0, _dqagse3.dqagse)(func, a, b, epsabs, epsrel, limit, result, abserr, neval, ier, alist, blist, rlist, elist, iord, last);\n\n  var _dqagse2 = _slicedToArray(_dqagse, 6);\n\n  result = _dqagse2[0];\n  abserr = _dqagse2[1];\n  neval = _dqagse2[2];\n  ier = _dqagse2[3];\n  iord = _dqagse2[4];\n  last = _dqagse2[5];\n\n\n  if (fullOutput) {\n    infoObj = { 'neval': neval,\n      'last': last,\n      'iord': iord,\n      'alist': alist,\n      'blist': blist,\n      'rlist': rlist,\n      'elist': elist };\n    return [result, abserr, infoObj, ier];\n  } else {\n    return [result, abserr, ier];\n  }\n}\n\nfunction _qagie(func, bound, inf, fullOutput, epsabs, epsrel, limit) {\n  var iord = void 0,\n      alist = void 0,\n      blist = void 0,\n      rlist = void 0,\n      elist = void 0,\n      infoObj = void 0;\n  var neval = 0;\n  var ier = 6;\n  var last = 0;\n  var result = 0.0;\n  var abserr = 0.0;\n\n  /* Need to check that limit is bigger than 1 */\n  if (limit < 1) return [result, abserr, ier];\n\n  /* Setup iwork and work arrays */\n  iord = new Int32Array(limit);\n  alist = new Float64Array(limit);\n  blist = new Float64Array(limit);\n  rlist = new Float64Array(limit);\n  elist = new Float64Array(limit);\n\n  var _dqagie = (0, _dqagie3.dqagie)(func, bound, inf, epsabs, epsrel, limit, result, abserr, neval, ier, alist, blist, rlist, elist, iord, last);\n\n  var _dqagie2 = _slicedToArray(_dqagie, 10);\n\n  result = _dqagie2[0];\n  abserr = _dqagie2[1];\n  neval = _dqagie2[2];\n  ier = _dqagie2[3];\n  alist = _dqagie2[4];\n  blist = _dqagie2[5];\n  rlist = _dqagie2[6];\n  elist = _dqagie2[7];\n  iord = _dqagie2[8];\n  last = _dqagie2[9];\n\n\n  if (fullOutput) {\n    infoObj = { 'neval': neval,\n      'last': last,\n      'iord': iord,\n      'alist': alist,\n      'blist': blist,\n      'rlist': rlist,\n      'elist': elist };\n    return [result, abserr, infoObj, ier];\n  } else {\n    return [result, abserr, ier];\n  }\n}\n\nfunction _qagpe(func, a, b, thePoints, fullOutput, epsabs, epsrel, limit) {\n  var neval = void 0,\n      ier = void 0,\n      last = void 0,\n      result = void 0,\n      abserr = void 0,\n      npts2 = void 0,\n      iord = void 0,\n      alist = void 0,\n      blist = void 0,\n      rlist = void 0,\n      elist = void 0,\n      pts = void 0,\n      level = void 0,\n      ndin = void 0,\n      dqagpe = void 0;\n  neval = 0;\n  ier = 6;\n  last = 0;\n  result = 0.0;\n  abserr = 0.0;\n\n  /* Need to check that limit is bigger than 1 */\n  if (limit < 1) return [result, abserr, ier];\n  npts2 = thePoints.length;\n\n  /* Setup iwork and work arrays */\n  iord = new Int32Array(limit);\n  alist = new Float64Array(limit);\n  blist = new Float64Array(limit);\n  rlist = new Float64Array(limit);\n  elist = new Float64Array(limit);\n  pts = new Float64Array(npts2);\n  level = new Float64Array(limit);\n  ndin = new Float64Array(npts2);\n\n  var _dqagpe = dqagpe(func, a, b, npts2, thePoints, epsabs, epsrel, limit, result, abserr, neval, ier, alist, blist, rlist, elist, pts, iord, level, ndin, last);\n\n  var _dqagpe2 = _slicedToArray(_dqagpe, 13);\n\n  result = _dqagpe2[0];\n  abserr = _dqagpe2[1];\n  neval = _dqagpe2[2];\n  ier = _dqagpe2[3];\n  alist = _dqagpe2[4];\n  blist = _dqagpe2[5];\n  rlist = _dqagpe2[6];\n  elist = _dqagpe2[7];\n  pts = _dqagpe2[8];\n  iord = _dqagpe2[9];\n  level = _dqagpe2[10];\n  ndin = _dqagpe2[11];\n  last = _dqagpe2[12];\n\n\n  if (fullOutput) {\n    var infoObj = {\n      'neval': neval,\n      'last': last,\n      'iord': iord,\n      'alist': alist,\n      'blist': blist,\n      'rlist': rlist,\n      'elist': elist,\n      'pts': pts,\n      'level': level,\n      'ndin': ndin\n    };\n    return [result, abserr, infoObj, ier];\n  } else {\n    return [result, abserr, ier];\n  }\n}\n\n// https:// stackoverflow.com/questions/4833651/javascript-array-sort-and-unique\nfunction sortUnique(arr) {\n  if (arr.length === 0) return arr;\n  arr = arr.sort(function (a, b) {\n    return a * 1 - b * 1;\n  });\n  var ret = [arr[0]];\n  for (var i = 1; i < arr.length; i++) {\n    // Start loop at 1: arr[0] can never be a duplicate\n    if (arr[i - 1] !== arr[i]) {\n      ret.push(arr[i]);\n    }\n  }\n  return ret;\n}\n\nexports.quad = quad;\n},{\"./quadpack/dqagie.js\":3,\"./quadpack/dqagse.js\":4}],3:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); /* eslint-disable no-labels */\n/* eslint-disable no-fallthrough */\n\n\nexports.dqagie = dqagie;\n\nvar _d1mach = require('../../utils/fortran-utils/d1mach.js');\n\nvar _dqk15i7 = require('./dqk15i.js');\n\nvar _dqpsrt3 = require('./dqpsrt.js');\n\nvar _dqelg3 = require('./dqelg.js');\n\nfunction dqagie(f, bound, inf, epsabs, epsrel, limit, result, abserr, neval, ier, alist, blist, rlist, elist, iord, last) {\n  var abseps = void 0,\n      area = void 0,\n      area1 = void 0,\n      area12 = void 0,\n      area2 = void 0,\n      a1 = void 0,\n      a2 = void 0,\n      boun = void 0,\n      b1 = void 0,\n      b2 = void 0,\n      correc = void 0,\n      defabs = void 0,\n      defab1 = void 0,\n      defab2 = void 0,\n      dres = void 0,\n      epmach = void 0,\n      erlarg = void 0,\n      erlast = void 0,\n      errbnd = void 0,\n      errmax = void 0,\n      error1 = void 0,\n      error2 = void 0,\n      erro12 = void 0,\n      errsum = void 0,\n      ertest = void 0,\n      oflow = void 0,\n      resabs = void 0,\n      reseps = void 0,\n      res3la = void 0,\n      rlist2 = void 0,\n      small = void 0,\n      uflow = void 0,\n      id = void 0,\n      ierro = void 0,\n      iroff1 = void 0,\n      iroff2 = void 0,\n      iroff3 = void 0,\n      jupbnd = void 0,\n      k = void 0,\n      ksgn = void 0,\n      ktmin = void 0,\n      maxerr = void 0,\n      nres = void 0,\n      nrmax = void 0,\n      numrl2 = void 0,\n      extrap = void 0,\n      noext = void 0,\n      condition = void 0;\n\n  res3la = new Float64Array(3);\n  rlist2 = new Float64Array(52);\n\n  var goToLabel = 0;\n  mainExecutionLoop: while (true) {\n    switch (goToLabel) {\n      case 0:\n        epmach = (0, _d1mach.d1mach)(4);\n        //\n        //           test on validity of parameters\n        //           -----------------------------\n        //\n        ier = 0;\n        neval = 0;\n        last = 0;\n        result = 0.0e+00;\n        abserr = 0.0e+00;\n        alist[0] = 0.0e+00;\n        blist[0] = 0.1e+01;\n        rlist[0] = 0.0e+00;\n        elist[0] = 0.0e+00;\n        iord[0] = 0;\n        if (epsabs <= 0.0e+00 && epsrel < Math.max(0.5e+02 * epmach, 0.5e-28)) ier = 6;\n        if (ier === 6) {\n          goToLabel = 999;break;\n        }\n        //\n        //\n        //           first approximation to the integral\n        //           -----------------------------------\n        //\n        //           determine the interval to be mapped onto (0,1).\n        //           if inf = 2 the integral is computed as i = i1+i2, where\n        //           i1 = integral of f over (-infinity,0),\n        //           i2 = integral of f over (0,+infinity).\n        //\n        boun = bound;\n        if (inf === 2) boun = 0.0e+00;\n\n        //\n        //           test on accuracy\n        //\n        var _dqk15i = (0, _dqk15i7.dqk15i)(f, boun, inf, 0.0e+00, 0.1e+01, result, abserr, defabs, resabs);\n\n        var _dqk15i2 = _slicedToArray(_dqk15i, 4);\n\n        result = _dqk15i2[0];\n        abserr = _dqk15i2[1];\n        defabs = _dqk15i2[2];\n        resabs = _dqk15i2[3];\n        last = 1;\n        rlist[0] = result;\n        elist[0] = abserr;\n        iord[0] = 1;\n        dres = Math.abs(result);\n        errbnd = Math.max(epsabs, epsrel * dres);\n        if (abserr <= 1.0e+02 * epmach * defabs && abserr > errbnd) ier = 2;\n        if (limit === 1) ier = 1;\n        if (ier !== 0 || abserr <= errbnd && abserr !== resabs || abserr === 0.0e+00) {\n          goToLabel = 130;break;\n        }\n        //\n        //           initialization\n        //           --------------\n        //\n        uflow = (0, _d1mach.d1mach)(1);\n        oflow = (0, _d1mach.d1mach)(2);\n        rlist2[0] = result;\n        errmax = abserr;\n        maxerr = 1;\n        area = result;\n        errsum = abserr;\n        abserr = oflow;\n        nrmax = 1;\n        nres = 0;\n        ktmin = 0;\n        numrl2 = 2;\n        extrap = false;\n        noext = false;\n        ierro = 0;\n        iroff1 = 0;\n        iroff2 = 0;\n        iroff3 = 0;\n        ksgn = -1;\n        if (dres >= (0.1e+01 - 0.5e+02 * epmach) * defabs) ksgn = 1;\n        //\n        //           main do-loop\n        //           ------------\n        //\n        for (last = 2; last <= limit; last++) {\n          //\n          //           bisect the subinterval with nrmax-th largest error estimate.\n          //\n          a1 = alist[maxerr - 1];\n          b1 = 0.5e+00 * (alist[maxerr - 1] + blist[maxerr - 1]);\n          a2 = b1;\n          b2 = blist[maxerr - 1];\n          erlast = errmax;\n\n          var _dqk15i3 = (0, _dqk15i7.dqk15i)(f, boun, inf, a1, b1, area1, error1, resabs, defab1);\n\n          var _dqk15i4 = _slicedToArray(_dqk15i3, 4);\n\n          area1 = _dqk15i4[0];\n          error1 = _dqk15i4[1];\n          resabs = _dqk15i4[2];\n          defab1 = _dqk15i4[3];\n\n          //\n          //           improve previous approximations to integral\n          //           and error and test for accuracy.\n          //\n          var _dqk15i5 = (0, _dqk15i7.dqk15i)(f, boun, inf, a2, b2, area2, error2, resabs, defab2);\n\n          var _dqk15i6 = _slicedToArray(_dqk15i5, 4);\n\n          area2 = _dqk15i6[0];\n          error2 = _dqk15i6[1];\n          resabs = _dqk15i6[2];\n          defab2 = _dqk15i6[3];\n          area12 = area1 + area2;\n          erro12 = error1 + error2;\n          errsum = errsum + erro12 - errmax;\n          area = area + area12 - rlist[maxerr - 1];\n          if (defab1 === error1 || defab2 === error2) {\n            // GO TO 15\n          } else {\n            condition = Math.abs(rlist[maxerr - 1] - area12) > 0.1e-04 * Math.abs(area12) || erro12 < 0.99e+00 * errmax;\n            if (condition) {\n              // GO TO 10\n            } else {\n              if (extrap) iroff2 = iroff2 + 1;\n              if (!extrap) iroff1 = iroff1 + 1;\n            }\n            // LABEL 10\n            if (last > 10 && erro12 > errmax) iroff3 = iroff3 + 1;\n          }\n          // LABEL 15:\n          rlist[maxerr - 1] = area1;\n          rlist[last - 1] = area2;\n          errbnd = Math.max(epsabs, epsrel * Math.abs(area));\n          //\n          //           test for roundoff error and eventually set error flag.\n          //\n          if (iroff1 + iroff2 >= 10 || iroff3 >= 20) ier = 2;\n          if (iroff2 >= 5) ierro = 3;\n          //\n          //           set error flag in the case that the number of\n          //           subintervals equals limit.\n          //\n          if (last === limit) ier = 1;\n          //\n          //           set error flag in the case of bad integrand behaviour\n          //           at some points of the integration range.\n          //\n          condition = Math.max(Math.abs(a1), Math.abs(b2)) <= (0.1e+01 + 0.1e+03 * epmach) * (Math.abs(a2) + 0.1e+04 * uflow);\n          if (condition) ier = 4;\n          //\n          //           append the newly-created intervals to the list.\n          //\n          if (error2 > error1) {\n            alist[maxerr - 1] = a2;\n            alist[last - 1] = a1;\n            blist[last - 1] = b1;\n            rlist[maxerr - 1] = area2;\n            rlist[last - 1] = area1;\n            elist[maxerr - 1] = error2;\n            elist[last - 1] = error1;\n          } else {\n            alist[last - 1] = a2;\n            blist[maxerr - 1] = b1;\n            blist[last - 1] = b2;\n            elist[maxerr - 1] = error1;\n            elist[last - 1] = error2;\n          }\n          // LABEL 30\n\n          //\n          //           subroutine() dqpsrt to maintain the descending ordering\n          //           in the list of error estimates and select the subinterval\n          //           with nrmax-th largest error estimate (to be bisected next).\n          //\n\n          var _dqpsrt = (0, _dqpsrt3.dqpsrt)(limit, last, maxerr, errmax, elist, iord, nrmax);\n\n          var _dqpsrt2 = _slicedToArray(_dqpsrt, 4);\n\n          maxerr = _dqpsrt2[0];\n          errmax = _dqpsrt2[1];\n          iord = _dqpsrt2[2];\n          nrmax = _dqpsrt2[3];\n\n          if (errsum <= errbnd) {\n            goToLabel = 115;break;\n          }\n          if (ier !== 0) {\n            goToLabel = 100;break;\n          }\n          if (last === 2) {\n            // GO TO 80\n          } else {\n            if (noext) continue;\n            erlarg = erlarg - erlast;\n            if (Math.abs(b1 - a1) > small) erlarg = erlarg + erro12;\n            if (extrap) {\n              // goToLabel = 40; break;\n            } else {\n              //\n              //           test whether the interval to be bisected next is the\n              //           smallest interval.\n              //\n              if (Math.abs(blist[maxerr - 1] - alist[maxerr - 1]) > small) continue;\n              extrap = true;\n              nrmax = 2;\n            }\n            if (ierro === 3 || erlarg <= ertest) {\n              // goToLabel = 60; break;\n            } else {\n              //\n              //           the smallest interval has the largest error.\n              //           before bisecting decrease the sum of the errors over the\n              //           larger intervals (erlarg) and perform extrapolation.\n              //\n              id = nrmax;\n              jupbnd = last;\n              if (last > 2 + Math.trunc(limit / 2)) jupbnd = limit + 3 - last;\n              for (k = id; k <= jupbnd; k++) {\n                maxerr = iord[nrmax - 1];\n                errmax = elist[maxerr - 1];\n                if (Math.abs(blist[maxerr - 1] - alist[maxerr - 1]) > small) continue;\n                nrmax = nrmax + 1;\n              }\n            }\n            //\n            //           perform extrapolation.\n            //\n            // case 60:\n            numrl2 = numrl2 + 1;\n            rlist2[numrl2 - 1] = area;\n\n            var _dqelg = (0, _dqelg3.dqelg)(numrl2, rlist2, reseps, abseps, res3la, nres);\n\n            var _dqelg2 = _slicedToArray(_dqelg, 4);\n\n            numrl2 = _dqelg2[0];\n            reseps = _dqelg2[1];\n            abseps = _dqelg2[2];\n            nres = _dqelg2[3];\n\n            ktmin = ktmin + 1;\n            if (ktmin > 5 && abserr < 0.1e-02 * errsum) ier = 5;\n            if (abseps >= abserr) {\n              // goToLabel = 70; break;\n            } else {\n              ktmin = 0;\n              abserr = abseps;\n              result = reseps;\n              correc = erlarg;\n              ertest = Math.max(epsabs, epsrel * Math.abs(reseps));\n              if (abserr <= ertest) {\n                goToLabel = 100;break;\n              }\n            }\n            //\n            //            prepare bisection of the smallest interval.\n            //\n            if (numrl2 === 1) noext = true;\n            if (ier === 5) {\n              goToLabel = 100;break;\n            }\n            maxerr = iord[0];\n            errmax = elist[maxerr - 1];\n            nrmax = 1;\n            extrap = false;\n            small = small * 0.5e+00;\n            erlarg = errsum;\n            continue;\n          }\n          // case 80:\n          small = 0.375e+00;\n          erlarg = errsum;\n          ertest = errbnd;\n          rlist2[1] = area;\n        } // end of loop\n        if (goToLabel > 100) break;\n      case 100:\n        //\n        //           set final result and error estimate.\n        //           ------------------------------------\n        //\n        if (abserr === oflow) {\n          goToLabel = 115;break;\n        }\n        if (ier + ierro === 0) {\n          goToLabel = 110;break;\n        }\n        if (ierro === 3) abserr = abserr + correc;\n        if (ier === 0) ier = 3;\n        if (result !== 0.0e+00 && area !== 0.0e+00) {\n          goToLabel = 105;break;\n        }\n        if (abserr > errsum) {\n          goToLabel = 115;break;\n        }\n        if (area === 0.0e+00) {\n          goToLabel = 130;break;\n        }\n        goToLabel = 110;break;\n      case 105:\n        if (abserr / Math.abs(result) > errsum / Math.abs(area)) {\n          goToLabel = 115;break;\n        }\n      //\n      //           test on divergence\n      //\n      case 110:\n        if (ksgn === -1 && Math.max(Math.abs(result), Math.abs(area)) <= defabs * 0.1e-01) {\n          goToLabel = 130;break;\n        }\n        if (result / area < 0.1e-01 || result / area > 0.1e+03 || errsum > Math.abs(area)) ier = 6;\n        goToLabel = 130;break;\n      //\n      //           compute global integral sum.\n      //\n      case 115:\n        result = 0.0e+00;\n        for (k = 1; k <= last; k++) {\n          result = result + rlist[k - 1];\n        }\n        abserr = errsum;\n      case 130:\n        neval = 30 * last - 15;\n        if (inf === 2) neval = 2 * neval;\n        if (ier > 2) ier = ier - 1;\n      case 999:\n\n      default:\n        break mainExecutionLoop;\n    }\n  }\n  return [result, abserr, neval, ier, alist, blist, rlist, elist, iord, last];\n}\n},{\"../../utils/fortran-utils/d1mach.js\":91,\"./dqelg.js\":5,\"./dqk15i.js\":6,\"./dqpsrt.js\":8}],4:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); /* eslint-disable no-labels */\n/* eslint-disable no-fallthrough */\n\n\nexports.dqagse = dqagse;\n\nvar _d1mach = require('../../utils/fortran-utils/d1mach.js');\n\nvar _dqk7 = require('./dqk21.js');\n\nvar _dqpsrt3 = require('./dqpsrt.js');\n\nvar _dqelg3 = require('./dqelg.js');\n\nfunction dqagse(f, a, b, epsabs, epsrel, limit, result, abserr, neval, ier, alist, blist, rlist, elist, iord, last) {\n  var abseps = void 0,\n      area = void 0,\n      area1 = void 0,\n      area12 = void 0,\n      area2 = void 0,\n      a1 = void 0,\n      a2 = void 0,\n      b1 = void 0,\n      b2 = void 0,\n      correc = void 0,\n      defabs = void 0,\n      defab1 = void 0,\n      defab2 = void 0,\n      dres = void 0,\n      epmach = void 0,\n      erlarg = void 0,\n      erlast = void 0,\n      errbnd = void 0,\n      errmax = void 0,\n      error1 = void 0,\n      error2 = void 0,\n      erro12 = void 0,\n      errsum = void 0,\n      ertest = void 0,\n      oflow = void 0,\n      resabs = void 0,\n      reseps = void 0,\n      res3la = void 0,\n      rlist2 = void 0,\n      small = void 0,\n      uflow = void 0,\n      id = void 0,\n      ierro = void 0,\n      iroff1 = void 0,\n      iroff2 = void 0,\n      iroff3 = void 0,\n      jupbnd = void 0,\n      k = void 0,\n      ksgn = void 0,\n      ktmin = void 0,\n      maxerr = void 0,\n      nres = void 0,\n      nrmax = void 0,\n      numrl2 = void 0,\n      extrap = void 0,\n      noext = void 0;\n\n  res3la = new Float64Array(3);\n  rlist2 = new Float64Array(52);\n\n  var goToLabel = 0;\n  mainExecutionLoop: while (true) {\n    switch (goToLabel) {\n      case 0:\n        epmach = (0, _d1mach.d1mach)(4);\n        //\n        //            test on validity of parameters\n        //            ------------------------------\n        ier = 0;\n        neval = 0;\n        last = 0;\n        result = 0.0e+00;\n        abserr = 0.0e+00;\n        alist[0] = a;\n        blist[0] = b;\n        rlist[0] = 0.0e+00;\n        elist[0] = 0.0e+00;\n        if (epsabs <= 0.0e+00 && epsrel < Math.max(0.5e+02 * epmach, 0.5e-28)) ier = 6;\n        if (ier === 6) {\n          goToLabel = 999;break;\n        }\n        //\n        //           first approximation to the integral\n        //           -----------------------------------\n        //\n        uflow = (0, _d1mach.d1mach)(1);\n        oflow = (0, _d1mach.d1mach)(2);\n        ierro = 0;\n\n        //\n        //           test on accuracy.\n        //\n        var _dqk = (0, _dqk7.dqk21)(f, a, b, result, abserr, defabs, resabs);\n\n        var _dqk2 = _slicedToArray(_dqk, 4);\n\n        result = _dqk2[0];\n        abserr = _dqk2[1];\n        defabs = _dqk2[2];\n        resabs = _dqk2[3];\n        dres = Math.abs(result);\n        errbnd = Math.max(epsabs, epsrel * dres);\n        last = 1;\n        rlist[0] = result;\n        elist[0] = abserr;\n        iord[0] = 1;\n        if (abserr <= 1.0e+02 * epmach * defabs && abserr > errbnd) ier = 2;\n        if (limit === 1) ier = 1;\n        if (ier !== 0 || abserr <= errbnd && abserr !== resabs || abserr === 0) {\n          goToLabel = 140;break;\n        }\n        //\n        //           initialization\n        //           --------------\n        //\n        rlist2[0] = result;\n        errmax = abserr;\n        maxerr = 1;\n        area = result;\n        errsum = abserr;\n        abserr = oflow;\n        nrmax = 1;\n        nres = 0;\n        numrl2 = 2;\n        ktmin = 0;\n        extrap = false;\n        noext = false;\n        iroff1 = 0;\n        iroff2 = 0;\n        iroff3 = 0;\n        ksgn = -1;\n        if (dres >= (0.1e+01 - 0.5e+02 * epmach) * defabs) ksgn = 1;\n        //\n        //           main do-loop\n        //           ------------\n        //\n        mainDoLoop: for (last = 2; last <= limit; last++) {\n          //\n          //           bisect the subinterval with the nrmax-th largest error\n          //           estimate.\n          //\n          a1 = alist[maxerr - 1];\n          b1 = 0.5e+00 * (alist[maxerr - 1] + blist[maxerr - 1]);\n          a2 = b1;\n          b2 = blist[maxerr - 1];\n          erlast = errmax;\n\n          var _dqk3 = (0, _dqk7.dqk21)(f, a1, b1, area1, error1, resabs, defab1);\n\n          var _dqk4 = _slicedToArray(_dqk3, 4);\n\n          area1 = _dqk4[0];\n          error1 = _dqk4[1];\n          resabs = _dqk4[2];\n          defab1 = _dqk4[3];\n\n          //\n          //           improve previous approximations to integral\n          //           and error and test for accuracy.\n          //\n          var _dqk5 = (0, _dqk7.dqk21)(f, a2, b2, area2, error2, resabs, defab2);\n\n          var _dqk6 = _slicedToArray(_dqk5, 4);\n\n          area2 = _dqk6[0];\n          error2 = _dqk6[1];\n          resabs = _dqk6[2];\n          defab2 = _dqk6[3];\n          area12 = area1 + area2;\n          erro12 = error1 + error2;\n          errsum = errsum + erro12 - errmax;\n          area = area + area12 - rlist[maxerr - 1];\n          if (defab1 === error1 || defab2 === error2) {\n            // goToLabel = 15; break;\n          } else {\n            if (Math.abs(rlist[maxerr - 1] - area12) > 0.1e-04 * Math.abs(area12) || erro12 < 0.99e+00 * errmax) {\n              // goToLabel = 10; break;\n            } else {\n              if (extrap) iroff2 = iroff2 + 1;\n              if (!extrap) iroff1 = iroff1 + 1;\n            }\n            // case 10:\n            if (last > 10 && erro12 > errmax) iroff3 = iroff3 + 1;\n          }\n          // case 15:\n          rlist[maxerr - 1] = area1;\n          rlist[last - 1] = area2;\n          errbnd = Math.max(epsabs, epsrel * Math.abs(area));\n          //\n          //           test for roundoff error and eventually set error flag.\n          //\n          if (iroff1 + iroff2 >= 10 || iroff3 >= 20) ier = 2;\n          if (iroff2 >= 5) ierro = 3;\n          //\n          //           set error flag in the case that the number of subintervals\n          //           equals limit.\n          //\n          if (last === limit) ier = 1;\n          //\n          //           set error flag in the case of bad integrand behaviour\n          //           at a point of the integration range.\n          //\n          if (Math.max(Math.abs(a1), Math.abs(b2)) <= (0.1e+01 + 0.1e+03 * epmach) * (Math.abs(a2) + 0.1e+04 * uflow)) ier = 4;\n          //\n          //           append the newly-created intervals to the list.\n          //\n          if (error2 > error1) {\n            alist[maxerr - 1] = a2;\n            alist[last - 1] = a1;\n            blist[last - 1] = b1;\n            rlist[maxerr - 1] = area2;\n            rlist[last - 1] = area1;\n            elist[maxerr - 1] = error2;\n            elist[last - 1] = error1;\n          } else {\n            alist[last - 1] = a2;\n            blist[maxerr - 1] = b1;\n            blist[last - 1] = b2;\n            elist[maxerr - 1] = error1;\n            elist[last - 1] = error2;\n          }\n          //\n          //           subroutine() dqpsrt to maintain the descending ordering\n          //           in the list of error estimates and select the subinterval\n          //           with nrmax-th largest error estimate (to be bisected next).\n          //\n\n          // ***jump out of do-loop\n          var _dqpsrt = (0, _dqpsrt3.dqpsrt)(limit, last, maxerr, errmax, elist, iord, nrmax);\n\n          var _dqpsrt2 = _slicedToArray(_dqpsrt, 4);\n\n          maxerr = _dqpsrt2[0];\n          errmax = _dqpsrt2[1];\n          iord = _dqpsrt2[2];\n          nrmax = _dqpsrt2[3];\n          if (errsum <= errbnd) {\n            goToLabel = 115;break;\n          }\n          // ***jump out of do-loop\n          if (ier !== 0) {\n            goToLabel = 100;break;\n          }\n          if (last === 2) {\n            // goToLabel = 80; break;\n          } else {\n            if (noext) continue;\n            erlarg = erlarg - erlast;\n            if (Math.abs(b1 - a1) > small) erlarg = erlarg + erro12;\n            if (extrap) {\n              // goToLabel = 40; break;\n            } else {\n              //\n              //           test whether the interval to be bisected next is the\n              //           smallest interval.\n              //\n              if (Math.abs(blist[maxerr - 1] - alist[maxerr - 1]) > small) continue;\n              extrap = true;\n              nrmax = 2;\n            }\n            // case 40:\n            if (ierro === 3 || erlarg <= ertest) {\n              // goToLabel = 60; break;\n            } else {\n              //\n              //           the smallest interval has the largest error.\n              //           before bisecting decrease the sum of the errors over the\n              //           larger intervals (erlarg) and perform extrapolation.\n              //\n              id = nrmax;\n              jupbnd = last;\n              if (last > 2 + Math.trunc(limit / 2)) jupbnd = limit + 3 - last;\n              for (k = id; k <= jupbnd; k++) {\n                maxerr = iord[nrmax - 1];\n                errmax = elist[maxerr - 1];\n                // ***jump out of do-loop\n                if (Math.abs(blist[maxerr - 1] - alist[maxerr - 1]) > small) continue mainDoLoop;\n                nrmax = nrmax + 1;\n              }\n            }\n\n            //\n            //           perform extrapolation.\n            //\n            // case 60:\n            numrl2 = numrl2 + 1;\n            rlist2[numrl2 - 1] = area;\n\n            var _dqelg = (0, _dqelg3.dqelg)(numrl2, rlist2, reseps, abseps, res3la, nres);\n\n            var _dqelg2 = _slicedToArray(_dqelg, 4);\n\n            numrl2 = _dqelg2[0];\n            reseps = _dqelg2[1];\n            abseps = _dqelg2[2];\n            nres = _dqelg2[3];\n\n            ktmin = ktmin + 1;\n            if (ktmin > 5 && abserr < 0.1e-02 * errsum) ier = 5;\n            if (abseps >= abserr) {\n              // goToLabel = 70; break;\n            } else {\n              ktmin = 0;\n              abserr = abseps;\n              result = reseps;\n              correc = erlarg;\n              ertest = Math.max(epsabs, epsrel * Math.abs(reseps));\n              // ***jump out of do-loop\n              if (abserr <= ertest) {\n                goToLabel = 100;break;\n              }\n            }\n\n            //\n            //           prepare bisection of the smallest interval.\n            //\n            // case 70:\n            if (numrl2 === 1) noext = true;\n            if (ier === 5) {\n              goToLabel = 100;break;\n            }\n            maxerr = iord[0];\n            errmax = elist[maxerr - 1];\n            nrmax = 1;\n            extrap = false;\n            small = small * 0.5e+00;\n            erlarg = errsum;\n            continue;\n          }\n          // case 80:\n          small = Math.abs(b - a) * 0.375e+00;\n          erlarg = errsum;\n          ertest = errbnd;\n          rlist2[1] = area;\n        }\n        if (goToLabel > 100) break;\n      //\n      //           set final result and error estimate.\n      //           ------------------------------------\n      //\n      case 100:\n        if (abserr === oflow) {\n          goToLabel = 115;break;\n        }\n        if (ier + ierro === 0) {\n          goToLabel = 110;break;\n        }\n        if (ierro === 3) abserr = abserr + correc;\n        if (ier === 0) ier = 3;\n        if (result !== 0.0e+00 && area !== 0.0e+00) {\n          goToLabel = 105;break;\n        }\n        if (abserr > errsum) {\n          goToLabel = 115;break;\n        }\n        if (area === 0.0e+00) {\n          goToLabel = 130;break;\n        }\n        goToLabel = 110;break;\n      case 105:\n        if (abserr / Math.abs(result) > errsum / Math.abs(area)) {\n          goToLabel = 115;break;\n        }\n      //\n      //           test on divergence.\n      //\n      case 110:\n        if (ksgn === -1 && Math.max(Math.abs(result), Math.abs(area)) <= defabs * 0.1e-01) {\n          goToLabel = 130;break;\n        }\n        if (result / area < 0.1e-01 || result / area > 0.1e+03 || errsum > Math.abs(area)) ier = 6;\n        goToLabel = 130;break;\n      //\n      //           compute global integral sum.\n      //\n      case 115:\n        result = 0.0e+00;\n        for (k = 1; k <= last; k++) {\n          result = result + rlist[k - 1];\n        }\n        abserr = errsum;\n      case 130:\n        if (ier > 2) ier = ier - 1;\n      case 140:\n        neval = 42 * last - 21;\n      case 999:\n      default:\n        break mainExecutionLoop;\n    }\n  }\n  return [result, abserr, neval, ier, iord, last];\n}\n},{\"../../utils/fortran-utils/d1mach.js\":91,\"./dqelg.js\":5,\"./dqk21.js\":7,\"./dqpsrt.js\":8}],5:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.dqelg = dqelg;\n\nvar _d1mach = require('../../utils/fortran-utils/d1mach.js');\n\nfunction dqelg(n, epstab, result, abserr, res3la, nres) {\n  var delta1 = void 0,\n      delta2 = void 0,\n      delta3 = void 0,\n      epmach = void 0,\n      epsinf = void 0,\n      error = void 0,\n      err1 = void 0,\n      err2 = void 0,\n      err3 = void 0,\n      e0 = void 0,\n      e1 = void 0,\n      e1abs = void 0,\n      e2 = void 0,\n      e3 = void 0,\n      oflow = void 0,\n      res = void 0,\n      ss = void 0,\n      tol1 = void 0,\n      tol2 = void 0,\n      tol3 = void 0,\n      i = void 0,\n      ib = void 0,\n      ib2 = void 0,\n      ie = void 0,\n      indx = void 0,\n      k1 = void 0,\n      k2 = void 0,\n      k3 = void 0,\n      limexp = void 0,\n      newelm = void 0,\n      num = void 0;\n  var goToLabel = 0;\n  mainExecutionLoop: while (true) {\n    switch (goToLabel) {\n      case 0:\n        epmach = (0, _d1mach.d1mach)(4);\n        oflow = (0, _d1mach.d1mach)(2);\n        nres = nres + 1;\n        abserr = oflow;\n        result = epstab[n - 1];\n        if (n < 3) {\n          goToLabel = 100;break;\n        }\n        limexp = 50;\n        epstab[n + 1] = epstab[n - 1];\n        newelm = (n - 1) / 2;\n        epstab[n - 1] = oflow;\n        num = n;\n        k1 = n;\n        for (i = 1; i <= newelm; i++) {\n          k2 = k1 - 1;\n          k3 = k1 - 2;\n          res = epstab[k1 + 1];\n          e0 = epstab[k3 - 1];\n          e1 = epstab[k2 - 1];\n          e2 = res;\n          e1abs = Math.abs(e1);\n          delta2 = e2 - e1;\n          err2 = Math.abs(delta2);\n          tol2 = Math.max(Math.abs(e2), e1abs) * epmach;\n          delta3 = e1 - e0;\n          err3 = Math.abs(delta3);\n          tol3 = Math.max(e1abs, Math.abs(e0)) * epmach;\n          if (err2 > tol2 || err3 > tol3) {\n            // goToLabel = 10; break;\n          } else {\n            //\n            //           if e0, e1 and e2 are equal to within machine\n            //           accuracy, convergence is assumed.\n            //           result = e2\n            //           abserr = Math.abs(e1-e0)+Math.abs(e2-e1)\n            //\n            result = res;\n            abserr = err2 + err3;\n            // ***jump out of do-loop\n            goToLabel = 100;break;\n          }\n          // case 10:\n          e3 = epstab[k1 - 1];\n          epstab[k1 - 1] = e1;\n          delta1 = e1 - e3;\n          err1 = Math.abs(delta1);\n          tol1 = Math.max(e1abs, Math.abs(e3)) * epmach;\n          //\n          //           if two elements are very close to each other, omit\n          //           a part of the table by adjusting the value of n\n          //\n          if (err1 <= tol1 || err2 <= tol2 || err3 <= tol3) {\n            n = i + i - 1;\n            // ***jump out of do-loop\n            goToLabel = 50;break;\n          }\n          ss = 0.1e+01 / delta1 + 0.1e+01 / delta2 - 0.1e+01 / delta3;\n          epsinf = Math.abs(ss * e1);\n          //\n          //           test to detect irregular behaviour in the table, and\n          //           eventually omit a part of the table adjusting the value\n          //           of n.\n          //\n          if (epsinf > 0.1e-03) {\n            // goToLabel = 30; break;\n          } else {\n            n = i + i - 1;\n            // ***jump out of do-loop\n            goToLabel = 50;break;\n          }\n          //\n          //           compute a new element and eventually adjust\n          //           the value of result.\n          //\n          // case 30:\n          res = e1 + 0.1e+01 / ss;\n          epstab[k1 - 1] = res;\n          k1 = k1 - 2;\n          error = err2 + Math.abs(res - e2) + err3;\n          if (error > abserr) continue;\n          abserr = error;\n          result = res;\n        }\n        if (goToLabel > 50) break;\n      //\n      //           shift the table.\n      //\n      case 50:\n        if (n === limexp) n = 2 * Math.trunc(limexp / 2) - 1;\n        ib = 1;\n        if (Math.trunc(num / 2) * 2 === num) ib = 2;\n        ie = newelm + 1;\n        for (i = 1; i <= ie; i++) {\n          ib2 = ib + 2;\n          epstab[ib - 1] = epstab[ib2 - 1];\n          ib = ib2;\n        }\n        if (num === n) {\n          goToLabel = 80;break;\n        }\n        indx = num - n + 1;\n        for (i = 1; i <= n; i++) {\n          epstab[i - 1] = epstab[indx - 1];\n          indx = indx + 1;\n        }\n      case 80:\n        if (nres >= 4) {\n          goToLabel = 90;break;\n        }\n        res3la[nres - 1] = result;\n        abserr = oflow;\n        goToLabel = 100;break;\n      //\n      //           compute error estimate\n      //\n      case 90:\n        abserr = Math.abs(result - res3la[2]) + Math.abs(result - res3la[1]) + Math.abs(result - res3la[0]);\n        res3la[0] = res3la[1];\n        res3la[1] = res3la[2];\n        res3la[2] = result;\n      case 100:\n        abserr = Math.max(abserr, 0.5e+01 * epmach * Math.abs(result));\n      default:\n        break mainExecutionLoop;\n    }\n  }\n  return [n, result, abserr, nres];\n} /* eslint-disable no-labels */\n/* eslint-disable no-fallthrough */\n},{\"../../utils/fortran-utils/d1mach.js\":91}],6:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.dqk15i = dqk15i;\n\nvar _d1mach = require('../../utils/fortran-utils/d1mach.js');\n\nfunction dqk15i(f, boun, inf, a, b, result, abserr, resabs, resasc) {\n  var absc = void 0,\n      absc1 = void 0,\n      absc2 = void 0,\n      centr = void 0,\n      dinf = void 0,\n      epmach = void 0,\n      fc = void 0,\n      fsum = void 0,\n      fval1 = void 0,\n      fval2 = void 0,\n      fv1 = void 0,\n      fv2 = void 0,\n      hlgth = void 0,\n      resg = void 0,\n      resk = void 0,\n      reskh = void 0,\n      tabsc1 = void 0,\n      tabsc2 = void 0,\n      uflow = void 0,\n      wg = void 0,\n      wgk = void 0,\n      xgk = void 0,\n      j = void 0;\n\n  fv1 = new Float64Array(7);\n  fv2 = new Float64Array(7);\n  xgk = new Float64Array(8);\n  wgk = new Float64Array(8);\n  wg = new Float64Array(8);\n\n  var goToLabel = 0;\n  mainExecutionLoop: while (true) {\n    switch (goToLabel) {\n      case 0:\n        wg[0] = 0.0e0;\n        wg[1] = 0.129484966168869693270611432679082e0;\n        wg[2] = 0.0e0;\n        wg[3] = 0.279705391489276667901467771423780e0;\n        wg[4] = 0.0e0;\n        wg[5] = 0.381830050505118944950369775488975e0;\n        wg[6] = 0.0e0;\n        wg[7] = 0.417959183673469387755102040816327e0;\n        //\n        xgk[0] = 0.991455371120812639206854697526329e0;\n        xgk[1] = 0.949107912342758524526189684047851e0;\n        xgk[2] = 0.864864423359769072789712788640926e0;\n        xgk[3] = 0.741531185599394439863864773280788e0;\n        xgk[4] = 0.586087235467691130294144838258730e0;\n        xgk[5] = 0.405845151377397166906606412076961e0;\n        xgk[6] = 0.207784955007898467600689403773245e0;\n        xgk[7] = 0.000000000000000000000000000000000e0;\n        //\n        wgk[0] = 0.022935322010529224963732008058970e0;\n        wgk[1] = 0.063092092629978553290700663189204e0;\n        wgk[2] = 0.104790010322250183839876322541518e0;\n        wgk[3] = 0.140653259715525918745189590510238e0;\n        wgk[4] = 0.169004726639267902826583426598550e0;\n        wgk[5] = 0.190350578064785409913256402421014e0;\n        wgk[6] = 0.204432940075298892414161999234649e0;\n        wgk[7] = 0.209482141084727828012999174891714e0;\n        //\n        epmach = (0, _d1mach.d1mach)(4);\n        uflow = (0, _d1mach.d1mach)(1);\n        dinf = Math.min(1, inf);\n        //\n        centr = 0.5e+00 * (a + b);\n        hlgth = 0.5e+00 * (b - a);\n        tabsc1 = boun + dinf * (0.1e+01 - centr) / centr;\n        fval1 = f(tabsc1);\n        if (inf === 2) fval1 = fval1 + f(-tabsc1);\n        fc = fval1 / centr / centr;\n        //\n        //           compute the 15-point kronrod approximation to\n        //           the integral, and estimate the error.\n        //\n        resg = wg[7] * fc;\n        resk = wgk[7] * fc;\n        resabs = Math.abs(resk);\n        for (j = 1; j <= 7; j++) {\n          absc = hlgth * xgk[j - 1];\n          absc1 = centr - absc;\n          absc2 = centr + absc;\n          tabsc1 = boun + dinf * (0.1e+01 - absc1) / absc1;\n          tabsc2 = boun + dinf * (0.1e+01 - absc2) / absc2;\n          fval1 = f(tabsc1);\n          fval2 = f(tabsc2);\n          if (isNaN(fval1)) {}\n          if (inf === 2) fval1 = fval1 + f(-tabsc1);\n          if (inf === 2) fval2 = fval2 + f(-tabsc2);\n          fval1 = fval1 / absc1 / absc1;\n          fval2 = fval2 / absc2 / absc2;\n          fv1[j - 1] = fval1;\n          fv2[j - 1] = fval2;\n          fsum = fval1 + fval2;\n          resg = resg + wg[j - 1] * fsum;\n          resk = resk + wgk[j - 1] * fsum;\n          resabs = resabs + wgk[j - 1] * (Math.abs(fval1) + Math.abs(fval2));\n        }\n        reskh = resk * 0.5e+00;\n        resasc = wgk[7] * Math.abs(fc - reskh);\n        for (j = 1; j <= 7; j++) {\n          resasc = resasc + wgk[j - 1] * (Math.abs(fv1[j - 1] - reskh) + Math.abs(fv2[j - 1] - reskh));\n        }\n        result = resk * hlgth;\n        resasc = resasc * hlgth;\n        resabs = resabs * hlgth;\n        abserr = Math.abs((resk - resg) * hlgth);\n        if (resasc !== 0.0e+00 && abserr !== 0.e0) {\n          abserr = resasc * Math.min(0.1e+01, (0.2e+03 * abserr / resasc) ** 1.5e+00);\n        }\n        if (resabs > uflow / (0.5e+02 * epmach)) abserr = Math.max(epmach * 0.5e+02 * resabs, abserr);\n      default:\n        break mainExecutionLoop;\n    }\n  }\n  return [result, abserr, resabs, resasc];\n} /* eslint-disable no-labels */\n/* eslint-disable no-fallthrough */\n},{\"../../utils/fortran-utils/d1mach.js\":91}],7:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.dqk21 = dqk21;\n\nvar _d1mach = require('../../utils/fortran-utils/d1mach.js');\n\nfunction dqk21(f, a, b, result, abserr, resabs, resasc) {\n  var absc = void 0,\n      centr = void 0,\n      dhlgth = void 0,\n      epmach = void 0,\n      fc = void 0,\n      fsum = void 0,\n      fval1 = void 0,\n      fval2 = void 0,\n      fv1 = void 0,\n      fv2 = void 0,\n      hlgth = void 0,\n      resg = void 0,\n      resk = void 0,\n      reskh = void 0,\n      uflow = void 0,\n      wg = void 0,\n      wgk = void 0,\n      xgk = void 0,\n      j = void 0,\n      jtw = void 0,\n      jtwm1 = void 0;\n\n  fv1 = new Float64Array(10);\n  fv2 = new Float64Array(10);\n  wg = new Float64Array(5);\n  wgk = new Float64Array(11);\n  xgk = new Float64Array(11);\n\n  var goToLabel = 0;\n  mainExecutionLoop: while (true) {\n    switch (goToLabel) {\n      case 0:\n        wg[0] = 0.066671344308688137593568809893332e0;\n        wg[1] = 0.149451349150580593145776339657697e0;\n        wg[2] = 0.219086362515982043995534934228163e0;\n        wg[3] = 0.269266719309996355091226921569469e0;\n        wg[4] = 0.295524224714752870173892994651338e0;\n        //\n        xgk[0] = 0.995657163025808080735527280689003e0;\n        xgk[1] = 0.973906528517171720077964012084452e0;\n        xgk[2] = 0.930157491355708226001207180059508e0;\n        xgk[3] = 0.865063366688984510732096688423493e0;\n        xgk[4] = 0.780817726586416897063717578345042e0;\n        xgk[5] = 0.679409568299024406234327365114874e0;\n        xgk[6] = 0.562757134668604683339000099272694e0;\n        xgk[7] = 0.433395394129247190799265943165784e0;\n        xgk[8] = 0.294392862701460198131126603103866e0;\n        xgk[9] = 0.148874338981631210884826001129720e0;\n        xgk[10] = 0.000000000000000000000000000000000e0;\n        //\n        wgk[0] = 0.011694638867371874278064396062192e0;\n        wgk[1] = 0.032558162307964727478818972459390e0;\n        wgk[2] = 0.054755896574351996031381300244580e0;\n        wgk[3] = 0.075039674810919952767043140916190e0;\n        wgk[4] = 0.093125454583697605535065465083366e0;\n        wgk[5] = 0.109387158802297641899210590325805e0;\n        wgk[6] = 0.123491976262065851077958109831074e0;\n        wgk[7] = 0.134709217311473325928054001771707e0;\n        wgk[8] = 0.142775938577060080797094273138717e0;\n        wgk[9] = 0.147739104901338491374841515972068e0;\n        wgk[10] = 0.149445554002916905664936468389821e0;\n        //\n        epmach = (0, _d1mach.d1mach)(4);\n        uflow = (0, _d1mach.d1mach)(1);\n        //\n        centr = 0.5e+00 * (a + b);\n        hlgth = 0.5e+00 * (b - a);\n        dhlgth = Math.abs(hlgth);\n        //\n        //           compute the 21-point kronrod approximation to\n        //           the integral, and estimate the absolute error.\n        //\n        resg = 0.0e+00;\n        fc = f(centr);\n        resk = wgk[10] * fc;\n        resabs = Math.abs(resk);\n        for (j = 1; j <= 5; j++) {\n          jtw = 2 * j;\n          absc = hlgth * xgk[jtw - 1];\n          fval1 = f(centr - absc);\n          fval2 = f(centr + absc);\n          fv1[jtw - 1] = fval1;\n          fv2[jtw - 1] = fval2;\n          fsum = fval1 + fval2;\n          resg = resg + wg[j - 1] * fsum;\n          resk = resk + wgk[jtw - 1] * fsum;\n          resabs = resabs + wgk[jtw - 1] * (Math.abs(fval1) + Math.abs(fval2));\n        }\n        for (j = 1; j <= 5; j++) {\n          jtwm1 = 2 * j - 1;\n          absc = hlgth * xgk[jtwm1 - 1];\n          fval1 = f(centr - absc);\n          fval2 = f(centr + absc);\n          fv1[jtwm1 - 1] = fval1;\n          fv2[jtwm1 - 1] = fval2;\n          fsum = fval1 + fval2;\n          resk = resk + wgk[jtwm1 - 1] * fsum;\n          resabs = resabs + wgk[jtwm1 - 1] * (Math.abs(fval1) + Math.abs(fval2));\n        }\n        reskh = resk * 0.5e+00;\n        resasc = wgk[10] * Math.abs(fc - reskh);\n        for (j = 1; j <= 10; j++) {\n          resasc = resasc + wgk[j - 1] * (Math.abs(fv1[j - 1] - reskh) + Math.abs(fv2[j - 1] - reskh));\n        }\n        result = resk * hlgth;\n        resabs = resabs * dhlgth;\n        resasc = resasc * dhlgth;\n        abserr = Math.abs((resk - resg) * hlgth);\n        if (resasc !== 0.0e+00 && abserr !== 0.0e+00) {\n          abserr = resasc * Math.min(0.1e+01, (0.2e+03 * abserr / resasc) ** 1.5e+00);\n        }\n        if (resabs > uflow / (0.5e+02 * epmach)) abserr = Math.max(epmach * 0.5e+02 * resabs, abserr);\n      default:\n        break mainExecutionLoop;\n    }\n  }\n  return [result, abserr, resabs, resasc];\n} /* eslint-disable no-labels */\n/* eslint-disable no-fallthrough */\n},{\"../../utils/fortran-utils/d1mach.js\":91}],8:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.dqpsrt = dqpsrt;\n/* eslint-disable no-labels */\n/* eslint-disable no-fallthrough */\nfunction dqpsrt(limit, last, maxerr, ermax, elist, iord, nrmax) {\n  var errmax = void 0,\n      errmin = void 0,\n      i = void 0,\n      ibeg = void 0,\n      ido = void 0,\n      isucc = void 0,\n      j = void 0,\n      jbnd = void 0,\n      jupbn = void 0,\n      k = void 0;\n  var goToLabel = 0;\n  mainExecutionLoop: while (true) {\n    switch (goToLabel) {\n      case 0:\n        //\n        //           check whether the list contains more than\n        //           two error estimates.\n        //\n        if (last > 2) {\n          goToLabel = 10;break;\n        }\n        iord[0] = 1;\n        iord[1] = 2;\n        goToLabel = 90;break;\n      //\n      //           this part of the routine is only executed if, due to a\n      //           difficult integrand, subdivision increased the error\n      //           estimate. in the normal case the insert procedure should\n      //           start after the nrmax-th largest error estimate.\n      //\n      case 10:\n        errmax = elist[maxerr - 1];\n        if (nrmax === 1) {\n          goToLabel = 30;break;\n        }\n        ido = nrmax - 1;\n        for (i = 1; i <= ido; i++) {\n          isucc = iord[nrmax - 2];\n          // ***jump out of do-loop\n          if (errmax <= elist[isucc - 1]) {\n            goToLabel = 30;break;\n          }\n          iord[nrmax - 1] = isucc;\n          nrmax = nrmax - 1;\n        }\n\n      //\n      //           compute the number of elements in the list to be maintained\n      //           in descending order. this number depends on the number of\n      //           subdivisions still allowed.\n      //\n      case 30:\n        jupbn = last;\n        if (last > Math.trunc(limit / 2) + 2) jupbn = limit + 3 - last;\n        errmin = elist[last - 1];\n        //\n        //           insert errmax by traversing the list top-down,\n        //           starting comparison from the element elist(iord(nrmax+1)).\n        //\n        jbnd = jupbn - 1;\n        ibeg = nrmax + 1;\n        if (ibeg > jbnd) {\n          goToLabel = 50;break;\n        }\n        for (i = ibeg; i <= jbnd; i++) {\n          isucc = iord[i - 1];\n          // ***jump out of do-loop\n          if (errmax >= elist[isucc - 1]) {\n            goToLabel = 60;break;\n          }\n          iord[i - 2] = isucc;\n        }\n        if (goToLabel === 60) break;\n      case 50:\n        iord[jbnd - 1] = maxerr;\n        iord[jupbn - 1] = last;\n        goToLabel = 90;break;\n      //\n      //           insert errmin by traversing the list bottom-up.\n      //\n      case 60:\n        iord[i - 2] = maxerr;\n        k = jbnd;\n        for (j = i; j <= jbnd; j++) {\n          isucc = iord[k - 1];\n          // ***jump out of do-loop\n          if (errmin < elist[isucc - 1]) {\n            goToLabel = 80;break;\n          }\n          iord[k] = isucc;\n          k = k - 1;\n        }\n        if (goToLabel === 80) break;\n        iord[i - 1] = last;\n        goToLabel = 90;break;\n      case 80:\n        iord[k] = last;\n      //\n      //           set maxerr and ermax.\n      //\n      case 90:\n        maxerr = iord[nrmax - 1];\n        ermax = elist[maxerr - 1];\n      default:\n        break mainExecutionLoop;\n    }\n  }\n  return [maxerr, ermax, iord, nrmax];\n}\n},{}],9:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.airyB = exports.airyA = exports.besselH = exports.besselK = exports.besselI = exports.besselY = exports.besselJ = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _complex = require('../utils/complex.js');\n\nvar _complex2 = _interopRequireDefault(_complex);\n\nvar _zbesj = require('./amos/zbesj.js');\n\nvar _zbesy = require('./amos/zbesy.js');\n\nvar _zbesi = require('./amos/zbesi.js');\n\nvar _zbesk = require('./amos/zbesk.js');\n\nvar _zbesh = require('./amos/zbesh.js');\n\nvar _zairy = require('./amos/zairy.js');\n\nvar _zbiry = require('./amos/zbiry.js');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar INPUT_ERROR = 'INPUT ERROR - NO COMPUTATION';\nvar OVERFLOW = 'OVERFLOW - NO COMPUTATION, ';\nvar DEFAULT_OVERFLOW = 'FNU IS TOO LARGE OR CABS(Z) IS TOO SMALL OR BOTH';\nvar HALF_ACCURACY = 'CABS(Z) OR FNU+N-1 LARGE - COMPUTATION DONE BUT LOSSES OF' + ' SIGNIFICANCE BY ARGUMENT REDUCTION PRODUCE LESS THAN HALF OF MACHINE ACCURACY.';\nvar TOO_LARGE = 'CABS(Z) OR FNU+N-1 TOO LARGE - NO COMPUTATION BECAUSE OF' + ' COMPLETE LOSSES OF SIGNIFICANCE BY ARGUMENT REDUCTION.';\nvar TERMINATION = 'ERROR - NO COMPUTATION ALGORITHM TERMINATION CONDITION NOT MET';\n\nfunction besselCommon(nu, z, func, overflowMessage) {\n  var hankelType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\n  var nz = void 0,\n      ierr = void 0;\n  z = _complex2.default.ensureComplex(z);\n  var n = 1;\n  var cyr = new Array(1);\n  var cyi = new Array(1);\n  if (hankelType) {\n    var _func = func(z[0], z[1], nu, 1, hankelType, n, cyr, cyi);\n\n    var _func2 = _slicedToArray(_func, 2);\n\n    nz = _func2[0];\n    ierr = _func2[1];\n  } else {\n    var _func3 = func(z[0], z[1], nu, 1, n, cyr, cyi);\n\n    var _func4 = _slicedToArray(_func3, 2);\n\n    nz = _func4[0];\n    ierr = _func4[1];\n  }\n\n  checkUnderflow(nz, func);\n  checkErrorCode(ierr, overflowMessage, func);\n  return [cyr[0], cyi[0]];\n}\n\nfunction airyCommon(z, func, overflowMessage) {\n  z = _complex2.default.ensureComplex(z);\n\n  var _func5 = func(z[0], z[1], 0, 1),\n      _func6 = _slicedToArray(_func5, 4),\n      air = _func6[0],\n      aii = _func6[1],\n      nz = _func6[2],\n      ierr = _func6[3];\n\n  checkUnderflow(nz, func);\n  checkErrorCode(ierr, overflowMessage, func);\n  return [air, aii];\n}\n\nfunction besselJ(nu, z) {\n  var overflowMessage = 'AIMAG(Z) TOO LARGE ON KODE=1';\n  return besselCommon(nu, z, _zbesj.zbesj, overflowMessage);\n}\n\nfunction besselY(nu, z) {\n  var overflowMessage = DEFAULT_OVERFLOW;\n  return besselCommon(nu, z, _zbesy.zbesy, overflowMessage);\n}\n\nfunction besselI(nu, z) {\n  var overflowMessage = 'REAL(Z) TOO LARGE ON KODE=1';\n  return besselCommon(nu, z, _zbesi.zbesi, overflowMessage);\n}\n\nfunction besselK(nu, z) {\n  var overflowMessage = DEFAULT_OVERFLOW;\n  return besselCommon(nu, z, _zbesk.zbesk, overflowMessage);\n}\n\n// Hankel functions type 1 or type 2\nfunction besselH(nu, z, type) {\n  var overflowMessage = DEFAULT_OVERFLOW;\n  return besselCommon(nu, z, _zbesh.zbesh, overflowMessage, type);\n}\n\nfunction airyA(z) {\n  var overflowMessage = 'REAL(ZTA) TOO LARGE ON KODE=1';\n  return airyCommon(z, _zairy.zairy, overflowMessage);\n}\n\nfunction airyB(z) {\n  var overflowMessage = 'REAL(Z) TOO LARGE ON KODE=1';\n  return airyCommon(z, _zbiry.zbiry, overflowMessage);\n}\n\nfunction checkUnderflow(nz, func) {\n  if (nz !== 0) {\n    console.warn(func.name + ' returned nonzero number of underflows');\n  }\n}\n\nfunction checkErrorCode(ierr, overflowMessage, func) {\n  switch (ierr) {\n    case 0:\n      // NORMAL RETURN - COMPUTATION COMPLETED\n      break;\n    case 1:\n      throw new Error(INPUT_ERROR);\n    case 2:\n      throw new Error(OVERFLOW + overflowMessage);\n    case 3:\n      throw new Error(HALF_ACCURACY);\n    case 4:\n      throw new Error(TOO_LARGE);\n    case 5:\n      throw new Error(TERMINATION);\n    default:\n      throw new Error('Unexpected error code from ' + func.name);\n  }\n}\n\nexports.besselJ = besselJ;\nexports.besselY = besselY;\nexports.besselI = besselI;\nexports.besselK = besselK;\nexports.besselH = besselH;\nexports.airyA = airyA;\nexports.airyB = airyB;\n},{\"../utils/complex.js\":89,\"./amos/zairy.js\":14,\"./amos/zbesh.js\":16,\"./amos/zbesi.js\":17,\"./amos/zbesj.js\":18,\"./amos/zbesk.js\":19,\"./amos/zbesy.js\":20,\"./amos/zbiry.js\":22}],10:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.dgamln = dgamln;\n\nvar _d1mach = require('../../utils/fortran-utils/d1mach.js');\n\nvar _i1mach = require('../../utils/fortran-utils/i1mach.js');\n\n// DOUBLE PRECISION FUNCTION DGAMLN(Z,IERR)\n// ***BEGIN PROLOGUE  DGAMLN\n// ***DATE WRITTEN        830501   (YYMMDD)\n// ***REVISION DATE       830501   (YYMMDD)\n// ***PORT TO ECMASCRIPT  201801   (YYYYMM)\n// ***CATEGORY NO.  B5F\n// ***KEYWORDS  GAMMA FUNCTION,LOGARITHM OF GAMMA FUNCTION\n// ***AUTHOR (FORTRAN)  AMOS, DONALD E., SANDIA NATIONAL LABORATORIES\n// ***AUTHOR (ECMASCRIPT) ERB, KC, KINGS DISTRIBUTED SYSTEMS\n// ***PURPOSE  TO COMPUTE THE LOGARITHM OF THE GAMMA FUNCTION\n// ***DESCRIPTION\n//\n//                **** A DOUBLE PRECISION ROUTINE ****\n//          DGAMLN COMPUTES THE NATURAL LOG OF THE GAMMA FUNCTION FOR\n//          Z.GT.0.  THE ASYMPTOTIC EXPANSION IS USED TO GENERATE VALUES\n//          GREATER THAN ZMIN WHICH ARE ADJUSTED BY THE RECURSION\n//          G(Z+1)=Z*G(Z) FOR Z.LE.ZMIN.  THE FUNCTION WAS MADE AS\n//          PORTABLE AS POSSIBLE BY COMPUTIMG ZMIN FROM THE NUMBER OF BASE\n//          10 DIGITS IN A WORD, RLN=AMAX1(-ALOG10(R1MACH(4)),0.5E-18)\n//          LIMITED TO 18 DIGITS OF (RELATIVE) ACCURACY.\n//\n//          SINCE INTEGER ARGUMENTS ARE COMMON, A TABLE LOOK UP ON 100\n//          VALUES IS USED FOR SPEED OF EXECUTION.\n//\n//      DESCRIPTION OF ARGUMENTS\n//\n//          INPUT      Z IS D0UBLE PRECISION\n//            Z      - ARGUMENT, Z.GT.0.0D0\n//\n//          OUTPUT      DGAMLN IS DOUBLE PRECISION\n//            DGAMLN  - NATURAL LOG OF THE GAMMA FUNCTION AT Z.NE.0.0D0\n//\n//\n// ***REFERENCES  COMPUTATION OF BESSEL FUNCTIONS OF COMPLEX ARGUMENT\n//                  BY D. E. AMOS, SAND83-0083, MAY, 1983.\n// ***ROUTINES CALLED  I1MACH,D1MACH\n// ***END PROLOGUE  DGAMLN\nfunction dgamln(z) {\n  var cf = void 0,\n      con = void 0,\n      fln = void 0,\n      fz = void 0,\n      gln = void 0,\n      rln = void 0,\n      s = void 0,\n      tlg = void 0,\n      trm = void 0,\n      tst = void 0,\n      t1 = void 0,\n      wdtol = void 0,\n      zdmy = void 0,\n      zinc = void 0,\n      zm = void 0,\n      zmin = void 0,\n      zp = void 0,\n      zsq = void 0,\n      i = void 0,\n      i1m = void 0,\n      k = void 0,\n      mz = void 0,\n      nz = void 0;\n  gln = [0.00000000000000000e+00, 0.00000000000000000e+00, 6.93147180559945309e-01, 1.79175946922805500e+00, 3.17805383034794562e+00, 4.78749174278204599e+00, 6.57925121201010100e+00, 8.52516136106541430e+00, 1.06046029027452502e+01, 1.28018274800814696e+01, 1.51044125730755153e+01, 1.75023078458738858e+01, 1.99872144956618861e+01, 2.25521638531234229e+01, 2.51912211827386815e+01, 2.78992713838408916e+01, 3.06718601060806728e+01, 3.35050734501368889e+01, 3.63954452080330536e+01, 3.93398841871994940e+01, 4.23356164607534850e+01, 4.53801388984769080e+01, 4.84711813518352239e+01, 5.16066755677643736e+01, 5.47847293981123192e+01, 5.80036052229805199e+01, 6.12617017610020020e+01, 6.45575386270063311e+01, 6.78897431371815350e+01, 7.12570389671680090e+01, 7.46582363488301644e+01, 7.80922235533153106e+01, 8.15579594561150372e+01, 8.50544670175815174e+01, 8.85808275421976788e+01, 9.21361756036870925e+01, 9.57196945421432025e+01, 9.93306124547874269e+01, 1.02968198614513813e+02, 1.06631760260643459e+02, 1.10320639714757395e+02, 1.14034211781461703e+02, 1.17771881399745072e+02, 1.21533081515438634e+02, 1.25317271149356895e+02, 1.29123933639127215e+02, 1.32952575035616310e+02, 1.36802722637326368e+02, 1.40673923648234259e+02, 1.44565743946344886e+02, 1.48477766951773032e+02, 1.52409592584497358e+02, 1.56360836303078785e+02, 1.60331128216630907e+02, 1.64320112263195181e+02, 1.68327445448427652e+02, 1.72352797139162802e+02, 1.76395848406997352e+02, 1.80456291417543771e+02, 1.84533828861449491e+02, 1.88628173423671591e+02, 1.92739047287844902e+02, 1.96866181672889994e+02, 2.01009316399281527e+02, 2.05168199482641199e+02, 2.09342586752536836e+02, 2.13532241494563261e+02, 2.17736934113954227e+02, 2.21956441819130334e+02, 2.26190548323727593e+02, 2.30439043565776952e+02, 2.34701723442818268e+02, 2.38978389561834323e+02, 2.43268849002982714e+02, 2.47572914096186884e+02, 2.51890402209723194e+02, 2.56221135550009525e+02, 2.60564940971863209e+02, 2.64921649798552801e+02, 2.69291097651019823e+02, 2.73673124285693704e+02, 2.78067573440366143e+02, 2.82474292687630396e+02, 2.86893133295426994e+02, 2.91323950094270308e+02, 2.95766601350760624e+02, 3.00220948647014132e+02, 3.04686856765668715e+02, 3.09164193580146922e+02, 3.13652829949879062e+02, 3.18152639620209327e+02, 3.22663499126726177e+02, 3.27185287703775217e+02, 3.31717887196928473e+02, 3.36261181979198477e+02, 3.40815058870799018e+02, 3.45379407062266854e+02, 3.49954118040770237e+02, 3.54539085519440809e+02, 3.59134205369575399e+02];\n  cf = [8.33333333333333333e-02, -2.77777777777777778e-03, 7.93650793650793651e-04, -5.95238095238095238e-04, 8.41750841750841751e-04, -1.91752691752691753e-03, 6.41025641025641026e-03, -2.95506535947712418e-02, 1.79644372368830573e-01, -1.39243221690590112e+00, 1.34028640441683920e+01, -1.56848284626002017e+02, 2.19310333333333333e+03, -3.61087712537249894e+04, 6.91472268851313067e+05, -1.52382215394074162e+07, 3.82900751391414141e+08, -1.08822660357843911e+10, 3.47320283765002252e+11, -1.23696021422692745e+13, 4.88788064793079335e+14, -2.13203339609193739e+16];\n  con = 1.83787706640934548;\n  // c***first executable statement  dgamln\n  // ierr = 0;\n  if (z <= 0.0) {\n    // ierr = 1;\n    return null;\n  }\n  if (z > 101.0) {\n    // go to 10\n  } else {\n    nz = Math.trunc(z);\n    fz = z - nz;\n    if (fz > 0.0 || nz > 100) {\n      //\n    } else {\n      return gln[nz - 1];\n    }\n  }\n  // 10 continue\n  wdtol = (0, _d1mach.d1mach)(4);\n  wdtol = Math.max(wdtol, 0.5e-18);\n  i1m = (0, _i1mach.i1mach)(14);\n  rln = (0, _d1mach.d1mach)(5) * i1m;\n  fln = Math.min(rln, 20.0);\n  fln = Math.max(fln, 3.0);\n  fln = fln - 3.0;\n  zm = 1.8000 + 0.3875 * fln;\n  mz = Math.trunc(zm) + 1;\n  zmin = mz;\n  zdmy = z;\n  zinc = 0.0;\n  if (z >= zmin) {\n    // go to 20\n  } else {\n    zinc = zmin - nz;\n    zdmy = z + zinc;\n  }\n  // 20 continue\n  zp = 1.0 / zdmy;\n  t1 = cf[0] * zp;\n  s = t1;\n  if (zp < wdtol) {\n    // go to 40\n  } else {\n    zsq = zp * zp;\n    tst = t1 * wdtol;\n    // do 30 k=2,22\n    for (k = 1; k < 22; k++) {\n      zp = zp * zsq;\n      trm = cf[k] * zp;\n      if (Math.abs(trm) < tst) break; // go to 40\n      s = s + trm;\n    }\n    // 30 continue\n  }\n  // 40 continue\n  if (zinc !== 0.0) {\n    // go to 50\n  } else {\n    tlg = Math.log(z);\n    return z * (tlg - 1.0) + 0.5 * (con - tlg) + s;\n  }\n  // 50 continue\n  zp = 1.0;\n  nz = Math.trunc(zinc);\n  // do 60 i=1,nz\n  for (i = 1; i <= nz; i++) {\n    zp = zp * (z + (i - 1));\n  }\n  // 60 continue\n  tlg = Math.log(zdmy);\n  return zdmy * (tlg - 1.0) - Math.log(zp) + 0.5 * (con - tlg) + s;\n}\n},{\"../../utils/fortran-utils/d1mach.js\":91,\"../../utils/fortran-utils/i1mach.js\":92}],11:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.azabs = azabs;\n// DOUBLE PRECISION FUNCTION AZABS(ZR, ZI)\n// ***BEGIN PROLOGUE  AZABS\n// ***REFER TO  ZBESH,ZBESI,ZBESJ,ZBESK,ZBESY,ZAIRY,ZBIRY\n//\n//      AZABS COMPUTES THE ABSOLUTE VALUE OR MAGNITUDE OF A DOUBLE\n//      PRECISION COMPLEX VARIABLE CMPLX(ZR,ZI)\n//\n// ***ROUTINES CALLED  (NONE)\n// ***END PROLOGUE  AZABS\nfunction azabs(zr, zi) {\n  var u = void 0,\n      v = void 0,\n      q = void 0,\n      s = void 0;\n  u = Math.abs(zr);\n  v = Math.abs(zi);\n  s = u + v;\n\n  if (s === 0) return 0;\n  if (u > v) {\n    q = v / u;\n    return u * Math.sqrt(1 + q * q);\n  }\n  q = u / v;\n  return v * Math.sqrt(1 + q * q);\n}\n},{}],12:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); /* eslint-disable no-labels */\n/* eslint-disable no-fallthrough */\n// SUBROUTINE ZACAI(ZR, ZI, FNU, KODE, MR, N, YR, YI, NZ, RL, TOL,\n// * ELIM, ALIM)\n// ***BEGIN PROLOGUE  ZACAI\n// ***REFER TO  ZAIRY\n//\n//      ZACAI APPLIES THE ANALYTIC CONTINUATION FORMULA\n//\n//          K(FNU,ZN*EXP(MP))=K(FNU,ZN)*EXP(-MP*FNU) - MP*I(FNU,ZN)\n//                  MP=PI*MR*CMPLX(0.0,1.0)\n//\n//      TO CONTINUE THE K FUNCTION FROM THE RIGHT HALF TO THE LEFT\n//      HALF Z PLANE FOR USE WITH ZAIRY WHERE FNU=1/3 OR 2/3 AND N=1.\n//      ZACAI IS THE SAME AS ZACON WITH THE PARTS FOR LARGER ORDERS AND\n//      RECURRENCE REMOVED. A RECURSIVE CALL TO ZACON CAN RESULT IF ZACON\n//      IS CALLED FROM ZAIRY.\n//\n// ***ROUTINES CALLED  ZASYI,ZBKNU,ZMLRI,ZSERI,ZS1S2,D1MACH,AZABS\n// ***END PROLOGUE  ZACAI\n\n\nexports.zacai = zacai;\n\nvar _zasyi = require('./zasyi.js');\n\nvar _zbknu = require('./zbknu.js');\n\nvar _zmlri = require('./zmlri.js');\n\nvar _zseri = require('./zseri.js');\n\nvar _zs1s3 = require('./zs1s2.js');\n\nvar _d1mach = require('../../utils/fortran-utils/d1mach.js');\n\nvar _zabs = require('./zabs.js');\n\nvar _fortranHelpers = require('../../utils/fortranHelpers.js');\n\nvar ft = _interopRequireWildcard(_fortranHelpers);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction zacai(zr, zi, fnu, kode, mr, n, yr, yi, rl, tol, elim, alim) {\n  var arg = void 0,\n      ascle = void 0,\n      az = void 0,\n      csgnr = void 0,\n      csgni = void 0,\n      cspnr = void 0,\n      cspni = void 0,\n      c1r = void 0,\n      c1i = void 0,\n      c2r = void 0,\n      c2i = void 0,\n      cyr = void 0,\n      cyi = void 0,\n      dfnu = void 0,\n      fmr = void 0,\n      pi = void 0,\n      sgn = void 0,\n      yy = void 0,\n      znr = void 0,\n      zni = void 0,\n      inu = void 0,\n      iuf = void 0,\n      nn = void 0,\n      nw = void 0,\n      nz = void 0;\n  cyr = new Array(2);\n  cyi = new Array(2);\n  pi = 3.14159265358979324;\n\n  var goToLabel = 0;\n  mainExecutionLoop: while (true) {\n    switch (goToLabel) {\n      case 0:\n        nz = 0;\n        znr = -zr;\n        zni = -zi;\n        az = (0, _zabs.azabs)(zr, zi);\n        nn = n;\n        dfnu = fnu + (n - 1);\n        if (az <= 2.0) {\n          goToLabel = 10;break;\n        }\n        if (az * az * 0.25 > dfnu + 1.0) {\n          goToLabel = 20;break;\n        }\n      case 10:\n        // c-----------------------------------------------------------------------\n        // c     power series for the i function\n        // c-----------------------------------------------------------------------\n        nw = (0, _zseri.zseri)(znr, zni, fnu, kode, nn, yr, yi, tol, elim, alim);\n        goToLabel = 40;break;\n      case 20:\n        if (az < rl) {\n          goToLabel = 30;break;\n        }\n        // c-----------------------------------------------------------------------\n        // c     asymptotic expansion for large z for the i function\n        // c-----------------------------------------------------------------------\n        nw = (0, _zasyi.zasyi)(znr, zni, fnu, kode, nn, yr, yi, rl, tol, elim, alim);\n        if (nw < 0) {\n          goToLabel = 80;break;\n        }\n        goToLabel = 40;break;\n      case 30:\n        // c-----------------------------------------------------------------------\n        // c     miller algorithm normalized by the series for the i function\n        // c-----------------------------------------------------------------------\n        nw = (0, _zmlri.zmlri)(znr, zni, fnu, kode, nn, yr, yi, tol);\n        if (nw < 0) {\n          goToLabel = 80;break;\n        }\n      case 40:\n        // c-----------------------------------------------------------------------\n        // c     analytic continuation to the left half plane for the k function\n        // c-----------------------------------------------------------------------\n        nw = (0, _zbknu.zbknu)(znr, zni, fnu, kode, 1, cyr, cyi, tol, elim, alim);\n        if (nw !== 0) {\n          goToLabel = 80;break;\n        }\n        fmr = mr;\n        sgn = -ft.sign(pi, fmr);\n        csgnr = 0.0;\n        csgni = sgn;\n        if (kode === 1) {\n          goToLabel = 50;break;\n        }\n        yy = -zni;\n        csgnr = -csgni * Math.sin(yy);\n        csgni = csgni * Math.cos(yy);\n      case 50:\n        // c-----------------------------------------------------------------------\n        // c     calculate cspn=exp(fnu*pi*i) to minimize losses of significance\n        // c     when fnu is large\n        // c-----------------------------------------------------------------------\n        inu = Math.trunc(fnu);\n        arg = (fnu - inu) * sgn;\n        cspnr = Math.cos(arg);\n        cspni = Math.sin(arg);\n        if (inu % 2 === 0) {\n          goToLabel = 60;break;\n        }\n        cspnr = -cspnr;\n        cspni = -cspni;\n      case 60:\n        c1r = cyr[0];\n        c1i = cyi[0];\n        c2r = yr[0];\n        c2i = yi[0];\n        if (kode === 1) {\n          goToLabel = 70;break;\n        }\n        iuf = 0;\n        ascle = 1.0e+3 * (0, _d1mach.d1mach)(1) / tol;\n\n        var _zs1s = (0, _zs1s3.zs1s2)(znr, zni, c1r, c1i, c2r, c2i, ascle, alim, iuf);\n\n        var _zs1s2 = _slicedToArray(_zs1s, 6);\n\n        c1r = _zs1s2[0];\n        c1i = _zs1s2[1];\n        c2r = _zs1s2[2];\n        c2i = _zs1s2[3];\n        nw = _zs1s2[4];\n        iuf = _zs1s2[5];\n\n        nz = nz + nw;\n      case 70:\n        yr[0] = cspnr * c1r - cspni * c1i + csgnr * c2r - csgni * c2i;\n        yi[0] = cspnr * c1i + cspni * c1r + csgnr * c2i + csgni * c2r;\n        break mainExecutionLoop;\n      case 80:\n        nz = -1;\n        if (nw === -2) nz = -2;\n      default:\n        break mainExecutionLoop;\n    }\n  }\n\n  return nz;\n}\n},{\"../../utils/fortran-utils/d1mach.js\":91,\"../../utils/fortranHelpers.js\":93,\"./zabs.js\":11,\"./zasyi.js\":15,\"./zbknu.js\":23,\"./zmlri.js\":30,\"./zs1s2.js\":33,\"./zseri.js\":34}],13:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); /* eslint-disable no-labels */\n/* eslint-disable no-fallthrough */\n// SUBROUTINE ZACON(ZR, ZI, FNU, KODE, MR, N, YR, YI, NZ, RL, FNUL,\n// * TOL, ELIM, ALIM)\n// ***BEGIN PROLOGUE  ZACON\n// ***REFER TO  ZBESK,ZBESH\n//\n//      ZACON APPLIES THE ANALYTIC CONTINUATION FORMULA\n//\n//          K(FNU,ZN*EXP(MP))=K(FNU,ZN)*EXP(-MP*FNU) - MP*I(FNU,ZN)\n//                  MP=PI*MR*CMPLX(0.0,1.0)\n//\n//      TO CONTINUE THE K FUNCTION FROM THE RIGHT HALF TO THE LEFT\n//      HALF Z PLANE\n//\n// ***ROUTINES CALLED  ZBINU,ZBKNU,ZS1S2,D1MACH,AZABS,ZMLT\n// ***END PROLOGUE  ZACON\n//      COMPLEX CK,CONE,CSCL,CSCR,CSGN,CSPN,CY,CZERO,C1,C2,RZ,SC1,SC2,ST,\n//     *S1,S2,Y,Z,ZN\n\n\nexports.zacon = zacon;\n\nvar _zbknu = require('./zbknu.js');\n\nvar _zbinu = require('./zbinu.js');\n\nvar _zs1s7 = require('./zs1s2.js');\n\nvar _d1mach = require('../../utils/fortran-utils/d1mach.js');\n\nvar _zabs = require('./zabs.js');\n\nvar _zmlt11 = require('./zmlt.js');\n\nvar _fortranHelpers = require('../../utils/fortranHelpers.js');\n\nvar ft = _interopRequireWildcard(_fortranHelpers);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction zacon(zr, zi, fnu, kode, mr, n, yr, yi, rl, fnul, tol, elim, alim) {\n  var arg = void 0,\n      ascle = void 0,\n      as2 = void 0,\n      azn = void 0,\n      bry = void 0,\n      bscle = void 0,\n      cki = void 0,\n      ckr = void 0,\n      coner = void 0,\n      cpn = void 0,\n      cscl = void 0,\n      cscr = void 0,\n      csgni = void 0,\n      csgnr = void 0,\n      cspni = void 0,\n      cspnr = void 0,\n      csr = void 0,\n      csrr = void 0,\n      cssr = void 0,\n      cyi = void 0,\n      cyr = void 0,\n      c1i = void 0,\n      c1m = void 0,\n      c1r = void 0,\n      c2i = void 0,\n      c2r = void 0,\n      fmr = void 0,\n      fn = void 0,\n      pi = void 0,\n      pti = void 0,\n      ptr = void 0,\n      razn = void 0,\n      rzi = void 0,\n      rzr = void 0,\n      sc1i = void 0,\n      sc1r = void 0,\n      sc2i = void 0,\n      sc2r = void 0,\n      sgn = void 0,\n      spn = void 0,\n      sti = void 0,\n      str = void 0,\n      s1i = void 0,\n      s1r = void 0,\n      s2i = void 0,\n      s2r = void 0,\n      yy = void 0,\n      zeror = void 0,\n      zni = void 0,\n      znr = void 0,\n      i = void 0,\n      inu = void 0,\n      iuf = void 0,\n      kflag = void 0,\n      nn = void 0,\n      nw = void 0,\n      nz = void 0;\n\n  cyr = new Float64Array(2);\n  cyi = new Float64Array(2);\n  cssr = new Float64Array(3);\n  csrr = new Float64Array(3);\n  bry = new Float64Array(3);\n  pi = 3.14159265358979324;\n\n  zeror = 0;\n  coner = 1;\n  var goToLabel = 0;\n  mainExecutionLoop: while (true) {\n    switch (goToLabel) {\n      case 0:\n        nz = 0;\n        znr = -zr;\n        zni = -zi;\n        nn = n;\n        nw = (0, _zbinu.zbinu)(znr, zni, fnu, kode, nn, yr, yi, rl, fnul, tol, elim, alim);\n        if (nw < 0) {\n          goToLabel = 90;break;\n        }\n        // c-----------------------------------------------------------------------\n        // c     analytic continuation to the left half plane for the k function\n        // c-----------------------------------------------------------------------\n        nn = Math.min(2, n);\n        nw = (0, _zbknu.zbknu)(znr, zni, fnu, kode, nn, cyr, cyi, tol, elim, alim);\n        if (nw !== 0) {\n          goToLabel = 90;break;\n        }\n        s1r = cyr[0];\n        s1i = cyi[0];\n        fmr = mr;\n        sgn = -ft.sign(pi, fmr);\n        csgnr = zeror;\n        csgni = sgn;\n        if (kode === 1) {\n          goToLabel = 10;break;\n        }\n        yy = -zni;\n        cpn = Math.cos(yy);\n        spn = Math.sin(yy);\n\n        var _zmlt = (0, _zmlt11.zmlt)(csgnr, csgni, cpn, spn);\n\n        var _zmlt2 = _slicedToArray(_zmlt, 2);\n\n        csgnr = _zmlt2[0];\n        csgni = _zmlt2[1];\n\n      case 10:\n        // c-----------------------------------------------------------------------\n        // c     calculate cspn=exp(fnu*pi*i) to minimize losses of significance\n        // c     when fnu is large\n        // c-----------------------------------------------------------------------\n        inu = Math.trunc(fnu);\n        arg = (fnu - inu) * sgn;\n        cpn = Math.cos(arg);\n        spn = Math.sin(arg);\n        cspnr = cpn;\n        cspni = spn;\n        if (inu % 2 === 0) {\n          goToLabel = 20;break;\n        }\n        cspnr = -cspnr;\n        cspni = -cspni;\n      case 20:\n        iuf = 0;\n        c1r = s1r;\n        c1i = s1i;\n        c2r = yr[0];\n        c2i = yi[0];\n        ascle = 1.0e+3 * (0, _d1mach.d1mach)(1) / tol;\n        if (kode === 1) {\n          goToLabel = 30;break;\n        }\n\n        var _zs1s = (0, _zs1s7.zs1s2)(znr, zni, c1r, c1i, c2r, c2i, ascle, alim, iuf);\n\n        var _zs1s2 = _slicedToArray(_zs1s, 6);\n\n        nw = _zs1s2[0];\n        c1r = _zs1s2[1];\n        c1i = _zs1s2[2];\n        c2r = _zs1s2[3];\n        c2i = _zs1s2[4];\n        iuf = _zs1s2[5];\n\n        nz = nz + nw;\n        sc1r = c1r;\n        sc1i = c1i;\n      case 30:\n        var _zmlt3 = (0, _zmlt11.zmlt)(cspnr, cspni, c1r, c1i);\n\n        var _zmlt4 = _slicedToArray(_zmlt3, 2);\n\n        str = _zmlt4[0];\n        sti = _zmlt4[1];\n\n        var _zmlt5 = (0, _zmlt11.zmlt)(csgnr, csgni, c2r, c2i);\n\n        var _zmlt6 = _slicedToArray(_zmlt5, 2);\n\n        ptr = _zmlt6[0];\n        pti = _zmlt6[1];\n\n        yr[0] = str + ptr;\n        yi[0] = sti + pti;\n        if (n === 1) break mainExecutionLoop;\n        cspnr = -cspnr;\n        cspni = -cspni;\n        s2r = cyr[1];\n        s2i = cyi[1];\n        c1r = s2r;\n        c1i = s2i;\n        c2r = yr[1];\n        c2i = yi[1];\n        if (kode === 1) {\n          goToLabel = 40;break;\n        }\n\n        var _zs1s3 = (0, _zs1s7.zs1s2)(znr, zni, c1r, c1i, c2r, c2i, ascle, alim, iuf);\n\n        var _zs1s4 = _slicedToArray(_zs1s3, 6);\n\n        nw = _zs1s4[0];\n        c1r = _zs1s4[1];\n        c1i = _zs1s4[2];\n        c2r = _zs1s4[3];\n        c2i = _zs1s4[4];\n        iuf = _zs1s4[5];\n\n        nz = nz + nw;\n        sc2r = c1r;\n        sc2i = c1i;\n      case 40:\n        var _zmlt7 = (0, _zmlt11.zmlt)(cspnr, cspni, c1r, c1i);\n\n        var _zmlt8 = _slicedToArray(_zmlt7, 2);\n\n        str = _zmlt8[0];\n        sti = _zmlt8[1];\n\n        var _zmlt9 = (0, _zmlt11.zmlt)(csgnr, csgni, c2r, c2i);\n\n        var _zmlt10 = _slicedToArray(_zmlt9, 2);\n\n        ptr = _zmlt10[0];\n        pti = _zmlt10[1];\n\n        yr[1] = str + ptr;\n        yi[1] = sti + pti;\n        if (n === 2) break mainExecutionLoop;\n        cspnr = -cspnr;\n        cspni = -cspni;\n        azn = (0, _zabs.azabs)(znr, zni);\n        razn = 1.0 / azn;\n        str = znr * razn;\n        sti = -zni * razn;\n        rzr = (str + str) * razn;\n        rzi = (sti + sti) * razn;\n        fn = fnu + 1.0;\n        ckr = fn * rzr;\n        cki = fn * rzi;\n        // c-----------------------------------------------------------------------\n        // c     scale near exponent extremes during recurrence on k functions\n        // c-----------------------------------------------------------------------\n        cscl = 1.0 / tol;\n        cscr = tol;\n        cssr[0] = cscl;\n        cssr[1] = coner;\n        cssr[2] = cscr;\n        csrr[0] = cscr;\n        csrr[1] = coner;\n        csrr[2] = cscl;\n        bry[0] = ascle;\n        bry[1] = 1.0 / ascle;\n        bry[2] = (0, _d1mach.d1mach)(2);\n        as2 = (0, _zabs.azabs)(s2r, s2i);\n        kflag = 2;\n        if (as2 > bry[0]) {\n          goToLabel = 50;break;\n        }\n        kflag = 1;\n        goToLabel = 60;break;\n      case 50:\n        if (as2 < bry[1]) {\n          goToLabel = 60;break;\n        }\n        kflag = 3;\n      case 60:\n        bscle = bry[kflag - 1];\n        s1r = s1r * cssr[kflag - 1];\n        s1i = s1i * cssr[kflag - 1];\n        s2r = s2r * cssr[kflag - 1];\n        s2i = s2i * cssr[kflag - 1];\n        csr = csrr[kflag - 1];\n        // do 80 i=3,n\n        for (i = 3; i <= n; i++) {\n          str = s2r;\n          sti = s2i;\n          s2r = ckr * str - cki * sti + s1r;\n          s2i = ckr * sti + cki * str + s1i;\n          s1r = str;\n          s1i = sti;\n          c1r = s2r * csr;\n          c1i = s2i * csr;\n          str = c1r;\n          sti = c1i;\n          c2r = yr[i - 1];\n          c2i = yi[i - 1];\n          if (kode === 1) {\n            // go to 70\n          } else {\n            if (iuf < 0) {\n              // go to 70\n            } else {\n              var _zs1s5 = (0, _zs1s7.zs1s2)(znr, zni, c1r, c1i, c2r, c2i, ascle, alim, iuf);\n\n              var _zs1s6 = _slicedToArray(_zs1s5, 6);\n\n              nw = _zs1s6[0];\n              c1r = _zs1s6[1];\n              c1i = _zs1s6[2];\n              c2r = _zs1s6[3];\n              c2i = _zs1s6[4];\n              iuf = _zs1s6[5];\n\n              nz = nz + nw;\n              sc1r = sc2r;\n              sc1i = sc2i;\n              sc2r = c1r;\n              sc2i = c1i;\n              if (iuf !== 3) {\n                // go to 70\n              } else {\n                iuf = -4;\n                s1r = sc1r * cssr[kflag - 1];\n                s1i = sc1i * cssr[kflag - 1];\n                s2r = sc2r * cssr[kflag - 1];\n                s2i = sc2i * cssr[kflag - 1];\n                str = sc2r;\n                sti = sc2i;\n              }\n            }\n          }\n          // 70   continue\n          ptr = cspnr * c1r - cspni * c1i;\n          pti = cspnr * c1i + cspni * c1r;\n          yr[i - 1] = ptr + csgnr * c2r - csgni * c2i;\n          yi[i - 1] = pti + csgnr * c2i + csgni * c2r;\n          ckr = ckr + rzr;\n          cki = cki + rzi;\n          cspnr = -cspnr;\n          cspni = -cspni;\n          if (kflag >= 3) continue;\n          ptr = Math.abs(c1r);\n          pti = Math.abs(c1i);\n          c1m = Math.max(ptr, pti);\n          if (c1m <= bscle) continue;\n          kflag = kflag + 1;\n          bscle = bry[kflag - 1];\n          s1r = s1r * csr;\n          s1i = s1i * csr;\n          s2r = str;\n          s2i = sti;\n          s1r = s1r * cssr[kflag - 1];\n          s1i = s1i * cssr[kflag - 1];\n          s2r = s2r * cssr[kflag - 1];\n          s2i = s2i * cssr[kflag - 1];\n          csr = csrr[kflag - 1];\n        } // 80 continue\n        break mainExecutionLoop;\n      case 90:\n        nz = -1;\n        if (nw === -2) nz = -2;\n      default:\n        break mainExecutionLoop;\n    }\n  }\n  return nz;\n}\n},{\"../../utils/fortran-utils/d1mach.js\":91,\"../../utils/fortranHelpers.js\":93,\"./zabs.js\":11,\"./zbinu.js\":21,\"./zbknu.js\":23,\"./zmlt.js\":31,\"./zs1s2.js\":33}],14:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); /* eslint-disable no-labels */\n/* eslint-disable no-fallthrough */\n// SUBROUTINE ZAIRY(ZR, ZI, ID, KODE, AIR, AII, NZ, IERR)\n// ***BEGIN PROLOGUE  ZAIRY\n// ***DATE WRITTEN   830501   (YYMMDD)\n// ***REVISION DATE  890801   (YYMMDD)\n// ***PORT TO ECMASCRIPT  201801   (YYYYMM)\n// ***CATEGORY NO.  B5K\n// ***KEYWORDS  AIRY FUNCTION,BESSEL FUNCTIONS OF ORDER ONE THIRD\n// ***AUTHOR (FORTRAN) AMOS, DONALD E., SANDIA NATIONAL LABORATORIES\n// ***AUTHOR (ECMASCRIPT) ERB, KC, KINGS DISTRIBUTED SYSTEMS\n// ***PURPOSE  TO COMPUTE AIRY FUNCTIONS AI(Z) AND DAI(Z) FOR COMPLEX Z\n// ***DESCRIPTION\n//\n//                       ***A DOUBLE PRECISION ROUTINE***\n//          ON KODE=1, ZAIRY COMPUTES THE COMPLEX AIRY FUNCTION AI(Z) OR\n//          ITS DERIVATIVE DAI(Z)/DZ ON ID=0 OR ID=1 RESPECTIVELY. ON\n//          KODE=2, A SCALING OPTION CEXP(ZTA)*AI(Z) OR CEXP(ZTA)*\n//          DAI(Z)/DZ IS PROVIDED TO REMOVE THE EXPONENTIAL DECAY IN\n//          -PI/3.LT.ARG(Z).LT.PI/3 AND THE EXPONENTIAL GROWTH IN\n//          PI/3.LT.ABS(ARG(Z)).LT.PI WHERE ZTA=(2/3)*Z*CSQRT(Z).\n//\n//          WHILE THE AIRY FUNCTIONS AI(Z) AND DAI(Z)/DZ ARE ANALYTIC IN\n//          THE WHOLE Z PLANE, THE CORRESPONDING SCALED FUNCTIONS DEFINED\n//          FOR KODE=2 HAVE A CUT ALONG THE NEGATIVE REAL AXIS.\n//          DEFINTIONS AND NOTATION ARE FOUND IN THE NBS HANDBOOK OF\n//          MATHEMATICAL FUNCTIONS (REF. 1).\n//\n//          INPUT      ZR,ZI ARE DOUBLE PRECISION\n//            ZR,ZI  - Z=CMPLX(ZR,ZI)\n//            ID     - ORDER OF DERIVATIVE, ID=0 OR ID=1\n//            KODE   - A PARAMETER TO INDICATE THE SCALING OPTION\n//                     KODE= 1  RETURNS\n//                              AI=AI(Z)                ON ID=0 OR\n//                              AI=DAI(Z)/DZ            ON ID=1\n//                         = 2  RETURNS\n//                              AI=CEXP(ZTA)*AI(Z)       ON ID=0 OR\n//                              AI=CEXP(ZTA)*DAI(Z)/DZ   ON ID=1 WHERE\n//                              ZTA=(2/3)*Z*CSQRT(Z)\n//\n//          OUTPUT     AIR,AII ARE DOUBLE PRECISION\n//            AIR,AII- COMPLEX ANSWER DEPENDING ON THE CHOICES FOR ID AND\n//                     KODE\n//            NZ     - UNDERFLOW INDICATOR\n//                     NZ= 0   , NORMAL RETURN\n//                     NZ= 1   , AI=CMPLX(0.0D0,0.0D0) DUE TO UNDERFLOW IN\n//                               -PI/3.LT.ARG(Z).LT.PI/3 ON KODE=1\n//            IERR   - ERROR FLAG\n//                     IERR=0, NORMAL RETURN - COMPUTATION COMPLETED\n//                     IERR=1, INPUT ERROR   - NO COMPUTATION\n//                     IERR=2, OVERFLOW      - NO COMPUTATION, REAL(ZTA)\n//                             TOO LARGE ON KODE=1\n//                     IERR=3, CABS(Z) LARGE      - COMPUTATION COMPLETED\n//                             LOSSES OF SIGNIFCANCE BY ARGUMENT REDUCTION\n//                             PRODUCE LESS THAN HALF OF MACHINE ACCURACY\n//                     IERR=4, CABS(Z) TOO LARGE  - NO COMPUTATION\n//                             COMPLETE LOSS OF ACCURACY BY ARGUMENT\n//                             REDUCTION\n//                     IERR=5, ERROR              - NO COMPUTATION,\n//                             ALGORITHM TERMINATION CONDITION NOT MET\n//\n// ***LONG DESCRIPTION\n//\n//          AI AND DAI ARE COMPUTED FOR CABS(Z).GT.1.0 FROM THE K BESSEL\n//          FUNCTIONS BY\n//\n//             AI(Z)=C*SQRT(Z)*K(1/3,ZTA) , DAI(Z)=-C*Z*K(2/3,ZTA)\n//                            C=1.0/(PI*SQRT(3.0))\n//                             ZTA=(2/3)*Z**(3/2)\n//\n//          WITH THE POWER SERIES FOR CABS(Z).LE.1.0.\n//\n//          IN MOST COMPLEX VARIABLE COMPUTATION, ONE MUST EVALUATE ELE-\n//          MENTARY FUNCTIONS. WHEN THE MAGNITUDE OF Z IS LARGE, LOSSES\n//          OF SIGNIFICANCE BY ARGUMENT REDUCTION OCCUR. CONSEQUENTLY, IF\n//          THE MAGNITUDE OF ZETA=(2/3)*Z**1.5 EXCEEDS U1=SQRT(0.5/UR),\n//          THEN LOSSES EXCEEDING HALF PRECISION ARE LIKELY AND AN ERROR\n//          FLAG IERR=3 IS TRIGGERED WHERE UR=DMAX1(D1MACH(4),1.0D-18) IS\n//          DOUBLE PRECISION UNIT ROUNDOFF LIMITED TO 18 DIGITS PRECISION.\n//          ALSO, IF THE MAGNITUDE OF ZETA IS LARGER THAN U2=0.5/UR, THEN\n//          ALL SIGNIFICANCE IS LOST AND IERR=4. IN ORDER TO USE THE INT\n//          FUNCTION, ZETA MUST BE FURTHER RESTRICTED NOT TO EXCEED THE\n//          LARGEST INTEGER, U3=I1MACH(9). THUS, THE MAGNITUDE OF ZETA\n//          MUST BE RESTRICTED BY MIN(U2,U3). ON 32 BIT MACHINES, U1,U2,\n//          AND U3 ARE APPROXIMATELY 2.0E+3, 4.2E+6, 2.1E+9 IN SINGLE\n//          PRECISION ARITHMETIC AND 1.3E+8, 1.8E+16, 2.1E+9 IN DOUBLE\n//          PRECISION ARITHMETIC RESPECTIVELY. THIS MAKES U2 AND U3 LIMIT-\n//          ING IN THEIR RESPECTIVE ARITHMETICS. THIS MEANS THAT THE MAG-\n//          NITUDE OF Z CANNOT EXCEED 3.1E+4 IN SINGLE AND 2.1E+6 IN\n//          DOUBLE PRECISION ARITHMETIC. THIS ALSO MEANS THAT ONE CAN\n//          EXPECT TO RETAIN, IN THE WORST CASES ON 32 BIT MACHINES,\n//          NO DIGITS IN SINGLE PRECISION AND ONLY 7 DIGITS IN DOUBLE\n//          PRECISION ARITHMETIC. SIMILAR CONSIDERATIONS HOLD FOR OTHER\n//          MACHINES.\n//\n//          THE APPROXIMATE RELATIVE ERROR IN THE MAGNITUDE OF A COMPLEX\n//          BESSEL FUNCTION CAN BE EXPRESSED BY P*10**S WHERE P=MAX(UNIT\n//          ROUNDOFF,1.0E-18) IS THE NOMINAL PRECISION AND 10**S REPRE-\n//          SENTS THE INCREASE IN ERROR DUE TO ARGUMENT REDUCTION IN THE\n//          ELEMENTARY FUNCTIONS. HERE, S=MAX(1,ABS(LOG10(CABS(Z))),\n//          ABS(LOG10(FNU))) APPROXIMATELY (I.E. S=MAX(1,ABS(EXPONENT OF\n//          CABS(Z),ABS(EXPONENT OF FNU)) ). HOWEVER, THE PHASE ANGLE MAY\n//          HAVE ONLY ABSOLUTE ACCURACY. THIS IS MOST LIKELY TO OCCUR WHEN\n//          ONE COMPONENT (IN ABSOLUTE VALUE) IS LARGER THAN THE OTHER BY\n//          SEVERAL ORDERS OF MAGNITUDE. IF ONE COMPONENT IS 10**K LARGER\n//          THAN THE OTHER, THEN ONE CAN EXPECT ONLY MAX(ABS(LOG10(P))-K,\n//          0) SIGNIFICANT DIGITS; OR, STATED ANOTHER WAY, WHEN K EXCEEDS\n//          THE EXPONENT OF P, NO SIGNIFICANT DIGITS REMAIN IN THE SMALLER\n//          COMPONENT. HOWEVER, THE PHASE ANGLE RETAINS ABSOLUTE ACCURACY\n//          BECAUSE, IN COMPLEX ARITHMETIC WITH PRECISION P, THE SMALLER\n//          COMPONENT WILL NOT (AS A RULE) DECREASE BELOW P TIMES THE\n//          MAGNITUDE OF THE LARGER COMPONENT. IN THESE EXTREME CASES,\n//          THE PRINCIPAL PHASE ANGLE IS ON THE ORDER OF +P, -P, PI/2-P,\n//          OR -PI/2+P.\n//\n// ***REFERENCES  HANDBOOK OF MATHEMATICAL FUNCTIONS BY M. ABRAMOWITZ\n//                  AND I. A. STEGUN, NBS AMS SERIES 55, U.S. DEPT. OF\n//                  COMMERCE, 1955.\n//\n//                COMPUTATION OF BESSEL FUNCTIONS OF COMPLEX ARGUMENT\n//                  AND LARGE ORDER BY D. E. AMOS, SAND83-0643, MAY, 1983\n//\n//                A SUBROUTINE PACKAGE FOR BESSEL FUNCTIONS OF A COMPLEX\n//                  ARGUMENT AND NONNEGATIVE ORDER BY D. E. AMOS, SAND85-\n//                  1018, MAY, 1985\n//\n//                A PORTABLE PACKAGE FOR BESSEL FUNCTIONS OF A COMPLEX\n//                  ARGUMENT AND NONNEGATIVE ORDER BY D. E. AMOS, TRANS.\n//                  MATH. SOFTWARE, 1986\n//\n// ***ROUTINES CALLED  ZACAI,ZBKNU,AZEXP,AZSQRT,I1MACH,D1MACH\n// ***END PROLOGUE  ZAIRY\n\n\nexports.zairy = zairy;\n\nvar _zacai = require('./zacai.js');\n\nvar _zbknu = require('./zbknu.js');\n\nvar _zexp = require('./zexp.js');\n\nvar _zsqrt = require('./zsqrt.js');\n\nvar _zabs = require('./zabs.js');\n\nvar _i1mach = require('../../utils/fortran-utils/i1mach.js');\n\nvar _d1mach = require('../../utils/fortran-utils/d1mach.js');\n\nfunction zairy(zr, zi, id, kode) {\n  var aa = void 0,\n      ad = void 0,\n      aii = void 0,\n      air = void 0,\n      ak = void 0,\n      alim = void 0,\n      atrm = void 0,\n      az = void 0,\n      az3 = void 0,\n      bk = void 0,\n      cc = void 0,\n      ck = void 0,\n      coef = void 0,\n      conei = void 0,\n      coner = void 0,\n      csqi = void 0,\n      csqr = void 0,\n      cyi = void 0,\n      cyr = void 0,\n      c1 = void 0,\n      c2 = void 0,\n      dig = void 0,\n      dk = void 0,\n      d1 = void 0,\n      d2 = void 0,\n      elim = void 0,\n      fid = void 0,\n      fnu = void 0,\n      ptr = void 0,\n      rl = void 0,\n      r1m5 = void 0,\n      sfac = void 0,\n      sti = void 0,\n      str = void 0,\n      s1i = void 0,\n      s1r = void 0,\n      s2i = void 0,\n      s2r = void 0,\n      tol = void 0,\n      trm1i = void 0,\n      trm1r = void 0,\n      trm2i = void 0,\n      trm2r = void 0,\n      tth = void 0,\n      zeroi = void 0,\n      zeror = void 0,\n      ztai = void 0,\n      ztar = void 0,\n      z3i = void 0,\n      z3r = void 0,\n      alaz = void 0,\n      bb = void 0,\n      ierr = void 0,\n      iflag = void 0,\n      k = void 0,\n      k1 = void 0,\n      k2 = void 0,\n      mr = void 0,\n      nn = void 0,\n      nz = void 0;\n  cyr = [];\n  cyi = [];\n  tth = 6.66666666666666667e-01;\n  c1 = 3.55028053887817240e-01;\n  c2 = 2.58819403792806799e-01;\n  coef = 1.83776298473930683e-01;\n  zeror = 0;\n  zeroi = 0;\n  coner = 1;\n  conei = 0;\n\n\n  var goToLabel = 0;\n  mainExecutionLoop: while (true) {\n    switch (goToLabel) {\n      case 0:\n        ierr = 0;\n        nz = 0;\n        if (id < 0 || id > 1) ierr = 1;\n        if (kode < 1 || kode > 2) ierr = 1;\n        if (ierr !== 0) break mainExecutionLoop;\n        az = (0, _zabs.azabs)(zr, zi);\n        tol = Math.max((0, _d1mach.d1mach)(4), 1.0e-18);\n        fid = id;\n        if (az > 1.0) {\n          goToLabel = 70;break;\n        }\n        // c-----------------------------------------------------------------------\n        // c     power series for cabs(z) <= 1.\n        // c-----------------------------------------------------------------------\n        s1r = coner;\n        s1i = conei;\n        s2r = coner;\n        s2i = conei;\n        if (az < tol) {\n          goToLabel = 170;break;\n        }\n        aa = az * az;\n        if (aa < tol / az) {\n          goToLabel = 40;break;\n        }\n        trm1r = coner;\n        trm1i = conei;\n        trm2r = coner;\n        trm2i = conei;\n        atrm = 1.0;\n        str = zr * zr - zi * zi;\n        sti = zr * zi + zi * zr;\n        z3r = str * zr - sti * zi;\n        z3i = str * zi + sti * zr;\n        az3 = az * aa;\n        ak = 2.0 + fid;\n        bk = 3.0 - fid - fid;\n        ck = 4.0 - fid;\n        dk = 3.0 + fid + fid;\n        d1 = ak * dk;\n        d2 = bk * ck;\n        ad = Math.min(d1, d2);\n        ak = 24.0 + 9.0 * fid;\n        bk = 30.0 - 9.0 * fid;\n        // do 30 k=1,25\n        for (k = 1; k <= 25; k++) {\n          str = (trm1r * z3r - trm1i * z3i) / d1;\n          trm1i = (trm1r * z3i + trm1i * z3r) / d1;\n          trm1r = str;\n          s1r = s1r + trm1r;\n          s1i = s1i + trm1i;\n          str = (trm2r * z3r - trm2i * z3i) / d2;\n          trm2i = (trm2r * z3i + trm2i * z3r) / d2;\n          trm2r = str;\n          s2r = s2r + trm2r;\n          s2i = s2i + trm2i;\n          atrm = atrm * az3 / ad;\n          d1 = d1 + ak;\n          d2 = d2 + bk;\n          ad = Math.min(d1, d2);\n          if (atrm < tol * ad) break; // go to 40\n          ak = ak + 18.0;\n          bk = bk + 18.0;\n        }\n        // 30 continue\n        // 40 continue\n        if (id === 1) {\n          goToLabel = 50;break;\n        }\n        air = s1r * c1 - c2 * (zr * s2r - zi * s2i);\n        aii = s1i * c1 - c2 * (zr * s2i + zi * s2r);\n        if (kode === 1) break mainExecutionLoop;\n\n        var _azsqrt = (0, _zsqrt.azsqrt)(zr, zi);\n\n        var _azsqrt2 = _slicedToArray(_azsqrt, 2);\n\n        str = _azsqrt2[0];\n        sti = _azsqrt2[1];\n\n        ztar = tth * (zr * str - zi * sti);\n        ztai = tth * (zr * sti + zi * str);\n\n        var _azexp = (0, _zexp.azexp)(ztar, ztai);\n\n        var _azexp2 = _slicedToArray(_azexp, 2);\n\n        str = _azexp2[0];\n        sti = _azexp2[1];\n\n        ptr = air * str - aii * sti;\n        aii = air * sti + aii * str;\n        air = ptr;\n        break mainExecutionLoop;\n      case 50:\n        air = -s2r * c2;\n        aii = -s2i * c2;\n        if (az <= tol) {\n          goToLabel = 60;break;\n        }\n        str = zr * s1r - zi * s1i;\n        sti = zr * s1i + zi * s1r;\n        cc = c1 / (1.0 + fid);\n        air = air + cc * (str * zr - sti * zi);\n        aii = aii + cc * (str * zi + sti * zr);\n      case 60:\n        if (kode === 1) break mainExecutionLoop;\n\n        var _azsqrt3 = (0, _zsqrt.azsqrt)(zr, zi);\n\n        var _azsqrt4 = _slicedToArray(_azsqrt3, 2);\n\n        str = _azsqrt4[0];\n        sti = _azsqrt4[1];\n\n        ztar = tth * (zr * str - zi * sti);\n        ztai = tth * (zr * sti + zi * str);\n\n        var _azexp3 = (0, _zexp.azexp)(ztar, ztai);\n\n        var _azexp4 = _slicedToArray(_azexp3, 2);\n\n        str = _azexp4[0];\n        sti = _azexp4[1];\n\n        ptr = str * air - sti * aii;\n        aii = str * aii + sti * air;\n        air = ptr;\n        break mainExecutionLoop;\n      // c-----------------------------------------------------------------------\n      // c     case for cabs(z) > 1.0\n      // c-----------------------------------------------------------------------\n      case 70:\n        fnu = (1.0 + fid) / 3.0;\n        // c-----------------------------------------------------------------------\n        // c     set parameters related to machine constants.\n        // c     tol is the approximate unit roundoff limited to 1.0e-18.\n        // c     elim is the approximate exponential over- and underflow limit.\n        // c     exp(-elim) < exp(-alim)=exp(-elim)/tol    and\n        // c     exp(elim) > exp(alim)=exp(elim)*tol       are intervals near\n        // c     underflow and overflow limits where scaled arithmetic is done.\n        // c     rl is the lower boundary of the asymptotic expansion for large z.\n        // c     dig = number of base 10 digits in tol = 10**(-dig).\n        // c-----------------------------------------------------------------------\n        k1 = (0, _i1mach.i1mach)(15);\n        k2 = (0, _i1mach.i1mach)(16);\n        r1m5 = (0, _d1mach.d1mach)(5);\n        k = Math.min(Math.abs(k1), Math.abs(k2));\n        elim = 2.303 * (k * r1m5 - 3.0);\n        k1 = (0, _i1mach.i1mach)(14) - 1;\n        aa = r1m5 * k1;\n        dig = Math.min(aa, 18.0);\n        aa = aa * 2.303;\n        alim = elim + Math.max(-aa, -41.45);\n        rl = 1.2 * dig + 3.0;\n        alaz = Math.log(az);\n        // c--------------------------------------------------------------------------\n        // c     test for proper range\n        // c-----------------------------------------------------------------------\n        aa = 0.5 / tol;\n        bb = (0, _i1mach.i1mach)(9) * 0.5;\n        aa = Math.min(aa, bb);\n        aa = aa ** tth;\n        if (az > aa) {\n          goToLabel = 260;break;\n        }\n        aa = Math.sqrt(aa);\n        if (az > aa) ierr = 3;\n\n        var _azsqrt5 = (0, _zsqrt.azsqrt)(zr, zi);\n\n        var _azsqrt6 = _slicedToArray(_azsqrt5, 2);\n\n        csqr = _azsqrt6[0];\n        csqi = _azsqrt6[1];\n\n        ztar = tth * (zr * csqr - zi * csqi);\n        ztai = tth * (zr * csqi + zi * csqr);\n        // c-----------------------------------------------------------------------\n        // c     re(zta) <= 0 when re(z) < 0, especially when im(z) is small\n        // c-----------------------------------------------------------------------\n        iflag = 0;\n        sfac = 1.0;\n        ak = ztai;\n        if (zr >= 0.0) {\n          goToLabel = 80;break;\n        }\n        bk = ztar;\n        ck = -Math.abs(bk);\n        ztar = ck;\n        ztai = ak;\n      case 80:\n        if (zi !== 0.0) {\n          goToLabel = 90;break;\n        }\n        if (zr > 0.0) {\n          goToLabel = 90;break;\n        }\n        ztar = 0.0;\n        ztai = ak;\n      case 90:\n        aa = ztar;\n        if (aa >= 0.0 && zr > 0.0) {\n          goToLabel = 110;break;\n        }\n        if (kode === 2) {\n          goToLabel = 100;break;\n        }\n        // c-----------------------------------------------------------------------\n        // c     overflow test\n        // c-----------------------------------------------------------------------\n        if (aa > -alim) {\n          goToLabel = 100;break;\n        }\n        aa = -aa + 0.25 * alaz;\n        iflag = 1;\n        sfac = tol;\n        if (aa > elim) {\n          goToLabel = 270;break;\n        }\n      case 100:\n        // c-----------------------------------------------------------------------\n        // c     cbknu and cacon return exp(zta)*k(fnu,zta) on kode=2\n        // c-----------------------------------------------------------------------\n        mr = 1;\n        if (zi < 0.0) mr = -1;\n        nn = (0, _zacai.zacai)(ztar, ztai, fnu, kode, mr, 1, cyr, cyi, rl, tol, elim, alim);\n        if (nn < 0) {\n          goToLabel = 280;break;\n        }\n        nz = nz + nn;\n        goToLabel = 130;break;\n      case 110:\n        if (kode === 2) {\n          goToLabel = 120;break;\n        }\n        // c-----------------------------------------------------------------------\n        // c     underflow test\n        // c-----------------------------------------------------------------------\n        if (aa < alim) {\n          goToLabel = 120;break;\n        }\n        aa = -aa - 0.25 * alaz;\n        iflag = 2;\n        sfac = 1.0 / tol;\n        if (aa < -elim) {\n          goToLabel = 210;break;\n        }\n      case 120:\n        nz = (0, _zbknu.zbknu)(ztar, ztai, fnu, kode, 1, cyr, cyi, tol, elim, alim);\n      case 130:\n        s1r = cyr[0] * coef;\n        s1i = cyi[0] * coef;\n        if (iflag !== 0) {\n          goToLabel = 150;break;\n        }\n        if (id === 1) {\n          goToLabel = 140;break;\n        }\n        air = csqr * s1r - csqi * s1i;\n        aii = csqr * s1i + csqi * s1r;\n        break mainExecutionLoop;\n      case 140:\n        air = -(zr * s1r - zi * s1i);\n        aii = -(zr * s1i + zi * s1r);\n        break mainExecutionLoop;\n      case 150:\n        s1r = s1r * sfac;\n        s1i = s1i * sfac;\n        if (id === 1) {\n          goToLabel = 160;break;\n        }\n        str = s1r * csqr - s1i * csqi;\n        s1i = s1r * csqi + s1i * csqr;\n        s1r = str;\n        air = s1r / sfac;\n        aii = s1i / sfac;\n        break mainExecutionLoop;\n      case 160:\n        str = -(s1r * zr - s1i * zi);\n        s1i = -(s1r * zi + s1i * zr);\n        s1r = str;\n        air = s1r / sfac;\n        aii = s1i / sfac;\n        break mainExecutionLoop;\n      case 170:\n        aa = 1.0e+3 * (0, _d1mach.d1mach)(1);\n        s1r = zeror;\n        s1i = zeroi;\n        if (id === 1) {\n          goToLabel = 190;break;\n        }\n        if (az <= aa) {\n          goToLabel = 180;break;\n        }\n        s1r = c2 * zr;\n        s1i = c2 * zi;\n      case 180:\n        air = c1 - s1r;\n        aii = -s1i;\n        break mainExecutionLoop;\n      case 190:\n        air = -c2;\n        aii = 0.0;\n        aa = Math.sqrt(aa);\n        if (az <= aa) {\n          goToLabel = 200;break;\n        }\n        s1r = 0.5 * (zr * zr - zi * zi);\n        s1i = zr * zi;\n      case 200:\n        air = air + c1 * s1r;\n        aii = aii + c1 * s1i;\n        break mainExecutionLoop;\n      case 210:\n        nz = 1;\n        air = zeror;\n        aii = zeroi;\n        break mainExecutionLoop;\n      case 270:\n        nz = 0;\n        ierr = 2;\n        break mainExecutionLoop;\n      case 280:\n        if (nn === -1) {\n          goToLabel = 270;break;\n        }\n        nz = 0;\n        ierr = 5;\n        break mainExecutionLoop;\n      case 260:\n        ierr = 4;\n        nz = 0;\n      default:\n        break mainExecutionLoop;\n    }\n  }\n\n  return [air, aii, nz, ierr];\n}\n},{\"../../utils/fortran-utils/d1mach.js\":91,\"../../utils/fortran-utils/i1mach.js\":92,\"./zabs.js\":11,\"./zacai.js\":12,\"./zbknu.js\":23,\"./zexp.js\":27,\"./zsqrt.js\":36}],15:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); /* eslint-disable no-labels */\n/* eslint-disable no-fallthrough */\n// SUBROUTINE ZASYI(ZR, ZI, FNU, KODE, N, YR, YI, NZ, RL, TOL, ELIM, ALIM)\n// ***BEGIN PROLOGUE  ZASYI\n// ***REFER TO  ZBESI,ZBESK\n//\n//      ZASYI COMPUTES THE I BESSEL FUNCTION FOR REAL(Z).GE.0.0 BY\n//      MEANS OF THE ASYMPTOTIC EXPANSION FOR LARGE CABS(Z) IN THE\n//      REGION CABS(Z).GT.MAX(RL,FNU*FNU/2). NZ=0 IS A NORMAL RETURN.\n//      NZ.LT.0 INDICATES AN OVERFLOW ON KODE=1.\n//\n// ***ROUTINES CALLED  D1MACH,AZABS,ZDIV,AZEXP,ZMLT,AZSQRT\n// ***END PROLOGUE  ZASYI\n\n\nexports.zasyi = zasyi;\n\nvar _d1mach = require('../../utils/fortran-utils/d1mach.js');\n\nvar _zabs = require('./zabs.js');\n\nvar _zdiv3 = require('./zdiv.js');\n\nvar _zexp = require('./zexp.js');\n\nvar _zmlt7 = require('./zmlt.js');\n\nvar _zsqrt = require('./zsqrt.js');\n\nfunction zasyi(zr, zi, fnu, kode, n, yr, yi, rl, tol, elim, alim) {\n  var aa = void 0,\n      aez = void 0,\n      ak = void 0,\n      ak1i = void 0,\n      ak1r = void 0,\n      arg = void 0,\n      arm = void 0,\n      atol = void 0,\n      az = void 0,\n      bb = void 0,\n      bk = void 0,\n      cki = void 0,\n      ckr = void 0,\n      conei = void 0,\n      coner = void 0,\n      cs1i = void 0,\n      cs1r = void 0,\n      cs2i = void 0,\n      cs2r = void 0,\n      czi = void 0,\n      czr = void 0,\n      dfnu = void 0,\n      dki = void 0,\n      dkr = void 0,\n      dnu2 = void 0,\n      ezi = void 0,\n      ezr = void 0,\n      fdn = void 0,\n      pi = void 0,\n      p1i = void 0,\n      p1r = void 0,\n      raz = void 0,\n      rtpi = void 0,\n      rtr1 = void 0,\n      rzi = void 0,\n      rzr = void 0,\n      s = void 0,\n      sgn = void 0,\n      sqk = void 0,\n      sti = void 0,\n      str = void 0,\n      s2i = void 0,\n      s2r = void 0,\n      tzi = void 0,\n      tzr = void 0,\n      zeroi = void 0,\n      zeror = void 0,\n      i = void 0,\n      ib = void 0,\n      il = void 0,\n      inu = void 0,\n      j = void 0,\n      jl = void 0,\n      k = void 0,\n      koded = void 0,\n      m = void 0,\n      nn = void 0,\n      nz = void 0;\n\n  var goToLabel = 0;\n  mainExecutionLoop: while (true) {\n    mainSwitch: switch (goToLabel) {\n      case 0:\n        pi = 3.14159265358979324;\n        rtpi = 0.159154943091895336;\n        zeror = 0.0;\n        zeroi = 0.0;\n        coner = 1.0;\n        conei = 0.0;\n\n        nz = 0;\n        az = (0, _zabs.azabs)(zr, zi);\n        arm = 1.0e+3 * (0, _d1mach.d1mach)(1);\n        rtr1 = Math.sqrt(arm);\n        il = Math.min(2, n);\n        dfnu = fnu + (n - il);\n        // c-----------------------------------------------------------------------\n        // c     overflow test\n        // c-----------------------------------------------------------------------\n        raz = 1.0 / az;\n        str = zr * raz;\n        sti = -zi * raz;\n        ak1r = rtpi * str * raz;\n        ak1i = rtpi * sti * raz;\n\n        var _azsqrt = (0, _zsqrt.azsqrt)(ak1r, ak1i);\n\n        var _azsqrt2 = _slicedToArray(_azsqrt, 2);\n\n        ak1r = _azsqrt2[0];\n        ak1i = _azsqrt2[1];\n\n        czr = zr;\n        czi = zi;\n        if (kode !== 2) {\n          goToLabel = 10;break;\n        }\n        czr = zeror;\n        czi = zi;\n      case 10:\n        if (Math.abs(czr) > elim) {\n          goToLabel = 100;break;\n        }\n        dnu2 = dfnu + dfnu;\n        koded = 1;\n        if (Math.abs(czr) > alim && n > 2) {\n          goToLabel = 20;break;\n        }\n        koded = 0;\n\n        var _azexp = (0, _zexp.azexp)(czr, czi);\n\n        var _azexp2 = _slicedToArray(_azexp, 2);\n\n        str = _azexp2[0];\n        sti = _azexp2[1];\n\n        var _zmlt = (0, _zmlt7.zmlt)(ak1r, ak1i, str, sti);\n\n        var _zmlt2 = _slicedToArray(_zmlt, 2);\n\n        ak1r = _zmlt2[0];\n        ak1i = _zmlt2[1];\n\n      case 20:\n        fdn = 0.0;\n        if (dnu2 > rtr1) fdn = dnu2 * dnu2;\n        ezr = zr * 8.0;\n        ezi = zi * 8.0;\n        // c-----------------------------------------------------------------------\n        // c     when z is imaginary, the error test must be made relative to the\n        // c     first reciprocal power since this is the leading term of the\n        // c     expansion for the imaginary part.\n        // c-----------------------------------------------------------------------\n        aez = 8.0 * az;\n        s = tol / aez;\n        jl = Math.trunc(rl + rl) + 2;\n        p1r = zeror;\n        p1i = zeroi;\n        if (zi === 0.0) {\n          goToLabel = 30;break;\n        }\n        // c-----------------------------------------------------------------------\n        // c     calculate exp(pi*(0.5+fnu+n-il)*i) to minimize losses of\n        // c     significance when fnu or n is large\n        // c-----------------------------------------------------------------------\n        inu = Math.trunc(fnu);\n        arg = (fnu - inu) * pi;\n        inu = inu + n - il;\n        ak = -Math.sin(arg);\n        bk = Math.cos(arg);\n        if (zi < 0.0) {\n          bk = -bk;\n        }\n        p1r = ak;\n        p1i = bk;\n        if (inu % 2 === 0) {\n          goToLabel = 30;break;\n        }\n        p1r = -p1r;\n        p1i = -p1i;\n      case 30:\n        // for loop 70:\n        for (k = 1; k <= il; k++) {\n          sqk = fdn - 1.0;\n          atol = s * Math.abs(sqk);\n          sgn = 1.0;\n          cs1r = coner;\n          cs1i = conei;\n          cs2r = coner;\n          cs2i = conei;\n          ckr = coner;\n          cki = conei;\n          ak = 0.0;\n          aa = 1.0;\n          bb = aez;\n          dkr = ezr;\n          dki = ezi;\n          // for loop 40\n          for (j = 1; j <= jl; j++) {\n            var _zdiv = (0, _zdiv3.zdiv)(ckr, cki, dkr, dki);\n\n            var _zdiv2 = _slicedToArray(_zdiv, 2);\n\n            str = _zdiv2[0];\n            sti = _zdiv2[1];\n\n            ckr = str * sqk;\n            cki = sti * sqk;\n            cs2r = cs2r + ckr;\n            cs2i = cs2i + cki;\n            sgn = -sgn;\n            cs1r = cs1r + ckr * sgn;\n            cs1i = cs1i + cki * sgn;\n            dkr = dkr + ezr;\n            dki = dki + ezi;\n            aa = aa * Math.abs(sqk) / bb;\n            bb = bb + aez;\n            ak = ak + 8.0;\n            sqk = sqk - ak;\n            if (aa <= atol) {\n              goToLabel = 50;break;\n            }\n          }\n          if (goToLabel === 50) {\n            // go to 50 - loop converged under atol\n          } else {\n            // 40   continue - throw error\n            goToLabel = 110;break mainSwitch;\n          }\n          // 50 continue\n          s2r = cs1r;\n          s2i = cs1i;\n          if (zr + zr >= elim) {\n            // goToLabel = 60;\n          } else {\n            tzr = zr + zr;\n            tzi = zi + zi;\n\n            var _azexp3 = (0, _zexp.azexp)(-tzr, -tzi);\n\n            var _azexp4 = _slicedToArray(_azexp3, 2);\n\n            str = _azexp4[0];\n            sti = _azexp4[1];\n\n            var _zmlt3 = (0, _zmlt7.zmlt)(str, sti, p1r, p1i);\n\n            var _zmlt4 = _slicedToArray(_zmlt3, 2);\n\n            str = _zmlt4[0];\n            sti = _zmlt4[1];\n\n            var _zmlt5 = (0, _zmlt7.zmlt)(str, sti, cs2r, cs2i);\n\n            var _zmlt6 = _slicedToArray(_zmlt5, 2);\n\n            str = _zmlt6[0];\n            sti = _zmlt6[1];\n\n            s2r = s2r + str;\n            s2i = s2i + sti;\n          }\n          fdn = fdn + 8.0 * dfnu + 4.0;\n          p1r = -p1r;\n          p1i = -p1i;\n          m = n - il + k;\n          yr[m - 1] = s2r * ak1r - s2i * ak1i;\n          yi[m - 1] = s2r * ak1i + s2i * ak1r;\n        }\n        if (n <= 2) {\n          break mainExecutionLoop;\n        }\n        nn = n;\n        k = nn - 2;\n        ak = k;\n        str = zr * raz;\n        sti = -zi * raz;\n        rzr = (str + str) * raz;\n        rzi = (sti + sti) * raz;\n        ib = 3;\n        // do 80 i=ib,nn\n        for (i = ib; i <= nn; i++) {\n          yr[k - 1] = (ak + fnu) * (rzr * yr[k] - rzi * yi[k]) + yr[k + 1];\n          yi[k - 1] = (ak + fnu) * (rzr * yi[k] + rzi * yr[k]) + yi[k + 1];\n          ak = ak - 1.0;\n          k = k - 1;\n        }\n        if (koded === 0) {\n          break mainExecutionLoop;\n        }\n\n        // do 90 i=1,nn\n        var _azexp5 = (0, _zexp.azexp)(czr, czi);\n\n        var _azexp6 = _slicedToArray(_azexp5, 2);\n\n        ckr = _azexp6[0];\n        cki = _azexp6[1];\n        for (i = 1; i <= nn; i++) {\n          str = yr[i - 1] * ckr - yi[i - 1] * cki;\n          yi[i - 1] = yr[i - 1] * cki + yi[i - 1] * ckr;\n          yr[i - 1] = str;\n        }\n        break mainExecutionLoop;\n      case 100:\n        nz = -1;\n        break mainExecutionLoop;\n      case 110:\n        nz = -2;\n      default:\n        break mainExecutionLoop;\n    }\n  }\n\n  return nz;\n}\n},{\"../../utils/fortran-utils/d1mach.js\":91,\"./zabs.js\":11,\"./zdiv.js\":26,\"./zexp.js\":27,\"./zmlt.js\":31,\"./zsqrt.js\":36}],16:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.zbesh = zbesh;\n\nvar _fortranHelpers = require('../../utils/fortranHelpers.js');\n\nvar fortranHelpers = _interopRequireWildcard(_fortranHelpers);\n\nvar _d1mach = require('../../utils/fortran-utils/d1mach.js');\n\nvar _i1mach = require('../../utils/fortran-utils/i1mach.js');\n\nvar _zuoik = require('./zuoik.js');\n\nvar _zbknu = require('./zbknu.js');\n\nvar _zacon = require('./zacon.js');\n\nvar _zbunk = require('./zbunk.js');\n\nvar _zabs = require('./zabs.js');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/* eslint-disable no-labels */\n/* eslint-disable no-fallthrough */\n// **BEGIN PROLOGUE  ZBESH\n// **DATE WRITTEN   830501   (YYMMDD)\n// **REVISION DATE  890801   (YYMMDD)\n// ***PORT TO ECMASCRIPT  201801   (YYYYMM)\n// **CATEGORY NO.  B5K\n// **KEYWORDS  H-BESSEL FUNCTIONS,BESSEL FUNCTIONS OF COMPLEX ARGUMENT,\n//            BESSEL FUNCTIONS OF THIRD KIND,HANKEL FUNCTIONS\n// **AUTHOR (FORTRAN) AMOS, DONALD E., SANDIA NATIONAL LABORATORIES\n// **AUTHOR (ECMASCRIPT) ERB, KC, KINGS DISTRIBUTED SYSTEMS\n// **PURPOSE  TO COMPUTE THE H-BESSEL FUNCTIONS OF A COMPLEX ARGUMENT\n// **DESCRIPTION\n//\n//                      ***A DOUBLE PRECISION ROUTINE***\n//         ON KODE=1, ZBESH COMPUTES AN N MEMBER SEQUENCE OF COMPLEX\n//         HANKEL (BESSEL) FUNCTIONS CY(J)=H(M,FNU+J-1,Z) FOR KINDS M=1\n//         OR 2, REAL, NONNEGATIVE ORDERS FNU+J-1, J=1,...,N, AND COMPLEX\n//         Z !== CMPLX(0.0,0.0) IN THE CUT PLANE -PI < ARG(Z) <= PI.\n//         ON KODE=2, ZBESH RETURNS THE SCALED HANKEL FUNCTIONS\n//\n//         CY(I)=MATH.EXP(-MM*Z*I)*H(M,FNU+J-1,Z)       MM=3-2*M,   I**2=-1.\n//\n//         WHICH REMOVES THE EXPONENTIAL BEHAVIOR IN BOTH THE UPPER AND\n//         LOWER HALF PLANES. DEFINITIONS AND NOTATION ARE FOUND IN THE\n//         NBS HANDBOOK OF MATHEMATICAL FUNCTIONS (REF. 1).\n//\n//         INPUT      ZR,ZI,FNU ARE DOUBLE PRECISION\n//           ZR,ZI  - Z=CMPLX(ZR,ZI), Z !== CMPLX(0.0E0,0.0E0),\n//                    -PT < ARG(Z) <= PI\n//           FNU    - ORDER OF INITIAL H FUNCTION, FNU >= 0.0E0\n//           KODE   - A PARAMETER TO INDICATE THE SCALING OPTION\n//                    KODE= 1  RETURNS\n//                             CY(J)=H(M,FNU+J-1,Z),   J=1,...,N\n//                        = 2  RETURNS\n//                             CY(J)=H(M,FNU+J-1,Z)*MATH.EXP(-I*Z*(3-2M))\n//                                  J=1,...,N  ,  I**2=-1\n//           M      - KIND OF HANKEL FUNCTION, M=1 OR 2\n//           N      - NUMBER OF MEMBERS IN THE SEQUENCE, N >= 1\n//\n//         OUTPUT     CYR,CYI ARE DOUBLE PRECISION\n//           CYR,CYI- DOUBLE PRECISION VECTORS WHOSE FIRST N COMPONENTS\n//                    CONTAIN REAL AND IMAGINARY PARTS FOR THE SEQUENCE\n//                    CY(J)=H(M,FNU+J-1,Z)  OR\n//                    CY(J)=H(M,FNU+J-1,Z)*MATH.EXP(-I*Z*(3-2M))  J=1,...,N\n//                    DEPENDING ON KODE, I**2=-1.\n//           NZ     - NUMBER OF COMPONENTS SET TO ZERO DUE TO UNDERFLOW,\n//                    NZ= 0   , NORMAL RETURN\n//                    NZ > 0 , FIRST NZ COMPONENTS OF CY SET TO ZERO DUE\n//                              TO UNDERFLOW, CY(J)=CMPLX(0.0E0,0.0E0)\n//                              J=1,...,NZ WHEN Y > 0.0 AND M=1 OR\n//                              Y < 0.0 AND M=2. FOR THE COMPLMENTARY\n//                              HALF PLANES, NZ STATES ONLY THE NUMBER\n//                              OF UNDERFLOWS.\n//           IERR   - ERROR FLAG\n//                    IERR=0, NORMAL RETURN - COMPUTATION COMPLETED\n//                    IERR=1, INPUT ERROR   - NO COMPUTATION\n//                    IERR=2, OVERFLOW      - NO COMPUTATION, FNU TOO\n//                            LARGE OR CABS(Z) TOO SMALL OR BOTH\n//                    IERR=3, CABS(Z) OR FNU+N-1 LARGE - COMPUTATION DONE\n//                            BUT LOSSES OF SIGNIFCANCE BY ARGUMENT\n//                            REDUCTION PRODUCE LESS THAN HALF OF MACHINE\n//                            ACCURACY\n//                    IERR=4, CABS(Z) OR FNU+N-1 TOO LARGE - NO COMPUTA-\n//                            TION BECAUSE OF COMPLETE LOSSES OF SIGNIFI-\n//                            CANCE BY ARGUMENT REDUCTION\n//                    IERR=5, ERROR              - NO COMPUTATION,\n//                            ALGORITHM TERMINATION CONDITION NOT MET\n//\n// **LONG DESCRIPTION\n//\n//         THE COMPUTATION IS CARRIED OUT BY THE RELATION\n//\n//         H(M,FNU,Z)=(MATH.TRUNC(1/M)P)*MATH.EXP(-MP*FNU)*K(FNU,Z*MATH.EXP(-MP))\n//             MP=MM*HPI*I,  MM=3-2*M,  HPI=PMATH.TRUNC(I/2),  I**2=-1\n//\n//         FOR M=1 OR 2 WHERE THE K BESSEL FUNCTION IS COMPUTED FOR THE\n//         RIGHT HALF PLANE RE(Z) >= 0.0. THE K FUNCTION IS CONTINUED\n//         TO THE LEFT HALF PLANE BY THE RELATION\n//\n//         K(FNU,Z*MATH.EXP(MP)) = MATH.EXP(-MP*FNU)*K(FNU,Z)-MP*I(FNU,Z)\n//         MP=MR*PI*I, MR=+1 OR -1, RE(Z) > 0, I**2=-1\n//\n//         WHERE I(FNU,Z) IS THE I BESSEL FUNCTION.\n//\n//         EXPONENTIAL DECAY OF H(M,FNU,Z) OCCURS IN THE UPPER HALF Z\n//         PLANE FOR M=1 AND THE LOWER HALF Z PLANE FOR M=2.  EXPONENTIAL\n//         GROWTH OCCURS IN THE COMPLEMENTARY HALF PLANES.  SCALING\n//         BY MATH.EXP(-MM*Z*I) REMOVES THE EXPONENTIAL BEHAVIOR IN THE\n//         WHOLE Z PLANE FOR Z TO INFINITY.\n//\n//         FOR NEGATIVE ORDERS,THE FORMULAE\n//\n//               H(1,-FNU,Z) = H(1,FNU,Z)*CEXP( PI*FNU*I)\n//               H(2,-FNU,Z) = H(2,FNU,Z)*CEXP(-PI*FNU*I)\n//                         I**2=-1\n//\n//         CAN BE USED.\n//\n//         IN MOST COMPLEX VARIABLE COMPUTATION, ONE MUST EVALUATE ELE-\n//         MENTARY FUNCTIONS. WHEN THE MAGNITUDE OF Z OR FNU+N-1 IS\n//         LARGE, LOSSES OF SIGNIFICANCE BY ARGUMENT REDUCTION OCCUR.\n//         CONSEQUENTLY, IF EITHER ONE EXCEEDS U1=MATH.SQRT(0.5/UR), {\n//         LOSSES EXCEEDING HALF PRECISION ARE LIKELY AND AN ERROR FLAG\n//         IERR=3 IS TRIGGERED WHERE UR=MATH.MAX(D1MACH(4),1.0E-18) IS\n//         DOUBLE PRECISION UNIT ROUNDOFF LIMITED TO 18 DIGITS PRECISION.\n//         IF EITHER IS LARGER THAN U2=0.5/UR, { ALL SIGNIFICANCE IS\n//         LOST AND IERR=4. IN ORDER TO USE THE INT FUNCTION, ARGUMENTS\n//         MUST BE FURTHER RESTRICTED NOT TO EXCEED THE LARGEST MACHINE\n//         INTEGER, U3=I1MACH(9). THUS, THE MAGNITUDE OF Z AND FNU+N-1 IS\n//         RESTRICTED BY MATH.MIN(U2,U3). ON 32 BIT MACHINES, U1,U2, AND U3\n//         ARE APPROXIMATELY 2.0E+3, 4.2E+6, 2.1E+9 IN SINGLE PRECISION\n//         ARITHMETIC AND 1.3E+8, 1.8E+16, 2.1E+9 IN DOUBLE PRECISION\n//         ARITHMETIC RESPECTIVELY. THIS MAKES U2 AND U3 LIMITING IN\n//         THEIR RESPECTIVE ARITHMETICS. THIS MEANS THAT ONE CAN EXPECT\n//         TO RETAIN, IN THE WORST CASES ON 32 BIT MACHINES, NO DIGITS\n//         IN SINGLE AND ONLY 7 DIGITS IN DOUBLE PRECISION ARITHMETIC.\n//         SIMILAR CONSIDERATIONS HOLD FOR OTHER MACHINES.\n//\n//         THE APPROXIMATE RELATIVE ERROR IN THE MAGNITUDE OF A COMPLEX\n//         BESSEL FUNCTION CAN BE EXPRESSED BY P*10**S WHERE P=MATH.MAX(UNIT\n//         ROUNDOFF,1.0E-18) IS THE NOMINAL PRECISION AND 10**S REPRE-\n//         SENTS THE INCREASE IN ERROR DUE TO ARGUMENT REDUCTION IN THE\n//         ELEMENTARY FUNCTIONS. HERE, S=MATH.MAX(1,MATH.ABS(MATH.LOG10(CABS(Z))),\n//         MATH.ABS(MATH.LOG10(FNU))) APPROXIMATELY (I.E. S=MATH.MAX(1,MATH.ABS(EXPONENT OF\n//         CABS(Z),ABS(EXPONENT OF FNU))) ). HOWEVER, THE PHASE ANGLE MAY\n//         HAVE ONLY ABSOLUTE ACCURACY. THIS IS MOST LIKELY TO OCCUR WHEN\n//         ONE COMPONENT (IN ABSOLUTE VALUE) IS LARGER THAN THE OTHER BY\n//         SEVERAL ORDERS OF MAGNITUDE. IF ONE COMPONENT IS 10**K LARGER\n//         THAN THE OTHER, { ONE CAN EXPECT ONLY MATH.MAX(MATH.ABS(MATH.LOG10(P))-K,\n//         0) SIGNIFICANT DIGITS; OR, STATED ANOTHER WAY, WHEN K EXCEEDS\n//         THE EXPONENT OF P, NO SIGNIFICANT DIGITS REMAIN IN THE SMALLER\n//         COMPONENT. HOWEVER, THE PHASE ANGLE RETAINS ABSOLUTE ACCURACY\n//         BECAUSE, IN COMPLEX ARITHMETIC WITH PRECISION P, THE SMALLER\n//         COMPONENT WILL NOT (AS A RULE) DECREASE BELOW P TIMES THE\n//         MAGNITUDE OF THE LARGER COMPONENT. IN THESE EXTREME CASES,\n//         THE PRINCIPAL PHASE ANGLE IS ON THE ORDER OF +P, -P, PMATH.TRUNC(I/2)-P,\n//         OR -PMATH.TRUNC(I/2)+P.\n//\n// **REFERENCES  HANDBOOK OF MATHEMATICAL FUNCTIONS BY M. ABRAMOWITZ\n//                 AND I. A. STEGUN, NBS AMS SERIES 55, U.S. DEPT. OF\n//                 COMMERCE, 1955.\n//\n//               COMPUTATION OF BESSEL FUNCTIONS OF COMPLEX ARGUMENT\n//                 BY D. E. AMOS, SAND83-0083, MAY, 1983.\n//\n//               COMPUTATION OF BESSEL FUNCTIONS OF COMPLEX ARGUMENT\n//                 AND LARGE ORDER BY D. E. AMOS, SAND83-0643, MAY, 1983\n//\n//               A SUBROUTINE PACKAGE FOR BESSEL FUNCTIONS OF A COMPLEX\n//                 ARGUMENT AND NONNEGATIVE ORDER BY D. E. AMOS, SAND85-\n//                 1018, MAY, 1985\n//\n//               A PORTABLE PACKAGE FOR BESSEL FUNCTIONS OF A COMPLEX\n//                 ARGUMENT AND NONNEGATIVE ORDER BY D. E. AMOS, TRANS.\n//                 MATH. SOFTWARE, 1986\n//\n// **ROUTINES ED()  ZACON,ZBKNU,ZBUNK,ZUOIK,AZABS,I1MACH,D1MACH\n// **END PROLOGUE  ZBESH\n//\n//     COMPLEX CY,Z,ZN,ZT,CSGN\nfunction zbesh(zr, zi, fnu, kode, m, n, cyr, cyi) {\n  var aa = void 0,\n      alim = void 0,\n      aln = void 0,\n      arg = void 0,\n      az = void 0,\n      dig = void 0,\n      elim = void 0,\n      fmm = void 0,\n      fn = void 0,\n      fnul = void 0,\n      hpi = void 0,\n      rhpi = void 0,\n      rl = void 0,\n      r1m5 = void 0,\n      sgn = void 0,\n      str = void 0,\n      tol = void 0,\n      ufl = void 0,\n      zni = void 0,\n      znr = void 0,\n      zti = void 0,\n      bb = void 0,\n      ascle = void 0,\n      rtol = void 0,\n      atol = void 0,\n      sti = void 0,\n      csgnr = void 0,\n      csgni = void 0,\n      i = void 0,\n      inu = void 0,\n      inuh = void 0,\n      ir = void 0,\n      k = void 0,\n      k1 = void 0,\n      k2 = void 0,\n      mm = void 0,\n      mr = void 0,\n      nn = void 0,\n      nuf = void 0,\n      nw = void 0,\n      nz = void 0,\n      ierr = void 0;\n\n  var goToLabel = 0;\n  mainExecutionLoop: while (true) {\n    switch (goToLabel) {\n      case 0:\n        hpi = 1.57079632679489662e0;\n        ierr = 0;\n        nz = 0;\n        if (zr === 0.0e0 && zi === 0.0e0) ierr = 1;\n        if (fnu < 0.0e0) ierr = 1;\n        if (m < 1 || m > 2) ierr = 1;\n        if (kode < 1 || kode > 2) ierr = 1;\n        if (n < 1) ierr = 1;\n        if (ierr !== 0) break mainExecutionLoop;\n        nn = n;\n        // -----------------------------------------------------------------------\n        //     set parameters related to machine constants.\n        //     tol is the approximate unit roundoff limited to 1.0e-18.\n        //     elim is the approximate exponential over- and underflow limit.\n        //     Math.exp(-elim) < Math.exp(-alim)=Math.exp(-elim)/tol    and\n        //     Math.exp(elim) > Math.exp(alim)=Math.exp(elim)*tol       are intervals near\n        //     underflow and overflow limits where scaled arithmetic is done.\n        //     rl is the lower boundary of the asymptotic expansion for large z.\n        //     dig = number of base 10 digits in tol = 10**(-dig).\n        //     fnul is the lower boundary of the asymptotic series for large fnu\n        // -----------------------------------------------------------------------\n        tol = Math.max((0, _d1mach.d1mach)(4), 1.0e-18);\n        k1 = (0, _i1mach.i1mach)(15);\n        k2 = (0, _i1mach.i1mach)(16);\n        r1m5 = (0, _d1mach.d1mach)(5);\n        k = Math.min(Math.abs(k1), Math.abs(k2));\n        elim = 2.303e0 * (k * r1m5 - 3.0e0);\n        k1 = (0, _i1mach.i1mach)(14) - 1;\n        aa = r1m5 * k1;\n        dig = Math.min(aa, 18.0e0);\n        aa = aa * 2.303e0;\n        alim = elim + Math.max(-aa, -41.45e0);\n        fnul = 10.0e0 + 6.0e0 * (dig - 3.0e0);\n        rl = 1.2e0 * dig + 3.0e0;\n        fn = fnu + (nn - 1);\n        mm = 3 - m - m;\n        fmm = mm;\n        znr = fmm * zi;\n        zni = -fmm * zr;\n        // -----------------------------------------------------------------------\n        //     test for proper range\n        // -----------------------------------------------------------------------\n        az = (0, _zabs.azabs)(zr, zi);\n        aa = 0.5e0 / tol;\n        bb = (0, _i1mach.i1mach)(9) * 0.5e0;\n        aa = Math.min(aa, bb);\n        if (az > aa) {\n          goToLabel = 260;break;\n        }\n        if (fn > aa) {\n          goToLabel = 260;break;\n        }\n        aa = Math.sqrt(aa);\n        if (az > aa) ierr = 3;\n        if (fn > aa) ierr = 3;\n        // -----------------------------------------------------------------------\n        //     overflow test on the last member of the sequence\n        // -----------------------------------------------------------------------\n        ufl = (0, _d1mach.d1mach)(1) * 1.0e+3;\n        if (az < ufl) {\n          goToLabel = 230;break;\n        }\n        if (fnu > fnul) {\n          goToLabel = 90;break;\n        }\n        if (fn <= 1.0e0) {\n          goToLabel = 70;break;\n        }\n        if (fn > 2.0e0) {\n          goToLabel = 60;break;\n        }\n        if (az > tol) {\n          goToLabel = 70;break;\n        }\n        arg = 0.5e0 * az;\n        aln = -fn * Math.log(arg);\n        if (aln > elim) {\n          goToLabel = 230;break;\n        }\n        goToLabel = 70;break;\n      case 60:\n\n        nuf = (0, _zuoik.zuoik)(znr, zni, fnu, kode, 2, nn, cyr, cyi, tol, elim, alim);\n        if (nuf < 0) {\n          goToLabel = 230;break;\n        }\n        nz = nz + nuf;\n        nn = nn - nuf;\n        // -----------------------------------------------------------------------\n        //     here nn=n or nn=0 since nuf=0,nn, or -1 on return from cuoik\n        //     if nuf=nn, { cy(i)=czero for all i\n        // -----------------------------------------------------------------------\n        if (nn === 0) {\n          goToLabel = 140;break;\n        }\n      case 70:\n\n        if (znr < 0.0e0 || znr === 0.0e0 && zni < 0.0e0 && m === 2) {\n          goToLabel = 80;break;\n        }\n        // -----------------------------------------------------------------------\n        //     right half plane computation, xn >= 0. && (xn !== 0. ||\n        //     yn >= 0. || m=1)\n        // -----------------------------------------------------------------------\n        nz = (0, _zbknu.zbknu)(znr, zni, fnu, kode, nn, cyr, cyi, tol, elim, alim);\n        goToLabel = 110;break;\n      // -----------------------------------------------------------------------\n      //     left half plane computation\n      // -----------------------------------------------------------------------\n      case 80:\n\n        mr = -mm;\n        nw = (0, _zacon.zacon)(znr, zni, fnu, kode, mr, nn, cyr, cyi, rl, fnul, tol, elim, alim);\n        if (nw < 0) {\n          goToLabel = 240;break;\n        }\n        nz = nw;\n        goToLabel = 110;break;\n      case 90:\n\n        // -----------------------------------------------------------------------\n        //     uniform asymptotic expansions for fnu > fnul\n        // -----------------------------------------------------------------------\n        mr = 0;\n        if (znr >= 0.0e0 && (znr !== 0.0e0 || zni >= 0.0e0 || m !== 2)) {\n          goToLabel = 100;break;\n        }\n        mr = -mm;\n        if (znr !== 0.0e0 || zni >= 0.0e0) {\n          goToLabel = 100;break;\n        }\n        znr = -znr;\n        zni = -zni;\n      case 100:\n\n        nw = (0, _zbunk.zbunk)(znr, zni, fnu, kode, mr, nn, cyr, cyi, nw, tol, elim, alim);\n        if (nw < 0) {\n          goToLabel = 240;break;\n        }\n        nz = nz + nw;\n      case 110:\n\n        // -----------------------------------------------------------------------\n        //     h(m,fnu,z) = -fmm*(i/hpi)*(zt**fnu)*k(fnu,-z*zt)\n        //\n        //     zt=Math.exp(-fmm*hpi*i) = cmplx(0.0,-fmm), fmm=3-2*m, m=1,2\n        // -----------------------------------------------------------------------\n        sgn = fortranHelpers.sign(hpi, -fmm);\n        // -----------------------------------------------------------------------\n        //     calculate Math.exp(fnu*hpi*i) to minimize losses of significance\n        //     when fnu is large\n        // -----------------------------------------------------------------------\n        inu = Math.trunc(fnu);\n        inuh = Math.trunc(inu / 2);\n        ir = inu - 2 * inuh;\n        arg = (fnu - (inu - ir)) * sgn;\n        rhpi = 1.0e0 / sgn;\n        //     zni = rhpi*Math.cos(arg)\n        //     znr = -rhpi*Math.sin(arg)\n        csgni = rhpi * Math.cos(arg);\n        csgnr = -rhpi * Math.sin(arg);\n        if (inuh % 2 === 0) {\n          goToLabel = 120;break;\n        }\n        //     znr = -znr\n        //     zni = -zni\n        csgnr = -csgnr;\n        csgni = -csgni;\n      case 120:\n\n        zti = -fmm;\n        rtol = 1.0e0 / tol;\n        ascle = ufl * rtol;\n        for (i = 1; i <= nn; i++) {\n          //       str = cyr(i)*znr - cyi(i)*zni\n          //       cyi(i) = cyr(i)*zni + cyi(i)*znr\n          //       cyr(i) = str\n          //       str = -zni*zti\n          //       zni = znr*zti\n          //       znr = str\n          aa = cyr[i - 1];\n          bb = cyi[i - 1];\n          atol = 1.0e0;\n          if (Math.max(Math.abs(aa), Math.abs(bb)) > ascle) {\n            // goToLabel = 135; break;\n          } else {\n            aa = aa * rtol;\n            bb = bb * rtol;\n            atol = tol;\n          }\n          // case 135:\n          str = aa * csgnr - bb * csgni;\n          sti = aa * csgni + bb * csgnr;\n          cyr[i - 1] = str * atol;\n          cyi[i - 1] = sti * atol;\n          str = -csgni * zti;\n          csgni = csgnr * zti;\n          csgnr = str;\n        }\n        break mainExecutionLoop;\n      case 140:\n\n        if (znr < 0.0e0) {\n          goToLabel = 230;break;\n        }\n        break mainExecutionLoop;\n      case 230:\n\n        nz = 0;\n        ierr = 2;\n        break mainExecutionLoop;\n      case 240:\n\n        if (nw === -1) {\n          goToLabel = 230;break;\n        }\n        nz = 0;\n        ierr = 5;\n        break mainExecutionLoop;\n      case 260:\n\n        nz = 0;\n        ierr = 4;\n\n      default:\n        break mainExecutionLoop;\n    }\n  }\n  return [nz, ierr];\n}\n},{\"../../utils/fortran-utils/d1mach.js\":91,\"../../utils/fortran-utils/i1mach.js\":92,\"../../utils/fortranHelpers.js\":93,\"./zabs.js\":11,\"./zacon.js\":13,\"./zbknu.js\":23,\"./zbunk.js\":25,\"./zuoik.js\":44}],17:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.zbesi = zbesi;\n\nvar _i1mach = require('../../utils/fortran-utils/i1mach.js');\n\nvar _d1mach = require('../../utils/fortran-utils/d1mach.js');\n\nvar _zbinu = require('./zbinu.js');\n\nvar _zabs = require('./zabs.js');\n\n/* eslint-disable no-labels */\n/* eslint-disable no-fallthrough */\n// **BEGIN PROLOGUE  ZBESI\n// **DATE WRITTEN   830501   (YYMMDD)\n// **REVISION DATE  890801   (YYMMDD)\n// ***PORT TO ECMASCRIPT  201801   (YYYYMM)\n// **CATEGORY NO.  B5K\n// **KEYWORDS  I-BESSEL FUNCTION,COMPLEX BESSEL FUNCTION,\n//            MODIFIED BESSEL FUNCTION OF THE FIRST KIND\n// **AUTHOR (FORTRAN) AMOS, DONALD E., SANDIA NATIONAL LABORATORIES\n// **AUTHOR (ECMASCRIPT) ERB, KC, KINGS DISTRIBUTED SYSTEMS\n// **PURPOSE  TO COMPUTE I-BESSEL FUNCTIONS OF COMPLEX ARGUMENT\n// **DESCRIPTION\n//\n//                    ***A DOUBLE PRECISION ROUTINE***\n//         ON KODE=1, ZBESI COMPUTES AN N MEMBER SEQUENCE OF COMPLEX\n//         BESSEL FUNCTIONS CY(J)=I(FNU+J-1,Z) FOR REAL, NONNEGATIVE\n//         ORDERS FNU+J-1, J=1,...,N AND COMPLEX Z IN THE CUT PLANE\n//         -PI < ARG(Z) <= PI. ON KODE=2, ZBESI RETURNS THE SCALED\n//         FUNCTIONS\n//\n//         CY(J)=MATH.EXP(-MATH.ABS(X))*I(FNU+J-1,Z)   J = 1,...,N , X=COMPLEXHELPERS.RE(Z)\n//\n//         WITH THE EXPONENTIAL GROWTH REMOVED IN BOTH THE LEFT AND\n//         RIGHT HALF PLANES FOR Z TO INFINITY. DEFINITIONS AND NOTATION\n//         ARE FOUND IN THE NBS HANDBOOK OF MATHEMATICAL FUNCTIONS\n//         (REF. 1).\n//\n//         INPUT      ZR,ZI,FNU ARE DOUBLE PRECISION\n//           ZR,ZI  - Z=CMPLX(ZR,ZI),  -PI < ARG(Z) <= PI\n//           FNU    - ORDER OF INITIAL I FUNCTION, FNU >= 0.0E0\n//           KODE   - A PARAMETER TO INDICATE THE SCALING OPTION\n//                    KODE= 1  RETURNS\n//                             CY(J)=I(FNU+J-1,Z), J=1,...,N\n//                        = 2  RETURNS\n//                             CY(J)=I(FNU+J-1,Z)*MATH.EXP(-MATH.ABS(X)), J=1,...,N\n//           N      - NUMBER OF MEMBERS OF THE SEQUENCE, N >= 1\n//\n//         OUTPUT     CYR,CYI ARE DOUBLE PRECISION\n//           CYR,CYI- DOUBLE PRECISION VECTORS WHOSE FIRST N COMPONENTS\n//                    CONTAIN REAL AND IMAGINARY PARTS FOR THE SEQUENCE\n//                    CY(J)=I(FNU+J-1,Z)  OR\n//                    CY(J)=I(FNU+J-1,Z)*MATH.EXP(-MATH.ABS(X))  J=1,...,N\n//                    DEPENDING ON KODE, X=COMPLEXHELPERS.RE(Z)\n//           NZ     - NUMBER OF COMPONENTS SET TO ZERO DUE TO UNDERFLOW,\n//                    NZ= 0   , NORMAL RETURN\n//                    NZ > 0 , LAST NZ COMPONENTS OF CY SET TO ZERO\n//                              TO UNDERFLOW, CY(J)=CMPLX(0.0E0,0.0E0)\n//                              J = N-NZ+1,...,N\n//           IERR   - ERROR FLAG\n//                    IERR=0, NORMAL RETURN - COMPUTATION COMPLETED\n//                    IERR=1, INPUT ERROR   - NO COMPUTATION\n//                    IERR=2, OVERFLOW      - NO COMPUTATION, RE(Z) TOO\n//                            LARGE ON KODE=1\n//                    IERR=3, CABS(Z) OR FNU+N-1 LARGE - COMPUTATION DONE\n//                            BUT LOSSES OF SIGNIFCANCE BY ARGUMENT\n//                            REDUCTION PRODUCE LESS THAN HALF OF MACHINE\n//                            ACCURACY\n//                    IERR=4, CABS(Z) OR FNU+N-1 TOO LARGE - NO COMPUTA-\n//                            TION BECAUSE OF COMPLETE LOSSES OF SIGNIFI-\n//                            CANCE BY ARGUMENT REDUCTION\n//                    IERR=5, ERROR              - NO COMPUTATION,\n//                            ALGORITHM TERMINATION CONDITION NOT MET\n//\n// **LONG DESCRIPTION\n//\n//         THE COMPUTATION IS CARRIED OUT BY THE POWER SERIES FOR\n//         SMALL CABS(Z), THE ASYMPTOTIC EXPANSION FOR LARGE CABS(Z),\n//         THE MILLER ALGORITHM NORMALIZED BY THE WRONSKIAN AND A\n//         NEUMANN SERIES FOR IMTERMEDIATE MAGNITUDES, AND THE\n//         UNIFORM ASYMPTOTIC EXPANSIONS FOR I(FNU,Z) AND J(FNU,Z)\n//         FOR LARGE ORDERS. BACKWARD RECURRENCE IS USED TO GENERATE\n//         SEQUENCES OR REDUCE ORDERS WHEN NECESSARY.\n//\n//         THE CALCULATIONS ABOVE ARE DONE IN THE RIGHT HALF PLANE AND\n//         CONTINUED INTO THE LEFT HALF PLANE BY THE FORMULA\n//\n//         I(FNU,Z*MATH.EXP(M*PI)) = MATH.EXP(M*PI*FNU)*I(FNU,Z)  COMPLEXHELPERS.RE(Z) > 0.0\n//                       M = +I OR -I,  I**2=-1\n//\n//         FOR NEGATIVE ORDERS,THE FORMULA\n//\n//              I(-FNU,Z) = I(FNU,Z) + (2/PI)*MATH.SIN(PI*FNU)*K(FNU,Z)\n//\n//         CAN BE USED. HOWEVER,FOR LARGE ORDERS CLOSE TO INTEGERS, THE\n//         THE FUNCTION CHANGES RADIY(). WHEN FNU IS A LARGE POSITIVE\n//         INTEGER,THE MAGNITUDE OF I(-FNU,Z)=I(FNU,Z) IS A LARGE\n//         NEGATIVE POWER OF TEN. BUT WHEN FNU IS NOT AN INTEGER,\n//         K(FNU,Z) DOMINATES IN MAGNITUDE WITH A LARGE POSITIVE POWER OF\n//         TEN AND THE MOST THAT THE SECOND TERM CAN BE REDUCED IS BY\n//         UNIT ROUNDOFF FROM THE COEFFICIENT. THUS, WIDE CHANGES CAN\n//         OCCUR WITHIN UNIT ROUNDOFF OF A LARGE INTEGER FOR FNU. HERE,\n//         LARGE MEANS FNU > CABS(Z).\n//\n//         IN MOST COMPLEX VARIABLE COMPUTATION, ONE MUST EVALUATE ELE-\n//         MENTARY FUNCTIONS. WHEN THE MAGNITUDE OF Z OR FNU+N-1 IS\n//         LARGE, LOSSES OF SIGNIFICANCE BY ARGUMENT REDUCTION OCCUR.\n//         CONSEQUENTLY, IF EITHER ONE EXCEEDS U1=MATH.SQRT(0.5/UR), {\n//         LOSSES EXCEEDING HALF PRECISION ARE LIKELY AND AN ERROR FLAG\n//         IERR=3 IS TRIGGERED WHERE UR=MATH.MAX(D1MACH(4),1.0E-18) IS\n//         DOUBLE PRECISION UNIT ROUNDOFF LIMITED TO 18 DIGITS PRECISION.\n//         IF EITHER IS LARGER THAN U2=0.5/UR, { ALL SIGNIFICANCE IS\n//         LOST AND IERR=4. IN ORDER TO USE THE INT FUNCTION, ARGUMENTS\n//         MUST BE FURTHER RESTRICTED NOT TO EXCEED THE LARGEST MACHINE\n//         INTEGER, U3=I1MACH(9). THUS, THE MAGNITUDE OF Z AND FNU+N-1 IS\n//         RESTRICTED BY MATH.MIN(U2,U3). ON 32 BIT MACHINES, U1,U2, AND U3\n//         ARE APPROXIMATELY 2.0E+3, 4.2E+6, 2.1E+9 IN SINGLE PRECISION\n//         ARITHMETIC AND 1.3E+8, 1.8E+16, 2.1E+9 IN DOUBLE PRECISION\n//         ARITHMETIC RESPECTIVELY. THIS MAKES U2 AND U3 LIMITING IN\n//         THEIR RESPECTIVE ARITHMETICS. THIS MEANS THAT ONE CAN EXPECT\n//         TO RETAIN, IN THE WORST CASES ON 32 BIT MACHINES, NO DIGITS\n//         IN SINGLE AND ONLY 7 DIGITS IN DOUBLE PRECISION ARITHMETIC.\n//         SIMILAR CONSIDERATIONS HOLD FOR OTHER MACHINES.\n//\n//         THE APPROXIMATE RELATIVE ERROR IN THE MAGNITUDE OF A COMPLEX\n//         BESSEL FUNCTION CAN BE EXPRESSED BY P*10**S WHERE P=MATH.MAX(UNIT\n//         ROUNDOFF,1.0E-18) IS THE NOMINAL PRECISION AND 10**S REPRE-\n//         SENTS THE INCREASE IN ERROR DUE TO ARGUMENT REDUCTION IN THE\n//         ELEMENTARY FUNCTIONS. HERE, S=MATH.MAX(1,MATH.ABS(MATH.LOG10(CABS(Z))),\n//         MATH.ABS(MATH.LOG10(FNU))) APPROXIMATELY (I.E. S=MATH.MAX(1,MATH.ABS(EXPONENT OF\n//         CABS(Z),ABS(EXPONENT OF FNU))) ). HOWEVER, THE PHASE ANGLE MAY\n//         HAVE ONLY ABSOLUTE ACCURACY. THIS IS MOST LIKELY TO OCCUR WHEN\n//         ONE COMPONENT (IN ABSOLUTE VALUE) IS LARGER THAN THE OTHER BY\n//         SEVERAL ORDERS OF MAGNITUDE. IF ONE COMPONENT IS 10**K LARGER\n//         THAN THE OTHER, { ONE CAN EXPECT ONLY MATH.MAX(MATH.ABS(MATH.LOG10(P))-K,\n//         0) SIGNIFICANT DIGITS; OR, STATED ANOTHER WAY, WHEN K EXCEEDS\n//         THE EXPONENT OF P, NO SIGNIFICANT DIGITS REMAIN IN THE SMALLER\n//         COMPONENT. HOWEVER, THE PHASE ANGLE RETAINS ABSOLUTE ACCURACY\n//         BECAUSE, IN COMPLEX ARITHMETIC WITH PRECISION P, THE SMALLER\n//         COMPONENT WILL NOT (AS A RULE) DECREASE BELOW P TIMES THE\n//         MAGNITUDE OF THE LARGER COMPONENT. IN THESE EXTREME CASES,\n//         THE PRINCIPAL PHASE ANGLE IS ON THE ORDER OF +P, -P, PMATH.TRUNC(I/2)-P,\n//         OR -PMATH.TRUNC(I/2)+P.\n//\n// **REFERENCES  HANDBOOK OF MATHEMATICAL FUNCTIONS BY M. ABRAMOWITZ\n//                 AND I. A. STEGUN, NBS AMS SERIES 55, U.S. DEPT. OF\n//                 COMMERCE, 1955.\n//\n//               COMPUTATION OF BESSEL FUNCTIONS OF COMPLEX ARGUMENT\n//                 BY D. E. AMOS, SAND83-0083, MAY, 1983.\n//\n//               COMPUTATION OF BESSEL FUNCTIONS OF COMPLEX ARGUMENT\n//                 AND LARGE ORDER BY D. E. AMOS, SAND83-0643, MAY, 1983\n//\n//               A SUBROUTINE PACKAGE FOR BESSEL FUNCTIONS OF A COMPLEX\n//                 ARGUMENT AND NONNEGATIVE ORDER BY D. E. AMOS, SAND85-\n//                 1018, MAY, 1985\n//\n//               A PORTABLE PACKAGE FOR BESSEL FUNCTIONS OF A COMPLEX\n//                 ARGUMENT AND NONNEGATIVE ORDER BY D. E. AMOS, TRANS.\n//                 MATH. SOFTWARE, 1986\n//\n// **ROUTINES ED()  ZBINU,I1MACH,D1MACH\n// **END PROLOGUE  ZBESI\n//     COMPLEX CONE,CSGN,CW,CY,CZERO,Z,ZN\nfunction zbesi(zr, zi, fnu, kode, n, cyr, cyi) {\n  var aa = void 0,\n      alim = void 0,\n      arg = void 0,\n      conei = void 0,\n      coner = void 0,\n      csgni = void 0,\n      csgnr = void 0,\n      dig = void 0,\n      elim = void 0,\n      fnul = void 0,\n      pi = void 0,\n      rl = void 0,\n      r1m5 = void 0,\n      str = void 0,\n      tol = void 0,\n      zni = void 0,\n      znr = void 0,\n      az = void 0,\n      bb = void 0,\n      fn = void 0,\n      ascle = void 0,\n      rtol = void 0,\n      atol = void 0,\n      sti = void 0,\n      i = void 0,\n      inu = void 0,\n      k = void 0,\n      k1 = void 0,\n      k2 = void 0,\n      nn = void 0,\n      ierr = void 0,\n      nz = void 0;\n\n  var goToLabel = 0;\n  mainExecutionLoop: while (true) {\n    switch (goToLabel) {\n      case 0:\n        pi = 3.14159265358979324e0;\n        coner = 1.0e0;\n        conei = 0.0e0;\n\n        ierr = 0;\n        nz = 0;\n        if (fnu < 0.0e0) ierr = 1;\n        if (kode < 1 || kode > 2) ierr = 1;\n        if (n < 1) ierr = 1;\n        if (ierr !== 0) break mainExecutionLoop;\n        // -----------------------------------------------------------------------\n        //     set parameters related to machine constants.\n        //     tol is the approximate unit roundoff limited to 1.0e-18.\n        //     elim is the approximate exponential over- and underflow limit.\n        //     Math.exp(-elim) < Math.exp(-alim)=Math.exp(-elim)/tol    and\n        //     Math.exp(elim) > Math.exp(alim)=Math.exp(elim)*tol       are intervals near\n        //     underflow and overflow limits where scaled arithmetic is done.\n        //     rl is the lower boundary of the asymptotic expansion for large z.\n        //     dig = number of base 10 digits in tol = 10**(-dig).\n        //     fnul is the lower boundary of the asymptotic series for large fnu.\n        // -----------------------------------------------------------------------\n        tol = Math.max((0, _d1mach.d1mach)(4), 1.0e-18);\n        k1 = (0, _i1mach.i1mach)(15);\n        k2 = (0, _i1mach.i1mach)(16);\n        r1m5 = (0, _d1mach.d1mach)(5);\n        k = Math.min(Math.abs(k1), Math.abs(k2));\n        elim = 2.303e0 * (k * r1m5 - 3.0e0);\n        k1 = (0, _i1mach.i1mach)(14) - 1;\n        aa = r1m5 * k1;\n        dig = Math.min(aa, 18.0e0);\n        aa = aa * 2.303e0;\n        alim = elim + Math.max(-aa, -41.45e0);\n        rl = 1.2e0 * dig + 3.0e0;\n        fnul = 10.0e0 + 6.0e0 * (dig - 3.0e0);\n        // -----------------------------------------------------------------------------\n        //     test for proper range\n        // -----------------------------------------------------------------------\n        az = (0, _zabs.azabs)(zr, zi);\n        fn = fnu + (n - 1);\n        aa = 0.5e0 / tol;\n        bb = (0, _i1mach.i1mach)(9) * 0.5e0;\n        aa = Math.min(aa, bb);\n        if (az > aa) {\n          goToLabel = 260;break;\n        }\n        if (fn > aa) {\n          goToLabel = 260;break;\n        }\n        aa = Math.sqrt(aa);\n        if (az > aa) ierr = 3;\n        if (fn > aa) ierr = 3;\n        znr = zr;\n        zni = zi;\n        csgnr = coner;\n        csgni = conei;\n        if (zr >= 0.0e0) {\n          goToLabel = 40;break;\n        }\n        znr = -zr;\n        zni = -zi;\n        // -----------------------------------------------------------------------\n        //     calculate csgn=Math.exp(fnu*pi*i) to minimize losses of significance\n        //     when fnu is large\n        // -----------------------------------------------------------------------\n        inu = Math.trunc(fnu);\n        arg = (fnu - inu) * pi;\n        if (zi < 0.0e0) arg = -arg;\n        csgnr = Math.cos(arg);\n        csgni = Math.sin(arg);\n        if (inu % 2 === 0) {\n          goToLabel = 40;break;\n        }\n        csgnr = -csgnr;\n        csgni = -csgni;\n      case 40:\n\n        nz = (0, _zbinu.zbinu)(znr, zni, fnu, kode, n, cyr, cyi, rl, fnul, tol, elim, alim);\n        if (nz < 0) {\n          goToLabel = 120;break;\n        }\n        if (zr >= 0.0e0) break mainExecutionLoop;\n        // -----------------------------------------------------------------------\n        //     analytic continuation to the left half plane\n        // -----------------------------------------------------------------------\n        nn = n - nz;\n        if (nn === 0) break mainExecutionLoop;\n        rtol = 1.0e0 / tol;\n        ascle = (0, _d1mach.d1mach)(1) * rtol * 1.0e+3;\n        for (i = 1; i <= nn; i++) {\n          //       str = cyr(i)*csgnr - cyi(i)*csgni\n          //       cyi(i) = cyr(i)*csgni + cyi(i)*csgnr\n          //       cyr(i) = str\n          aa = cyr[i - 1];\n          bb = cyi[i - 1];\n          atol = 1.0e0;\n          if (Math.max(Math.abs(aa), Math.abs(bb)) > ascle) {\n            // goToLabel = 55; break;\n          } else {\n            aa = aa * rtol;\n            bb = bb * rtol;\n            atol = tol;\n          }\n          // case 55:\n          str = aa * csgnr - bb * csgni;\n          sti = aa * csgni + bb * csgnr;\n          cyr[i - 1] = str * atol;\n          cyi[i - 1] = sti * atol;\n          csgnr = -csgnr;\n          csgni = -csgni;\n        }\n        break mainExecutionLoop;\n      case 120:\n\n        if (nz === -2) {\n          goToLabel = 130;break;\n        }\n        nz = 0;\n        ierr = 2;\n        break mainExecutionLoop;\n      case 130:\n\n        nz = 0;\n        ierr = 5;\n        break mainExecutionLoop;\n      case 260:\n\n        nz = 0;\n        ierr = 4;\n\n      default:\n        break mainExecutionLoop;\n    }\n  }\n  return [nz, ierr];\n}\n},{\"../../utils/fortran-utils/d1mach.js\":91,\"../../utils/fortran-utils/i1mach.js\":92,\"./zabs.js\":11,\"./zbinu.js\":21}],18:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.zbesj = zbesj;\n\nvar _d1mach = require('../../utils/fortran-utils/d1mach.js');\n\nvar _i1mach = require('../../utils/fortran-utils/i1mach.js');\n\nvar _zbinu = require('./zbinu.js');\n\nfunction zbesj(zr, zi, fnu, kode, n, cyr, cyi) {\n  var aa = void 0,\n      alim = void 0,\n      arg = void 0,\n      cii = void 0,\n      csgni = void 0,\n      csgnr = void 0,\n      dig = void 0,\n      elim = void 0,\n      fnul = void 0,\n      hpi = void 0,\n      rl = void 0,\n      r1m5 = void 0,\n      str = void 0,\n      tol = void 0,\n      zni = void 0,\n      znr = void 0,\n      bb = void 0,\n      fn = void 0,\n      az = void 0,\n      ascle = void 0,\n      rtol = void 0,\n      atol = void 0,\n      sti = void 0,\n      i = void 0,\n      inu = void 0,\n      inuh = void 0,\n      ir = void 0,\n      k = void 0,\n      k1 = void 0,\n      k2 = void 0,\n      nl = void 0,\n      nz = void 0,\n      ierr = void 0;\n\n  var goToLabel = 0;\n  mainExecutionLoop: while (true) {\n    switch (goToLabel) {\n      case 0:\n        hpi = 1.57079632679489662e0;\n        ierr = 0;\n        nz = 0;\n        if (fnu < 0.0e0) ierr = 1;\n        if (kode < 1 || kode > 2) ierr = 1;\n        if (n < 1) ierr = 1;\n        if (ierr !== 0) break mainExecutionLoop;\n        // -----------------------------------------------------------------------\n        //     set parameters related to machine constants.\n        //     tol is the approximate unit roundoff limited to 1.0e-18.\n        //     elim is the approximate exponential over- and underflow limit.\n        //     Math.exp(-elim) < Math.exp(-alim)=Math.exp(-elim)/tol    and\n        //     Math.exp(elim) > Math.exp(alim)=Math.exp(elim)*tol       are intervals near\n        //     underflow and overflow limits where scaled arithmetic is done.\n        //     rl is the lower boundary of the asymptotic expansion for large z.\n        //     dig = number of base 10 digits in tol = 10**(-dig).\n        //     fnul is the lower boundary of the asymptotic series for large fnu.\n        // -----------------------------------------------------------------------\n        tol = Math.max((0, _d1mach.d1mach)(4), 1.0e-18);\n        k1 = (0, _i1mach.i1mach)(15);\n        k2 = (0, _i1mach.i1mach)(16);\n        r1m5 = (0, _d1mach.d1mach)(5);\n        k = Math.min(Math.abs(k1), Math.abs(k2));\n        elim = 2.303e0 * (k * r1m5 - 3.0e0);\n        k1 = (0, _i1mach.i1mach)(14) - 1;\n        aa = r1m5 * k1;\n        dig = Math.min(aa, 18.0e0);\n        aa = aa * 2.303e0;\n        alim = elim + Math.max(-aa, -41.45e0);\n        rl = 1.2e0 * dig + 3.0e0;\n        fnul = 10.0e0 + 6.0e0 * (dig - 3.0e0);\n        // -----------------------------------------------------------------------\n        //     test for proper range\n        // -----------------------------------------------------------------------\n        az = Math.abs(zr, zi);\n        fn = fnu + (n - 1);\n        aa = 0.5e0 / tol;\n        bb = (0, _i1mach.i1mach)(9) * 0.5e0;\n        aa = Math.min(aa, bb);\n        if (az > aa) {\n          goToLabel = 260;break;\n        }\n        if (fn > aa) {\n          goToLabel = 260;break;\n        }\n        aa = Math.sqrt(aa);\n        if (az > aa) ierr = 3;\n        if (fn > aa) ierr = 3;\n        // -----------------------------------------------------------------------\n        //     calculate csgn=Math.exp(fnu*hpi*i) to minimize losses of significance\n        //     when fnu is large\n        // -----------------------------------------------------------------------\n        cii = 1.0e0;\n        inu = Math.trunc(fnu);\n        inuh = Math.trunc(inu / 2);\n        ir = inu - 2 * inuh;\n        arg = (fnu - (inu - ir)) * hpi;\n        csgnr = Math.cos(arg);\n        csgni = Math.sin(arg);\n        if (inuh % 2 === 0) {\n          goToLabel = 40;break;\n        }\n        csgnr = -csgnr;\n        csgni = -csgni;\n      case 40:\n\n        // -----------------------------------------------------------------------\n        //     zn is in the right half plane\n        // -----------------------------------------------------------------------\n        znr = zi;\n        zni = -zr;\n        if (zi >= 0.0e0) {\n          goToLabel = 50;break;\n        }\n        znr = -znr;\n        zni = -zni;\n        csgni = -csgni;\n        cii = -cii;\n      case 50:\n\n        nz = (0, _zbinu.zbinu)(znr, zni, fnu, kode, n, cyr, cyi, rl, fnul, tol, elim, alim);\n        if (nz < 0) {\n          goToLabel = 130;break;\n        }\n        nl = n - nz;\n        if (nl === 0) break mainExecutionLoop;\n        rtol = 1.0e0 / tol;\n        ascle = (0, _d1mach.d1mach)(1) * rtol * 1.0e+3;\n        for (i = 1; i <= nl; i++) {\n          //       str = cyr(i)*csgnr - cyi(i)*csgni\n          //       cyi(i) = cyr(i)*csgni + cyi(i)*csgnr\n          //       cyr(i) = str\n          aa = cyr[i - 1];\n          bb = cyi[i - 1];\n          atol = 1.0e0;\n          if (Math.max(Math.abs(aa), Math.abs(bb)) > ascle) {\n            // goToLabel = 55; break;\n          } else {\n            aa = aa * rtol;\n            bb = bb * rtol;\n            atol = tol;\n          }\n          // case 55:\n\n          str = aa * csgnr - bb * csgni;\n          sti = aa * csgni + bb * csgnr;\n          cyr[i - 1] = str * atol;\n          cyi[i - 1] = sti * atol;\n          str = -csgni * cii;\n          csgni = csgnr * cii;\n          csgnr = str;\n        }\n        break mainExecutionLoop;\n      case 130:\n        if (nz === -2) {\n          goToLabel = 140;break;\n        }\n        nz = 0;\n        ierr = 2;\n        break mainExecutionLoop;\n      case 140:\n        nz = 0;\n        ierr = 5;\n        break mainExecutionLoop;\n      case 260:\n        nz = 0;\n        ierr = 4;\n      default:\n        break mainExecutionLoop;\n    }\n  }\n  return [nz, ierr];\n} /* eslint-disable no-labels */\n/* eslint-disable no-fallthrough */\n// **BEGIN PROLOGUE  ZBESJ\n// **DATE WRITTEN   830501   (YYMMDD)\n// **REVISION DATE  890801   (YYMMDD)\n// ***PORT TO ECMASCRIPT  201801   (YYYYMM)\n// **CATEGORY NO.  B5K\n// **KEYWORDS  J-BESSEL FUNCTION,BESSEL FUNCTION OF COMPLEX ARGUMENT,\n//            BESSEL FUNCTION OF FIRST KIND\n// **AUTHOR (FORTRAN) AMOS, DONALD E., SANDIA NATIONAL LABORATORIES\n// **AUTHOR (ECMASCRIPT) ERB, KC, KINGS DISTRIBUTED SYSTEMS\n// **PURPOSE  TO COMPUTE THE J-BESSEL FUNCTION OF A COMPLEX ARGUMENT\n// **DESCRIPTION\n//\n//                      ***A DOUBLE PRECISION ROUTINE***\n//         ON KODE=1, CBESJ COMPUTES AN N MEMBER  SEQUENCE OF COMPLEX\n//         BESSEL FUNCTIONS CY(I)=J(FNU+I-1,Z) FOR REAL, NONNEGATIVE\n//         ORDERS FNU+I-1, I=1,...,N AND COMPLEX Z IN THE CUT PLANE\n//         -PI < ARG(Z) <= PI. ON KODE=2, CBESJ RETURNS THE SCALED\n//         FUNCTIONS\n//\n//         CY(I)=MATH.EXP(-MATH.ABS(Y))*J(FNU+I-1,Z)   I = 1,...,N , Y=AIMAG(Z)\n//\n//         WHICH REMOVE THE EXPONENTIAL GROWTH IN BOTH THE UPPER AND\n//         LOWER HALF PLANES FOR Z TO INFINITY. DEFINITIONS AND NOTATION\n//         ARE FOUND IN THE NBS HANDBOOK OF MATHEMATICAL FUNCTIONS\n//         (REF. 1).\n//\n//         INPUT      ZR,ZI,FNU ARE DOUBLE PRECISION\n//           ZR,ZI  - Z=CMPLX(ZR,ZI),  -PI < ARG(Z) <= PI\n//           FNU    - ORDER OF INITIAL J FUNCTION, FNU >= 0.0E0\n//           KODE   - A PARAMETER TO INDICATE THE SCALING OPTION\n//                    KODE= 1  RETURNS\n//                             CY(I)=J(FNU+I-1,Z), I=1,...,N\n//                        = 2  RETURNS\n//                             CY(I)=J(FNU+I-1,Z)MATH.EXP(-MATH.ABS(Y)), I=1,...,N\n//           N      - NUMBER OF MEMBERS OF THE SEQUENCE, N >= 1\n//\n//         OUTPUT     CYR,CYI ARE DOUBLE PRECISION\n//           CYR,CYI- DOUBLE PRECISION VECTORS WHOSE FIRST N COMPONENTS\n//                    CONTAIN REAL AND IMAGINARY PARTS FOR THE SEQUENCE\n//                    CY(I)=J(FNU+I-1,Z)  OR\n//                    CY(I)=J(FNU+I-1,Z)MATH.EXP(-MATH.ABS(Y))  I=1,...,N\n//                    DEPENDING ON KODE, Y=AIMAG(Z).\n//           NZ     - NUMBER OF COMPONENTS SET TO ZERO DUE TO UNDERFLOW,\n//                    NZ= 0   , NORMAL RETURN\n//                    NZ > 0 , LAST NZ COMPONENTS OF CY SET  ZERO DUE\n//                              TO UNDERFLOW, CY(I)=CMPLX(0.0E0,0.0E0),\n//                              I = N-NZ+1,...,N\n//           IERR   - ERROR FLAG\n//                    IERR=0, NORMAL RETURN - COMPUTATION COMPLETED\n//                    IERR=1, INPUT ERROR   - NO COMPUTATION\n//                    IERR=2, OVERFLOW      - NO COMPUTATION, AIMAG(Z)\n//                            TOO LARGE ON KODE=1\n//                    IERR=3, CABS(Z) OR FNU+N-1 LARGE - COMPUTATION DONE\n//                            BUT LOSSES OF SIGNIFCANCE BY ARGUMENT\n//                            REDUCTION PRODUCE LESS THAN HALF OF MACHINE\n//                            ACCURACY\n//                    IERR=4, CABS(Z) OR FNU+N-1 TOO LARGE - NO COMPUTA-\n//                            TION BECAUSE OF COMPLETE LOSSES OF SIGNIFI-\n//                            CANCE BY ARGUMENT REDUCTION\n//                    IERR=5, ERROR              - NO COMPUTATION,\n//                            ALGORITHM TERMINATION CONDITION NOT MET\n//\n// **LONG DESCRIPTION\n//\n//         THE COMPUTATION IS CARRIED OUT BY THE FORMULA\n//\n//         J(FNU,Z)=MATH.EXP( FNU*PI*MATH.TRUNC(I/2))*I(FNU,-I*Z)    AIMAG(Z) >= 0.0\n//\n//         J(FNU,Z)=MATH.EXP(-FNU*PI*MATH.TRUNC(I/2))*I(FNU, I*Z)    AIMAG(Z) < 0.0\n//\n//         WHERE I**2 = -1 AND I(FNU,Z) IS THE I BESSEL FUNCTION.\n//\n//         FOR NEGATIVE ORDERS,THE FORMULA\n//\n//              J(-FNU,Z) = J(FNU,Z)*MATH.COS(PI*FNU) - Y(FNU,Z)*MATH.SIN(PI*FNU)\n//\n//         CAN BE USED. HOWEVER,FOR LARGE ORDERS CLOSE TO INTEGERS, THE\n//         THE FUNCTION CHANGES RADIY(). WHEN FNU IS A LARGE POSITIVE\n//         INTEGER,THE MAGNITUDE OF J(-FNU,Z)=J(FNU,Z)*MATH.COS(PI*FNU) IS A\n//         LARGE NEGATIVE POWER OF TEN. BUT WHEN FNU IS NOT AN INTEGER,\n//         Y(FNU,Z) DOMINATES IN MAGNITUDE WITH A LARGE POSITIVE POWER OF\n//         TEN AND THE MOST THAT THE SECOND TERM CAN BE REDUCED IS BY\n//         UNIT ROUNDOFF FROM THE COEFFICIENT. THUS, WIDE CHANGES CAN\n//         OCCUR WITHIN UNIT ROUNDOFF OF A LARGE INTEGER FOR FNU. HERE,\n//         LARGE MEANS FNU > CABS(Z).\n//\n//         IN MOST COMPLEX VARIABLE COMPUTATION, ONE MUST EVALUATE ELE-\n//         MENTARY FUNCTIONS. WHEN THE MAGNITUDE OF Z OR FNU+N-1 IS\n//         LARGE, LOSSES OF SIGNIFICANCE BY ARGUMENT REDUCTION OCCUR.\n//         CONSEQUENTLY, IF EITHER ONE EXCEEDS U1=MATH.SQRT(0.5/UR), {\n//         LOSSES EXCEEDING HALF PRECISION ARE LIKELY AND AN ERROR FLAG\n//         IERR=3 IS TRIGGERED WHERE UR=MATH.MAX(D1MACH(4),1.0E-18) IS\n//         DOUBLE PRECISION UNIT ROUNDOFF LIMITED TO 18 DIGITS PRECISION.\n//         IF EITHER IS LARGER THAN U2=0.5/UR, { ALL SIGNIFICANCE IS\n//         LOST AND IERR=4. IN ORDER TO USE THE INT FUNCTION, ARGUMENTS\n//         MUST BE FURTHER RESTRICTED NOT TO EXCEED THE LARGEST MACHINE\n//         INTEGER, U3=I1MACH(9). THUS, THE MAGNITUDE OF Z AND FNU+N-1 IS\n//         RESTRICTED BY MATH.MIN(U2,U3). ON 32 BIT MACHINES, U1,U2, AND U3\n//         ARE APPROXIMATELY 2.0E+3, 4.2E+6, 2.1E+9 IN SINGLE PRECISION\n//         ARITHMETIC AND 1.3E+8, 1.8E+16, 2.1E+9 IN DOUBLE PRECISION\n//         ARITHMETIC RESPECTIVELY. THIS MAKES U2 AND U3 LIMITING IN\n//         THEIR RESPECTIVE ARITHMETICS. THIS MEANS THAT ONE CAN EXPECT\n//         TO RETAIN, IN THE WORST CASES ON 32 BIT MACHINES, NO DIGITS\n//         IN SINGLE AND ONLY 7 DIGITS IN DOUBLE PRECISION ARITHMETIC.\n//         SIMILAR CONSIDERATIONS HOLD FOR OTHER MACHINES.\n//\n//         THE APPROXIMATE RELATIVE ERROR IN THE MAGNITUDE OF A COMPLEX\n//         BESSEL FUNCTION CAN BE EXPRESSED BY P*10**S WHERE P=MATH.MAX(UNIT\n//         ROUNDOFF,1.0E-18) IS THE NOMINAL PRECISION AND 10**S REPRE-\n//         SENTS THE INCREASE IN ERROR DUE TO ARGUMENT REDUCTION IN THE\n//         ELEMENTARY FUNCTIONS. HERE, S=MATH.MAX(1,MATH.ABS(MATH.LOG10(CABS(Z))),\n//         MATH.ABS(MATH.LOG10(FNU))) APPROXIMATELY (I.E. S=MATH.MAX(1,MATH.ABS(EXPONENT OF\n//         CABS(Z),ABS(EXPONENT OF FNU))) ). HOWEVER, THE PHASE ANGLE MAY\n//         HAVE ONLY ABSOLUTE ACCURACY. THIS IS MOST LIKELY TO OCCUR WHEN\n//         ONE COMPONENT (IN ABSOLUTE VALUE) IS LARGER THAN THE OTHER BY\n//         SEVERAL ORDERS OF MAGNITUDE. IF ONE COMPONENT IS 10**K LARGER\n//         THAN THE OTHER, { ONE CAN EXPECT ONLY MATH.MAX(MATH.ABS(MATH.LOG10(P))-K,\n//         0) SIGNIFICANT DIGITS; OR, STATED ANOTHER WAY, WHEN K EXCEEDS\n//         THE EXPONENT OF P, NO SIGNIFICANT DIGITS REMAIN IN THE SMALLER\n//         COMPONENT. HOWEVER, THE PHASE ANGLE RETAINS ABSOLUTE ACCURACY\n//         BECAUSE, IN COMPLEX ARITHMETIC WITH PRECISION P, THE SMALLER\n//         COMPONENT WILL NOT (AS A RULE) DECREASE BELOW P TIMES THE\n//         MAGNITUDE OF THE LARGER COMPONENT. IN THESE EXTREME CASES,\n//         THE PRINCIPAL PHASE ANGLE IS ON THE ORDER OF +P, -P, PMATH.TRUNC(I/2)-P,\n//         OR -PMATH.TRUNC(I/2)+P.\n//\n// **REFERENCES  HANDBOOK OF MATHEMATICAL FUNCTIONS BY M. ABRAMOWITZ\n//                 AND I. A. STEGUN, NBS AMS SERIES 55, U.S. DEPT. OF\n//                 COMMERCE, 1955.\n//\n//               COMPUTATION OF BESSEL FUNCTIONS OF COMPLEX ARGUMENT\n//                 BY D. E. AMOS, SAND83-0083, MAY, 1983.\n//\n//               COMPUTATION OF BESSEL FUNCTIONS OF COMPLEX ARGUMENT\n//                 AND LARGE ORDER BY D. E. AMOS, SAND83-0643, MAY, 1983\n//\n//               A SUBROUTINE PACKAGE FOR BESSEL FUNCTIONS OF A COMPLEX\n//                 ARGUMENT AND NONNEGATIVE ORDER BY D. E. AMOS, SAND85-\n//                 1018, MAY, 1985\n//\n//               A PORTABLE PACKAGE FOR BESSEL FUNCTIONS OF A COMPLEX\n//                 ARGUMENT AND NONNEGATIVE ORDER BY D. E. AMOS, TRANS.\n//                 MATH. SOFTWARE, 1986\n//\n// **ROUTINES ED()  ZBINU,I1MACH,D1MACH\n// **END PROLOGUE  ZBESJ\n//\n//     COMPLEX CI,CSGN,CY,Z,ZN\n},{\"../../utils/fortran-utils/d1mach.js\":91,\"../../utils/fortran-utils/i1mach.js\":92,\"./zbinu.js\":21}],19:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.zbesk = zbesk;\n\nvar _d1mach = require('../../utils/fortran-utils/d1mach.js');\n\nvar _i1mach = require('../../utils/fortran-utils/i1mach.js');\n\nvar _zabs = require('./zabs.js');\n\nvar _zuoik = require('./zuoik.js');\n\nvar _zbknu = require('./zbknu.js');\n\nvar _zacon = require('./zacon.js');\n\nvar _zbunk = require('./zbunk.js');\n\nfunction zbesk(zr, zi, fnu, kode, n, cyr, cyi) {\n  var aa = void 0,\n      alim = void 0,\n      aln = void 0,\n      arg = void 0,\n      az = void 0,\n      dig = void 0,\n      elim = void 0,\n      fn = void 0,\n      fnul = void 0,\n      rl = void 0,\n      r1m5 = void 0,\n      tol = void 0,\n      ufl = void 0,\n      bb = void 0,\n      ierr = void 0,\n      k = void 0,\n      k1 = void 0,\n      k2 = void 0,\n      mr = void 0,\n      nn = void 0,\n      nuf = void 0,\n      nw = void 0,\n      nz = void 0;\n\n  var goToLabel = 0;\n  mainExecutionLoop: while (true) {\n    switch (goToLabel) {\n      case 0:\n        ierr = 0;\n        nz = 0;\n        if (zi === 0 && zr === 0) ierr = 1;\n        if (fnu < 0.0) ierr = 1;\n        if (kode < 1 || kode > 2) ierr = 1;\n        if (n < 1) ierr = 1;\n        if (ierr !== 0) break mainExecutionLoop;\n        nn = n;\n        // c-----------------------------------------------------------------------\n        // c     set parameters related to machine constants.\n        // c     tol is the approximate unit roundoff limited to 1.0e-18.\n        // c     elim is the approximate exponential over- and underflow limit.\n        // c     exp(-elim) < exp(-alim)=exp(-elim)/tol    and\n        // c     exp(elim) > exp(alim)=exp(elim)*tol       are intervals near\n        // c     underflow and overflow limits where scaled arithmetic is done.\n        // c     rl is the lower boundary of the asymptotic expansion for large z.\n        // c     dig = number of base 10 digits in tol = 10**(-dig).\n        // c     fnul is the lower boundary of the asymptotic series for large fnu\n        // c-----------------------------------------------------------------------\n        tol = Math.max((0, _d1mach.d1mach)(4), 1.0e-18);\n        k1 = (0, _i1mach.i1mach)(15);\n        k2 = (0, _i1mach.i1mach)(16);\n        r1m5 = (0, _d1mach.d1mach)(5);\n        k = Math.min(Math.abs(k1), Math.abs(k2));\n        elim = 2.303 * k * r1m5 - 3.0;\n        k1 = (0, _i1mach.i1mach)(14) - 1;\n        aa = r1m5 * k1;\n        dig = Math.min(aa, 18.0);\n        aa = aa * 2.303;\n        alim = elim + Math.max(-aa, -41.45);\n        fnul = 10.0 + 6.0 * (dig - 3.0);\n        rl = 1.2 * dig + 3.0;\n        // c-----------------------------------------------------------------------------\n        // c     test for proper range\n        // c-----------------------------------------------------------------------\n        az = (0, _zabs.azabs)(zr, zi);\n        fn = fnu + (nn - 1);\n        aa = 0.5 / tol;\n        bb = (0, _i1mach.i1mach)(9) * 0.5;\n        aa = Math.min(aa, bb);\n        if (az > aa) {\n          goToLabel = 260;break;\n        }\n        if (fn > aa) {\n          goToLabel = 260;break;\n        }\n        aa = Math.sqrt(aa);\n        if (az > aa) ierr = 3;\n        if (fn > aa) ierr = 3;\n        // c-----------------------------------------------------------------------\n        // c     overflow test on the last member of the sequence\n        // c-----------------------------------------------------------------------\n        // c ufl = Math.exp(-elim)\n        ufl = (0, _d1mach.d1mach)(1) * 1.0e+3;\n        if (az < ufl) {\n          goToLabel = 180;break;\n        }\n        if (fnu > fnul) {\n          goToLabel = 80;break;\n        }\n        if (fn <= 1.0) {\n          goToLabel = 60;break;\n        }\n        if (fn > 2.0) {\n          goToLabel = 50;break;\n        }\n        if (az > tol) {\n          goToLabel = 60;break;\n        }\n        arg = 0.5 * az;\n        aln = -fn * Math.log(arg);\n        if (aln > elim) {\n          goToLabel = 180;break;\n        }\n        goToLabel = 60;break;\n      case 50:\n        nuf = (0, _zuoik.zuoik)(zr, zi, fnu, kode, 2, nn, cyr, cyi, tol, elim, alim);\n        if (nuf < 0) {\n          goToLabel = 180;break;\n        }\n        nz = nz + nuf;\n        nn = nn - nuf;\n        // c-----------------------------------------------------------------------\n        // c     here nn=n or nn=0 since nuf=0,nn, or -1 on return from cuoik\n        // c     if nuf=nn, then cy(i)=czero for all i\n        // c-----------------------------------------------------------------------\n        if (nn === 0) {\n          goToLabel = 100;break;\n        }\n      case 60:\n        if (zr < 0.0) {\n          goToLabel = 70;break;\n        }\n        // c-----------------------------------------------------------------------\n        // c     right half plane computation, real(z) >= 0.\n        // c-----------------------------------------------------------------------\n        nw = (0, _zbknu.zbknu)(zr, zi, fnu, kode, nn, cyr, cyi, tol, elim, alim);\n        if (nw < 0) {\n          goToLabel = 200;break;\n        }\n        nz = nw;\n        break mainExecutionLoop;\n      // c-----------------------------------------------------------------------\n      // c     left half plane computation\n      // c     pi/2 < arg(z) <= pi and -pi < arg(z) < -pi/2.\n      // c-----------------------------------------------------------------------\n      case 70:\n        if (nz !== 0) {\n          goToLabel = 180;break;\n        }\n        mr = 1;\n        if (zi < 0.0) mr = -1;\n        nw = (0, _zacon.zacon)(zr, zi, fnu, kode, mr, nn, cyr, cyi, rl, fnul, tol, elim, alim);\n        if (nw < 0) {\n          goToLabel = 200;break;\n        }\n        nz = nw;\n        break mainExecutionLoop;\n      // c-----------------------------------------------------------------------\n      // c     uniform asymptotic expansions for fnu > fnul\n      // c-----------------------------------------------------------------------\n      case 80:\n        mr = 0;\n        if (zr >= 0.0) {\n          goToLabel = 90;break;\n        }\n        mr = 1;\n        if (zi < 0.0) mr = -1;\n      case 90:\n        nw = (0, _zbunk.zbunk)(zr, zi, fnu, kode, mr, nn, cyr, cyi, tol, elim, alim);\n        if (nw < 0) {\n          goToLabel = 200;break;\n        }\n        nz = nz + nw;\n        break mainExecutionLoop;\n      case 100:\n        if (zr < 0.0) {\n          goToLabel = 180;break;\n        }\n        break mainExecutionLoop;\n      case 180:\n        nz = 0;\n        ierr = 2;\n        break mainExecutionLoop;\n      case 200:\n        if (nw === -1) {\n          goToLabel = 180;break;\n        }\n        nz = 0;\n        ierr = 5;\n        break mainExecutionLoop;\n      case 260:\n        nz = 0;\n        ierr = 4;\n      default:\n        break mainExecutionLoop;\n    }\n  }\n\n  return [nz, ierr];\n} /* eslint-disable no-labels */\n/* eslint-disable no-fallthrough */\n// SUBROUTINE ZBESK(ZR, ZI, FNU, KODE, N, CYR, CYI, NZ, IERR)\n// ***BEGIN PROLOGUE  ZBESK\n// ***DATE WRITTEN   830501   (YYMMDD)\n// ***REVISION DATE  890801   (YYMMDD)\n// ***PORT TO ECMASCRIPT  201801   (YYYYMM)\n// ***CATEGORY NO.  B5K\n// ***KEYWORDS  K-BESSEL FUNCTION,COMPLEX BESSEL FUNCTION,\n//              MODIFIED BESSEL FUNCTION OF THE SECOND KIND,\n//              BESSEL FUNCTION OF THE THIRD KIND\n// ***AUTHOR (FORTRAN) AMOS, DONALD E., SANDIA NATIONAL LABORATORIES\n// **AUTHOR (ECMASCRIPT) ERB, KC, KINGS DISTRIBUTED SYSTEMS\n// ***PURPOSE  TO COMPUTE K-BESSEL FUNCTIONS OF COMPLEX ARGUMENT\n// ***DESCRIPTION\n//\n//                       ***A DOUBLE PRECISION ROUTINE***\n//\n//          ON KODE=1, CBESK COMPUTES AN N MEMBER SEQUENCE OF COMPLEX\n//          BESSEL FUNCTIONS CY(J)=K(FNU+J-1,Z) FOR REAL, NONNEGATIVE\n//          ORDERS FNU+J-1, J=1,...,N AND COMPLEX Z.NE.CMPLX(0.0,0.0)\n//          IN THE CUT PLANE -PI.LT.ARG(Z).LE.PI. ON KODE=2, CBESK\n//          RETURNS THE SCALED K FUNCTIONS,\n//\n//          CY(J)=EXP(Z)*K(FNU+J-1,Z) , J=1,...,N,\n//\n//          WHICH REMOVE THE EXPONENTIAL BEHAVIOR IN BOTH THE LEFT AND\n//          RIGHT HALF PLANES FOR Z TO INFINITY. DEFINITIONS AND\n//          NOTATION ARE FOUND IN THE NBS HANDBOOK OF MATHEMATICAL\n//          FUNCTIONS (REF. 1).\n//\n//          INPUT      ZR,ZI,FNU ARE DOUBLE PRECISION\n//            ZR,ZI  - Z=CMPLX(ZR,ZI), Z.NE.CMPLX(0.0D0,0.0D0),\n//                     -PI.LT.ARG(Z).LE.PI\n//            FNU    - ORDER OF INITIAL K FUNCTION, FNU.GE.0.0D0\n//            N      - NUMBER OF MEMBERS OF THE SEQUENCE, N.GE.1\n//            KODE   - A PARAMETER TO INDICATE THE SCALING OPTION\n//                     KODE= 1  RETURNS\n//                              CY(I)=K(FNU+I-1,Z), I=1,...,N\n//                         = 2  RETURNS\n//                              CY(I)=K(FNU+I-1,Z)*EXP(Z), I=1,...,N\n//\n//          OUTPUT     CYR,CYI ARE DOUBLE PRECISION\n//            CYR,CYI- DOUBLE PRECISION VECTORS WHOSE FIRST N COMPONENTS\n//                     CONTAIN REAL AND IMAGINARY PARTS FOR THE SEQUENCE\n//                     CY(I)=K(FNU+I-1,Z), I=1,...,N OR\n//                     CY(I)=K(FNU+I-1,Z)*EXP(Z), I=1,...,N\n//                     DEPENDING ON KODE\n//            NZ     - NUMBER OF COMPONENTS SET TO ZERO DUE TO UNDERFLOW.\n//                     NZ= 0   , NORMAL RETURN\n//                     NZ.GT.0 , FIRST NZ COMPONENTS OF CY SET TO ZERO DUE\n//                               TO UNDERFLOW, CY(I)=CMPLX(0.0D0,0.0D0),\n//                               I=1,...,N WHEN X.GE.0.0. WHEN X.LT.0.0\n//                               NZ STATES ONLY THE NUMBER OF UNDERFLOWS\n//                               IN THE SEQUENCE.\n//\n//            IERR   - ERROR FLAG\n//                     IERR=0, NORMAL RETURN - COMPUTATION COMPLETED\n//                     IERR=1, INPUT ERROR   - NO COMPUTATION\n//                     IERR=2, OVERFLOW      - NO COMPUTATION, FNU IS\n//                             TOO LARGE OR CABS(Z) IS TOO SMALL OR BOTH\n//                     IERR=3, CABS(Z) OR FNU+N-1 LARGE - COMPUTATION DONE\n//                             BUT LOSSES OF SIGNIFCANCE BY ARGUMENT\n//                             REDUCTION PRODUCE LESS THAN HALF OF MACHINE\n//                             ACCURACY\n//                     IERR=4, CABS(Z) OR FNU+N-1 TOO LARGE - NO COMPUTA-\n//                             TION BECAUSE OF COMPLETE LOSSES OF SIGNIFI-\n//                             CANCE BY ARGUMENT REDUCTION\n//                     IERR=5, ERROR              - NO COMPUTATION,\n//                             ALGORITHM TERMINATION CONDITION NOT MET\n//\n// ***LONG DESCRIPTION\n//\n//          EQUATIONS OF THE REFERENCE ARE IMPLEMENTED FOR SMALL ORDERS\n//          DNU AND DNU+1.0 IN THE RIGHT HALF PLANE X.GE.0.0. FORWARD\n//          RECURRENCE GENERATES HIGHER ORDERS. K IS CONTINUED TO THE LEFT\n//          HALF PLANE BY THE RELATION\n//\n//          K(FNU,Z*EXP(MP)) = EXP(-MP*FNU)*K(FNU,Z)-MP*I(FNU,Z)\n//          MP=MR*PI*I, MR=+1 OR -1, RE(Z).GT.0, I**2=-1\n//\n//          WHERE I(FNU,Z) IS THE I BESSEL FUNCTION.\n//\n//          FOR LARGE ORDERS, FNU.GT.FNUL, THE K FUNCTION IS COMPUTED\n//          BY MEANS OF ITS UNIFORM ASYMPTOTIC EXPANSIONS.\n//\n//          FOR NEGATIVE ORDERS, THE FORMULA\n//\n//                        K(-FNU,Z) = K(FNU,Z)\n//\n//          CAN BE USED.\n//\n//          CBESK ASSUMES THAT A SIGNIFICANT DIGIT SINH(X) FUNCTION IS\n//          AVAILABLE.\n//\n//          IN MOST COMPLEX VARIABLE COMPUTATION, ONE MUST EVALUATE ELE-\n//          MENTARY FUNCTIONS. WHEN THE MAGNITUDE OF Z OR FNU+N-1 IS\n//          LARGE, LOSSES OF SIGNIFICANCE BY ARGUMENT REDUCTION OCCUR.\n//          CONSEQUENTLY, IF EITHER ONE EXCEEDS U1=SQRT(0.5/UR), THEN\n//          LOSSES EXCEEDING HALF PRECISION ARE LIKELY AND AN ERROR FLAG\n//          IERR=3 IS TRIGGERED WHERE UR=DMAX1(D1MACH(4),1.0D-18) IS\n//          DOUBLE PRECISION UNIT ROUNDOFF LIMITED TO 18 DIGITS PRECISION.\n//          IF EITHER IS LARGER THAN U2=0.5/UR, THEN ALL SIGNIFICANCE IS\n//          LOST AND IERR=4. IN ORDER TO USE THE INT FUNCTION, ARGUMENTS\n//          MUST BE FURTHER RESTRICTED NOT TO EXCEED THE LARGEST MACHINE\n//          INTEGER, U3=I1MACH(9). THUS, THE MAGNITUDE OF Z AND FNU+N-1 IS\n//          RESTRICTED BY MIN(U2,U3). ON 32 BIT MACHINES, U1,U2, AND U3\n//          ARE APPROXIMATELY 2.0E+3, 4.2E+6, 2.1E+9 IN SINGLE PRECISION\n//          ARITHMETIC AND 1.3E+8, 1.8E+16, 2.1E+9 IN DOUBLE PRECISION\n//          ARITHMETIC RESPECTIVELY. THIS MAKES U2 AND U3 LIMITING IN\n//          THEIR RESPECTIVE ARITHMETICS. THIS MEANS THAT ONE CAN EXPECT\n//          TO RETAIN, IN THE WORST CASES ON 32 BIT MACHINES, NO DIGITS\n//          IN SINGLE AND ONLY 7 DIGITS IN DOUBLE PRECISION ARITHMETIC.\n//          SIMILAR CONSIDERATIONS HOLD FOR OTHER MACHINES.\n//\n//          THE APPROXIMATE RELATIVE ERROR IN THE MAGNITUDE OF A COMPLEX\n//          BESSEL FUNCTION CAN BE EXPRESSED BY P*10**S WHERE P=MAX(UNIT\n//          ROUNDOFF,1.0E-18) IS THE NOMINAL PRECISION AND 10**S REPRE-\n//          SENTS THE INCREASE IN ERROR DUE TO ARGUMENT REDUCTION IN THE\n//          ELEMENTARY FUNCTIONS. HERE, S=MAX(1,ABS(LOG10(CABS(Z))),\n//          ABS(LOG10(FNU))) APPROXIMATELY (I.E. S=MAX(1,ABS(EXPONENT OF\n//          CABS(Z),ABS(EXPONENT OF FNU)) ). HOWEVER, THE PHASE ANGLE MAY\n//          HAVE ONLY ABSOLUTE ACCURACY. THIS IS MOST LIKELY TO OCCUR WHEN\n//          ONE COMPONENT (IN ABSOLUTE VALUE) IS LARGER THAN THE OTHER BY\n//          SEVERAL ORDERS OF MAGNITUDE. IF ONE COMPONENT IS 10**K LARGER\n//          THAN THE OTHER, THEN ONE CAN EXPECT ONLY MAX(ABS(LOG10(P))-K,\n//          0) SIGNIFICANT DIGITS; OR, STATED ANOTHER WAY, WHEN K EXCEEDS\n//          THE EXPONENT OF P, NO SIGNIFICANT DIGITS REMAIN IN THE SMALLER\n//          COMPONENT. HOWEVER, THE PHASE ANGLE RETAINS ABSOLUTE ACCURACY\n//          BECAUSE, IN COMPLEX ARITHMETIC WITH PRECISION P, THE SMALLER\n//          COMPONENT WILL NOT (AS A RULE) DECREASE BELOW P TIMES THE\n//          MAGNITUDE OF THE LARGER COMPONENT. IN THESE EXTREME CASES,\n//          THE PRINCIPAL PHASE ANGLE IS ON THE ORDER OF +P, -P, PI/2-P,\n//          OR -PI/2+P.\n//\n// ***REFERENCES  HANDBOOK OF MATHEMATICAL FUNCTIONS BY M. ABRAMOWITZ\n//                  AND I. A. STEGUN, NBS AMS SERIES 55, U.S. DEPT. OF\n//                  COMMERCE, 1955.\n//\n//                COMPUTATION OF BESSEL FUNCTIONS OF COMPLEX ARGUMENT\n//                  BY D. E. AMOS, SAND83-0083, MAY, 1983.\n//\n//                COMPUTATION OF BESSEL FUNCTIONS OF COMPLEX ARGUMENT\n//                  AND LARGE ORDER BY D. E. AMOS, SAND83-0643, MAY, 1983.\n//\n//                A SUBROUTINE PACKAGE FOR BESSEL FUNCTIONS OF A COMPLEX\n//                  ARGUMENT AND NONNEGATIVE ORDER BY D. E. AMOS, SAND85-\n//                  1018, MAY, 1985\n//\n//                A PORTABLE PACKAGE FOR BESSEL FUNCTIONS OF A COMPLEX\n//                  ARGUMENT AND NONNEGATIVE ORDER BY D. E. AMOS, TRANS.\n//                  MATH. SOFTWARE, 1986\n//\n// ***ROUTINES CALLED  ZACON,ZBKNU,ZBUNK,ZUOIK,AZABS,I1MACH,D1MACH\n// ***END PROLOGUE  ZBESK\n//\n//      COMPLEX CY,Z\n},{\"../../utils/fortran-utils/d1mach.js\":91,\"../../utils/fortran-utils/i1mach.js\":92,\"./zabs.js\":11,\"./zacon.js\":13,\"./zbknu.js\":23,\"./zbunk.js\":25,\"./zuoik.js\":44}],20:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); /* eslint-disable no-labels */\n/* eslint-disable no-fallthrough */\n// **BEGIN PROLOGUE  ZBESY\n// **DATE WRITTEN   830501   (YYMMDD)\n// **REVISION DATE  890801   (YYMMDD)\n// ***PORT TO ECMASCRIPT  201801   (YYYYMM)\n// **CATEGORY NO.  B5K\n// **KEYWORDS  Y-BESSEL FUNCTION,BESSEL FUNCTION OF COMPLEX ARGUMENT,\n//            BESSEL FUNCTION OF SECOND KIND\n// **AUTHOR (FORTRAN) AMOS, DONALD E., SANDIA NATIONAL LABORATORIES\n// **AUTHOR (ECMASCRIPT) ERB, KC, KINGS DISTRIBUTED SYSTEMS\n// **PURPOSE  TO COMPUTE THE Y-BESSEL FUNCTION OF A COMPLEX ARGUMENT\n// **DESCRIPTION\n//\n//                      ***A DOUBLE PRECISION ROUTINE***\n//\n//         ON KODE=1, CBESY COMPUTES AN N MEMBER SEQUENCE OF COMPLEX\n//         BESSEL FUNCTIONS CY(I)=Y(FNU+I-1,Z) FOR REAL, NONNEGATIVE\n//         ORDERS FNU+I-1, I=1,...,N AND COMPLEX Z IN THE CUT PLANE\n//         -PI < ARG(Z) <= PI. ON KODE=2, CBESY RETURNS THE SCALED\n//         FUNCTIONS\n//\n//         CY(I)=MATH.EXP(-MATH.ABS(Y))*Y(FNU+I-1,Z)   I = 1,...,N , Y=AIMAG(Z)\n//\n//         WHICH REMOVE THE EXPONENTIAL GROWTH IN BOTH THE UPPER AND\n//         LOWER HALF PLANES FOR Z TO INFINITY. DEFINITIONS AND NOTATION\n//         ARE FOUND IN THE NBS HANDBOOK OF MATHEMATICAL FUNCTIONS\n//         (REF. 1).\n//\n//         INPUT      ZR,ZI,FNU ARE DOUBLE PRECISION\n//           ZR,ZI  - Z=CMPLX(ZR,ZI), Z !== CMPLX(0.0E0,0.0E0),\n//                    -PI < ARG(Z) <= PI\n//           FNU    - ORDER OF INITIAL Y FUNCTION, FNU >= 0.0E0\n//           KODE   - A PARAMETER TO INDICATE THE SCALING OPTION\n//                    KODE= 1  RETURNS\n//                             CY(I)=Y(FNU+I-1,Z), I=1,...,N\n//                        = 2  RETURNS\n//                             CY(I)=Y(FNU+I-1,Z)*MATH.EXP(-MATH.ABS(Y)), I=1,...,N\n//                             WHERE Y=AIMAG(Z)\n//           N      - NUMBER OF MEMBERS OF THE SEQUENCE, N >= 1\n//           CWRKR, - DOUBLE PRECISION WORK VECTORS OF DIMENSION AT\n//           CWRKI    AT LEAST N\n//\n//         OUTPUT     CYR,CYI ARE DOUBLE PRECISION\n//           CYR,CYI- DOUBLE PRECISION VECTORS WHOSE FIRST N COMPONENTS\n//                    CONTAIN REAL AND IMAGINARY PARTS FOR THE SEQUENCE\n//                    CY(I)=Y(FNU+I-1,Z)  OR\n//                    CY(I)=Y(FNU+I-1,Z)*MATH.EXP(-MATH.ABS(Y))  I=1,...,N\n//                    DEPENDING ON KODE.\n//           NZ     - NZ=0 , A NORMAL RETURN\n//                    NZ > 0 , NZ COMPONENTS OF CY SET TO ZERO DUE TO\n//                    UNDERFLOW (GENERALLY ON KODE=2)\n//           IERR   - ERROR FLAG\n//                    IERR=0, NORMAL RETURN - COMPUTATION COMPLETED\n//                    IERR=1, INPUT ERROR   - NO COMPUTATION\n//                    IERR=2, OVERFLOW      - NO COMPUTATION, FNU IS\n//                            TOO LARGE OR CABS(Z) IS TOO SMALL OR BOTH\n//                    IERR=3, CABS(Z) OR FNU+N-1 LARGE - COMPUTATION DONE\n//                            BUT LOSSES OF SIGNIFCANCE BY ARGUMENT\n//                            REDUCTION PRODUCE LESS THAN HALF OF MACHINE\n//                            ACCURACY\n//                    IERR=4, CABS(Z) OR FNU+N-1 TOO LARGE - NO COMPUTA-\n//                            TION BECAUSE OF COMPLETE LOSSES OF SIGNIFI-\n//                            CANCE BY ARGUMENT REDUCTION\n//                    IERR=5, ERROR              - NO COMPUTATION,\n//                            ALGORITHM TERMINATION CONDITION NOT MET\n//\n// **LONG DESCRIPTION\n//\n//         THE COMPUTATION IS CARRIED OUT BY THE FORMULA\n//\n//         Y(FNU,Z)=0.5*(H(1,FNU,Z)-H(2,FNU,Z))/I\n//\n//         WHERE I**2 = -1 AND THE HANKEL BESSEL FUNCTIONS H(1,FNU,Z)\n//         AND H(2,FNU,Z) ARE CALCULATED IN CBESH.\n//\n//         FOR NEGATIVE ORDERS,THE FORMULA\n//\n//              Y(-FNU,Z) = Y(FNU,Z)*MATH.COS(PI*FNU) + J(FNU,Z)*MATH.SIN(PI*FNU)\n//\n//         CAN BE USED. HOWEVER,FOR LARGE ORDERS CLOSE TO HALF ODD\n//         INTEGERS THE FUNCTION CHANGES RADIY(). WHEN FNU IS A LARGE\n//         POSITIVE HALF ODD INTEGER,THE MAGNITUDE OF Y(-FNU,Z)=J(FNU,Z)*\n//         MATH.SIN(PI*FNU) IS A LARGE NEGATIVE POWER OF TEN. BUT WHEN FNU IS\n//         NOT A HALF ODD INTEGER, Y(FNU,Z) DOMINATES IN MAGNITUDE WITH A\n//         LARGE POSITIVE POWER OF TEN AND THE MOST THAT THE SECOND TERM\n//         CAN BE REDUCED IS BY UNIT ROUNDOFF FROM THE COEFFICIENT. THUS,\n//         WIDE CHANGES CAN OCCUR WITHIN UNIT ROUNDOFF OF A LARGE HALF\n//         ODD INTEGER. HERE, LARGE MEANS FNU > CABS(Z).\n//\n//         IN MOST COMPLEX VARIABLE COMPUTATION, ONE MUST EVALUATE ELE-\n//         MENTARY FUNCTIONS. WHEN THE MAGNITUDE OF Z OR FNU+N-1 IS\n//         LARGE, LOSSES OF SIGNIFICANCE BY ARGUMENT REDUCTION OCCUR.\n//         CONSEQUENTLY, IF EITHER ONE EXCEEDS U1=MATH.SQRT(0.5/UR), {\n//         LOSSES EXCEEDING HALF PRECISION ARE LIKELY AND AN ERROR FLAG\n//         IERR=3 IS TRIGGERED WHERE UR=MATH.MAX(D1MACH(4),1.0E-18) IS\n//         DOUBLE PRECISION UNIT ROUNDOFF LIMITED TO 18 DIGITS PRECISION.\n//         IF EITHER IS LARGER THAN U2=0.5/UR, { ALL SIGNIFICANCE IS\n//         LOST AND IERR=4. IN ORDER TO USE THE INT FUNCTION, ARGUMENTS\n//         MUST BE FURTHER RESTRICTED NOT TO EXCEED THE LARGEST MACHINE\n//         INTEGER, U3=I1MACH(9). THUS, THE MAGNITUDE OF Z AND FNU+N-1 IS\n//         RESTRICTED BY MATH.MIN(U2,U3). ON 32 BIT MACHINES, U1,U2, AND U3\n//         ARE APPROXIMATELY 2.0E+3, 4.2E+6, 2.1E+9 IN SINGLE PRECISION\n//         ARITHMETIC AND 1.3E+8, 1.8E+16, 2.1E+9 IN DOUBLE PRECISION\n//         ARITHMETIC RESPECTIVELY. THIS MAKES U2 AND U3 LIMITING IN\n//         THEIR RESPECTIVE ARITHMETICS. THIS MEANS THAT ONE CAN EXPECT\n//         TO RETAIN, IN THE WORST CASES ON 32 BIT MACHINES, NO DIGITS\n//         IN SINGLE AND ONLY 7 DIGITS IN DOUBLE PRECISION ARITHMETIC.\n//         SIMILAR CONSIDERATIONS HOLD FOR OTHER MACHINES.\n//\n//         THE APPROXIMATE RELATIVE ERROR IN THE MAGNITUDE OF A COMPLEX\n//         BESSEL FUNCTION CAN BE EXPRESSED BY P*10**S WHERE P=MATH.MAX(UNIT\n//         ROUNDOFF,1.0E-18) IS THE NOMINAL PRECISION AND 10**S REPRE-\n//         SENTS THE INCREASE IN ERROR DUE TO ARGUMENT REDUCTION IN THE\n//         ELEMENTARY FUNCTIONS. HERE, S=MATH.MAX(1,MATH.ABS(MATH.LOG10(CABS(Z))),\n//         MATH.ABS(MATH.LOG10(FNU))) APPROXIMATELY (I.E. S=MATH.MAX(1,MATH.ABS(EXPONENT OF\n//         CABS(Z),ABS(EXPONENT OF FNU)) )). HOWEVER, THE PHASE ANGLE MAY\n//         HAVE ONLY ABSOLUTE ACCURACY. THIS IS MOST LIKELY TO OCCUR WHEN\n//         ONE COMPONENT (IN ABSOLUTE VALUE) IS LARGER THAN THE OTHER BY\n//         SEVERAL ORDERS OF MAGNITUDE. IF ONE COMPONENT IS 10**K LARGER\n//         THAN THE OTHER, { ONE CAN EXPECT ONLY MATH.MAX(MATH.ABS(MATH.LOG10(P))-K,\n//         0) SIGNIFICANT DIGITS; OR, STATED ANOTHER WAY, WHEN K EXCEEDS\n//         THE EXPONENT OF P, NO SIGNIFICANT DIGITS REMAIN IN THE SMALLER\n//         COMPONENT. HOWEVER, THE PHASE ANGLE RETAINS ABSOLUTE ACCURACY\n//         BECAUSE, IN COMPLEX ARITHMETIC WITH PRECISION P, THE SMALLER\n//         COMPONENT WILL NOT (AS A RULE) DECREASE BELOW P TIMES THE\n//         MAGNITUDE OF THE LARGER COMPONENT. IN THESE EXTREME CASES,\n//         THE PRINCIPAL PHASE ANGLE IS ON THE ORDER OF +P, -P, PMATH.TRUNC(I/2)-P,\n//         OR -PMATH.TRUNC(I/2)+P.\n//\n// **REFERENCES  HANDBOOK OF MATHEMATICAL FUNCTIONS BY M. ABRAMOWITZ\n//                 AND I. A. STEGUN, NBS AMS SERIES 55, U.S. DEPT. OF\n//                 COMMERCE, 1955.\n//\n//               COMPUTATION OF BESSEL FUNCTIONS OF COMPLEX ARGUMENT\n//                 BY D. E. AMOS, SAND83-0083, MAY, 1983.\n//\n//               COMPUTATION OF BESSEL FUNCTIONS OF COMPLEX ARGUMENT\n//                 AND LARGE ORDER BY D. E. AMOS, SAND83-0643, MAY, 1983\n//\n//               A SUBROUTINE PACKAGE FOR BESSEL FUNCTIONS OF A COMPLEX\n//                 ARGUMENT AND NONNEGATIVE ORDER BY D. E. AMOS, SAND85-\n//                 1018, MAY, 1985\n//\n//               A PORTABLE PACKAGE FOR BESSEL FUNCTIONS OF A COMPLEX\n//                 ARGUMENT AND NONNEGATIVE ORDER BY D. E. AMOS, TRANS.\n//                 MATH. SOFTWARE, 1986\n//\n// **ROUTINES CALLED  ZBESH,I1MACH,D1MACH\n// **END PROLOGUE  ZBESY\n//\n//     COMPLEX CWRK,CY,C1,C2,EX,HCI,Z,ZU,ZV\n\n\nexports.zbesy = zbesy;\n\nvar _d1mach = require('../../utils/fortran-utils/d1mach.js');\n\nvar _i1mach = require('../../utils/fortran-utils/i1mach.js');\n\nvar _zbesh5 = require('./zbesh.js');\n\nfunction zbesy(zr, zi, fnu, kode, n, cyr, cyi) {\n  var c1i = void 0,\n      c1r = void 0,\n      c2i = void 0,\n      c2r = void 0,\n      elim = void 0,\n      exi = void 0,\n      exr = void 0,\n      ey = void 0,\n      hcii = void 0,\n      sti = void 0,\n      str = void 0,\n      tay = void 0,\n      ascle = void 0,\n      rtol = void 0,\n      atol = void 0,\n      aa = void 0,\n      bb = void 0,\n      tol = void 0,\n      i = void 0,\n      k = void 0,\n      k1 = void 0,\n      k2 = void 0,\n      nz1 = void 0,\n      nz2 = void 0,\n      cwrkr = void 0,\n      cwrki = void 0,\n      ierr = void 0,\n      nz = void 0,\n      r1m5 = void 0;\n\n  cwrkr = new Array(n);\n  cwrki = new Array(n);\n\n  var goToLabel = 0;\n  mainExecutionLoop: while (true) {\n    switch (goToLabel) {\n      case 0:\n        ierr = 0;\n        nz = 0;\n        if (zr === 0.0e0 && zi === 0.0e0) ierr = 1;\n        if (fnu < 0.0e0) ierr = 1;\n        if (kode < 1 || kode > 2) ierr = 1;\n        if (n < 1) ierr = 1;\n        if (ierr !== 0) break mainExecutionLoop;\n        hcii = 0.5e0;\n\n        var _zbesh = (0, _zbesh5.zbesh)(zr, zi, fnu, kode, 1, n, cyr, cyi);\n\n        var _zbesh2 = _slicedToArray(_zbesh, 2);\n\n        nz1 = _zbesh2[0];\n        ierr = _zbesh2[1];\n\n        if (ierr !== 0 && ierr !== 3) {\n          goToLabel = 170;break;\n        }\n\n        var _zbesh3 = (0, _zbesh5.zbesh)(zr, zi, fnu, kode, 2, n, cwrkr, cwrki);\n\n        var _zbesh4 = _slicedToArray(_zbesh3, 2);\n\n        nz2 = _zbesh4[0];\n        ierr = _zbesh4[1];\n\n        if (ierr !== 0 && ierr !== 3) {\n          goToLabel = 170;break;\n        }\n        nz = Math.min(nz1, nz2);\n        if (kode === 2) {\n          goToLabel = 60;break;\n        }\n        for (i = 1; i <= n; i++) {\n          str = cwrkr[i - 1] - cyr[i - 1];\n          sti = cwrki[i - 1] - cyi[i - 1];\n          cyr[i - 1] = -sti * hcii;\n          cyi[i - 1] = str * hcii;\n        }\n        break mainExecutionLoop;\n      case 60:\n\n        tol = Math.max((0, _d1mach.d1mach)(4), 1.0e-18);\n        k1 = (0, _i1mach.i1mach)(15);\n        k2 = (0, _i1mach.i1mach)(16);\n        k = Math.min(Math.abs(k1), Math.abs(k2));\n        r1m5 = (0, _d1mach.d1mach)(5);\n        // -----------------------------------------------------------------------\n        //     elim is the approximate exponential under- and overflow limit\n        // -----------------------------------------------------------------------\n        elim = 2.303e0 * (k * r1m5 - 3.0e0);\n        exr = Math.cos(zr);\n        exi = Math.sin(zr);\n        ey = 0.0e0;\n        tay = Math.abs(zi + zi);\n        if (tay < elim) ey = Math.exp(-tay);\n        if (zi < 0.0e0) {\n          goToLabel = 90;break;\n        }\n        c1r = exr * ey;\n        c1i = exi * ey;\n        c2r = exr;\n        c2i = -exi;\n      case 70:\n\n        nz = 0;\n        rtol = 1.0e0 / tol;\n        ascle = (0, _d1mach.d1mach)(1) * rtol * 1.0e+3;\n        for (i = 1; i <= n; i++) {\n          //       str = c1r*cyr(i) - c1i*cyi(i)\n          //       sti = c1r*cyi(i) + c1i*cyr(i)\n          //       str = -str + c2r*cwrkr(i) - c2i*cwrki(i)\n          //       sti = -sti + c2r*cwrki(i) + c2i*cwrkr(i)\n          //       cyr(i) = -sti*hcii\n          //       cyi(i) = str*hcii\n          aa = cwrkr[i - 1];\n          bb = cwrki[i - 1];\n          atol = 1.0e0;\n          if (Math.max(Math.abs(aa), Math.abs(bb)) > ascle) {\n            // goToLabel = 75; break;\n          } else {\n            aa = aa * rtol;\n            bb = bb * rtol;\n            atol = tol;\n          }\n          // case 75:\n\n          str = (aa * c2r - bb * c2i) * atol;\n          sti = (aa * c2i + bb * c2r) * atol;\n          aa = cyr[i - 1];\n          bb = cyi[i - 1];\n          atol = 1.0e0;\n          if (Math.max(Math.abs(aa), Math.abs(bb)) > ascle) {\n            // goToLabel = 85; break;\n          } else {\n            aa = aa * rtol;\n            bb = bb * rtol;\n            atol = tol;\n          }\n          // case 85:\n\n          str = str - (aa * c1r - bb * c1i) * atol;\n          sti = sti - (aa * c1i + bb * c1r) * atol;\n          cyr[i - 1] = -sti * hcii;\n          cyi[i - 1] = str * hcii;\n          if (str === 0.0e0 && sti === 0.0e0 && ey === 0.0e0) {\n            nz = nz + 1;\n          }\n        }\n        break mainExecutionLoop;\n      case 90:\n\n        c1r = exr;\n        c1i = exi;\n        c2r = exr * ey;\n        c2i = -exi * ey;\n        goToLabel = 70;break;\n      case 170:\n\n        nz = 0;\n      default:\n        break mainExecutionLoop;\n    }\n  }\n  return [nz, ierr];\n}\n},{\"../../utils/fortran-utils/d1mach.js\":91,\"../../utils/fortran-utils/i1mach.js\":92,\"./zbesh.js\":16}],21:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); /* eslint-disable no-labels */\n/* eslint-disable no-fallthrough */\n// SUBROUTINE ZBINU(ZR, ZI, FNU, KODE, N, CYR, CYI, NZ, RL, FNUL,\n// * TOL, ELIM, ALIM)\n// ***BEGIN PROLOGUE  ZBINU\n// ***REFER TO  ZBESH,ZBESI,ZBESJ,ZBESK,ZAIRY,ZBIRY\n//\n//      ZBINU COMPUTES THE I FUNCTION IN THE RIGHT HALF Z PLANE\n//\n// ***ROUTINES CALLED  AZABS,ZASYI,ZBUNI,ZMLRI,ZSERI,ZUOIK,ZWRSK\n// ***END PROLOGUE  ZBINU\n\n\nexports.zbinu = zbinu;\n\nvar _zabs = require('./zabs.js');\n\nvar _zasyi = require('./zasyi.js');\n\nvar _zbuni3 = require('./zbuni.js');\n\nvar _zmlri = require('./zmlri.js');\n\nvar _zseri = require('./zseri.js');\n\nvar _zuoik = require('./zuoik.js');\n\nvar _zwrsk = require('./zwrsk.js');\n\nfunction zbinu(zr, zi, fnu, kode, n, cyr, cyi, rl, fnul, tol, elim, alim) {\n  var az = void 0,\n      cwi = void 0,\n      cwr = void 0,\n      dfnu = void 0,\n      zeroi = void 0,\n      zeror = void 0,\n      i = void 0,\n      inw = void 0,\n      nlast = void 0,\n      nn = void 0,\n      nui = void 0,\n      nw = void 0,\n      nz = void 0;\n  cwr = new Array(2);\n  cwi = new Array(2);\n  zeror = 0;\n  zeroi = 0;\n\n\n  var goToLabel = 0;\n  mainExecutionLoop: while (true) {\n    switch (goToLabel) {\n      case 0:\n        nz = 0;\n        az = (0, _zabs.azabs)(zr, zi);\n        nn = n;\n        dfnu = fnu + (n - 1);\n        if (az <= 2.0) {\n          goToLabel = 10;break;\n        }\n        if (az * az * 0.25 > dfnu + 1.0) {\n          goToLabel = 20;break;\n        }\n      case 10:\n        // c-----------------------------------------------------------------------\n        // c     power series\n        // c-----------------------------------------------------------------------\n        nw = (0, _zseri.zseri)(zr, zi, fnu, kode, nn, cyr, cyi, tol, elim, alim);\n        inw = Math.abs(nw);\n        nz = nz + inw;\n        nn = nn - inw;\n        if (nn === 0) break mainExecutionLoop;\n        if (nw >= 0) {\n          goToLabel = 120;break;\n        }\n        dfnu = fnu + (nn - 1);\n      case 20:\n        if (az < rl) {\n          goToLabel = 40;break;\n        }\n        if (dfnu <= 1.0) {\n          goToLabel = 30;break;\n        }\n        if (az + az < dfnu * dfnu) {\n          goToLabel = 50;break;\n        }\n      // c-----------------------------------------------------------------------\n      // c     asymptotic expansion for large z\n      // c-----------------------------------------------------------------------\n      case 30:\n        nw = (0, _zasyi.zasyi)(zr, zi, fnu, kode, nn, cyr, cyi, rl, tol, elim, alim);\n        if (nw < 0) {\n          goToLabel = 130;break;\n        }\n        goToLabel = 120;break;\n      case 40:\n        if (dfnu <= 1.0) {\n          goToLabel = 70;break;\n        }\n      case 50:\n        // c-----------------------------------------------------------------------\n        // c     overflow and underflow test on i sequence for miller algorithm\n        // c-----------------------------------------------------------------------\n        nw = (0, _zuoik.zuoik)(zr, zi, fnu, kode, 1, nn, cyr, cyi, tol, elim, alim);\n        if (nw < 0) {\n          goToLabel = 130;break;\n        }\n        nz = nz + nw;\n        nn = nn - nw;\n        if (nn === 0) break mainExecutionLoop;\n        dfnu = fnu + (nn - 1);\n        if (dfnu > fnul) {\n          goToLabel = 110;break;\n        }\n        if (az > fnul) {\n          goToLabel = 110;break;\n        }\n      case 60:\n        if (az > rl) {\n          goToLabel = 80;break;\n        }\n      case 70:\n        // c-----------------------------------------------------------------------\n        // c     miller algorithm normalized by the series\n        // c-----------------------------------------------------------------------\n        nw = (0, _zmlri.zmlri)(zr, zi, fnu, kode, nn, cyr, cyi, tol);\n        if (nw < 0) {\n          goToLabel = 130;break;\n        }\n        goToLabel = 120;break;\n      case 80:\n        // c-----------------------------------------------------------------------\n        // c     miller algorithm normalized by the wronskian\n        // c-----------------------------------------------------------------------\n        // c-----------------------------------------------------------------------\n        // c     overflow test on k functions used in wronskian\n        // c-----------------------------------------------------------------------\n        nw = (0, _zuoik.zuoik)(zr, zi, fnu, kode, 2, 2, cwr, cwi, tol, elim, alim);\n        if (nw >= 0) {\n          goToLabel = 100;break;\n        }\n        nz = nn;\n        // do 90 i=1,nn\n        for (i = 1; i <= nn; i++) {\n          cyr[i - 1] = zeror;\n          cyi[i - 1] = zeroi;\n        }\n        // 90 continue\n        break mainExecutionLoop;\n      case 100:\n        if (nw > 0) {\n          goToLabel = 130;break;\n        }\n        nw = (0, _zwrsk.zwrsk)(zr, zi, fnu, kode, nn, cyr, cyi, cwr, cwi, tol, elim, alim);\n        if (nw < 0) {\n          goToLabel = 130;break;\n        }\n        goToLabel = 120;break;\n      case 110:\n        // c-----------------------------------------------------------------------\n        // c     increment fnu+nn-1 up to fnul, compute and recur backward\n        // c-----------------------------------------------------------------------\n        nui = Math.trunc(fnul - dfnu) + 1;\n        nui = Math.max(nui, 0);\n\n        var _zbuni = (0, _zbuni3.zbuni)(zr, zi, fnu, kode, nn, cyr, cyi, nui, nlast, fnul, tol, elim, alim);\n\n        var _zbuni2 = _slicedToArray(_zbuni, 2);\n\n        nw = _zbuni2[0];\n        nlast = _zbuni2[1];\n\n        if (nw < 0) {\n          goToLabel = 130;break;\n        }\n        nz = nz + nw;\n        if (nlast === 0) {\n          goToLabel = 120;break;\n        }\n        nn = nlast;\n        goToLabel = 60;break;\n      case 120:\n        break mainExecutionLoop;\n      case 130:\n        nz = -1;\n        if (nw === -2) nz = -2;\n      default:\n        break mainExecutionLoop;\n    }\n  }\n  return nz;\n}\n},{\"./zabs.js\":11,\"./zasyi.js\":15,\"./zbuni.js\":24,\"./zmlri.js\":30,\"./zseri.js\":34,\"./zuoik.js\":44,\"./zwrsk.js\":45}],22:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); /* eslint-disable no-labels */\n/* eslint-disable no-fallthrough */\n// **BEGIN PROLOGUE  ZBIRY\n// **DATE WRITTEN   830501   (YYMMDD)\n// **REVISION DATE  890801   (YYMMDD)\n// ***PORT TO ECMASCRIPT  201801   (YYYYMM)\n// **CATEGORY NO.  B5K\n// **KEYWORDS  AIRY FUNCTION, BESSEL FUNCTIONS OF ORDER ONE THIRD\n// **AUTHOR (FORTRAN)  AMOS, DONALD E., SANDIA NATIONAL LABORATORIES\n// **AUTHOR (ECMASCRIPT) ERB, KC, KINGS DISTRIBUTED SYSTEMS\n// **PURPOSE  TO COMPUTE AIRY FUNCTIONS BI(Z) AND DBI(Z) FOR COMPLEX Z\n// **DESCRIPTION\n//\n//                      ***A DOUBLE PRECISION ROUTINE***\n//         ON KODE=1, CBIRY COMPUTES THE COMPLEX AIRY FUNCTION BI(Z) OR\n//         ITS DERIVATIVE DBI(Z)/DZ ON ID=0 OR ID=1 RESPECTIVELY. ON\n//         KODE=2, A SCALING OPTION CEXP(-AXZTA)*BI(Z) OR CEXP(-AXZTA)*\n//         DBI(Z)/DZ IS PROVIDED TO REMOVE THE EXPONENTIAL BEHAVIOR IN\n//         BOTH THE LEFT AND RIGHT HALF PLANES WHERE\n//         ZTA=(MATH.TRUNC(2/3))*Z*CSQRT(Z)=CMPLX(XZTA,YZTA) AND AXZTA=MATH.ABS(XZTA).\n//         DEFINITIONS AND NOTATION ARE FOUND IN THE NBS HANDBOOK OF\n//         MATHEMATICAL FUNCTIONS (REF. 1).\n//\n//         INPUT      ZR,ZI ARE DOUBLE PRECISION\n//           ZR,ZI  - Z=CMPLX(ZR,ZI)\n//           ID     - ORDER OF DERIVATIVE, ID=0 OR ID=1\n//           KODE   - A PARAMETER TO INDICATE THE SCALING OPTION\n//                    KODE= 1  RETURNS\n//                             BI=BI(Z)                 ON ID=0 OR\n//                             BI=DBI(Z)/DZ             ON ID=1\n//                        = 2  RETURNS\n//                             BI=CEXP(-AXZTA)*BI(Z)     ON ID=0 OR\n//                             BI=CEXP(-AXZTA)*DBI(Z)/DZ ON ID=1 WHERE\n//                             ZTA=(MATH.TRUNC(2/3))*Z*CSQRT(Z)=CMPLX(XZTA,YZTA)\n//                             AND AXZTA=MATH.ABS(XZTA)\n//\n//         OUTPUT     BIR,BII ARE DOUBLE PRECISION\n//           BIR,BII- COMPLEX ANSWER DEPENDING ON THE CHOICES FOR ID AND\n//                    KODE\n//           IERR   - ERROR FLAG\n//                    IERR=0, NORMAL RETURN - COMPUTATION COMPLETED\n//                    IERR=1, INPUT ERROR   - NO COMPUTATION\n//                    IERR=2, OVERFLOW      - NO COMPUTATION, REAL(Z)\n//                            TOO LARGE ON KODE=1\n//                    IERR=3, CABS(Z) LARGE      - COMPUTATION COMPLETED\n//                            LOSSES OF SIGNIFCANCE BY ARGUMENT REDUCTION\n//                            PRODUCE LESS THAN HALF OF MACHINE ACCURACY\n//                    IERR=4, CABS(Z) TOO LARGE  - NO COMPUTATION\n//                            COMPLETE LOSS OF ACCURACY BY ARGUMENT\n//                            REDUCTION\n//                    IERR=5, ERROR              - NO COMPUTATION,\n//                            ALGORITHM TERMINATION CONDITION NOT MET\n//\n// **LONG DESCRIPTION\n//\n//         BI AND DBI ARE COMPUTED FOR CABS(Z) > 1.0 FROM THE I BESSEL\n//         FUNCTIONS BY\n//\n//                BI(Z)=C*MATH.SQRT(Z)*( I(-MATH.TRUNC(1/3),ZTA) + I(MATH.TRUNC(1/3),ZTA) )\n//               DBI(Z)=C *  Z  * ( I(-MATH.TRUNC(2/3),ZTA) + I(MATH.TRUNC(2/3),ZTA) )\n//                               C=1.0/MATH.SQRT(3.0)\n//                             ZTA=(MATH.TRUNC(2/3))*Z**(MATH.TRUNC(3/2))\n//\n//         WITH THE POWER SERIES FOR CABS(Z) <= 1.0.\n//\n//         IN MOST COMPLEX VARIABLE COMPUTATION, ONE MUST EVALUATE ELE-\n//         MENTARY FUNCTIONS. WHEN THE MAGNITUDE OF Z IS LARGE, LOSSES\n//         OF SIGNIFICANCE BY ARGUMENT REDUCTION OCCUR. CONSEQUENTLY, IF\n//         THE MAGNITUDE OF ZETA=(MATH.TRUNC(2/3))*Z**1.5 EXCEEDS U1=MATH.SQRT(0.5/UR),\n//         { LOSSES EXCEEDING HALF PRECISION ARE LIKELY AND AN ERROR\n//         FLAG IERR=3 IS TRIGGERED WHERE UR=MATH.MAX(D1MACH(4),1.0E-18) IS\n//         DOUBLE PRECISION UNIT ROUNDOFF LIMITED TO 18 DIGITS PRECISION.\n//         ALSO, IF THE MAGNITUDE OF ZETA IS LARGER THAN U2=0.5/UR, {\n//         ALL SIGNIFICANCE IS LOST AND IERR=4. IN ORDER TO USE THE INT\n//         FUNCTION, ZETA MUST BE FURTHER RESTRICTED NOT TO EXCEED THE\n//         LARGEST INTEGER, U3=I1MACH(9). THUS, THE MAGNITUDE OF ZETA\n//         MUST BE RESTRICTED BY MATH.MIN(U2,U3). ON 32 BIT MACHINES, U1,U2,\n//         AND U3 ARE APPROXIMATELY 2.0E+3, 4.2E+6, 2.1E+9 IN SINGLE\n//         PRECISION ARITHMETIC AND 1.3E+8, 1.8E+16, 2.1E+9 IN DOUBLE\n//         PRECISION ARITHMETIC RESPECTIVELY. THIS MAKES U2 AND U3 LIMIT-\n//         ING IN THEIR RESPECTIVE ARITHMETICS. THIS MEANS THAT THE MAG-\n//         NITUDE OF Z CANNOT EXCEED 3.1E+4 IN SINGLE AND 2.1E+6 IN\n//         DOUBLE PRECISION ARITHMETIC. THIS ALSO MEANS THAT ONE CAN\n//         EXPECT TO RETAIN, IN THE WORST CASES ON 32 BIT MACHINES,\n//         NO DIGITS IN SINGLE PRECISION AND ONLY 7 DIGITS IN DOUBLE\n//         PRECISION ARITHMETIC. SIMILAR CONSIDERATIONS HOLD FOR OTHER\n//         MACHINES.\n//\n//         THE APPROXIMATE RELATIVE ERROR IN THE MAGNITUDE OF A COMPLEX\n//         BESSEL FUNCTION CAN BE EXPRESSED BY P*10**S WHERE P=MATH.MAX(UNIT\n//         ROUNDOFF,1.0E-18) IS THE NOMINAL PRECISION AND 10**S REPRE-\n//         SENTS THE INCREASE IN ERROR DUE TO ARGUMENT REDUCTION IN THE\n//         ELEMENTARY FUNCTIONS. HERE, S=MATH.MAX(1,MATH.ABS(MATH.LOG10(CABS(Z))),\n//         MATH.ABS(MATH.LOG10(FNU))) APPROXIMATELY (I.E. S=MATH.MAX(1,MATH.ABS(EXPONENT OF\n//         CABS(Z),ABS(EXPONENT OF FNU))) ). HOWEVER, THE PHASE ANGLE MAY\n//         HAVE ONLY ABSOLUTE ACCURACY. THIS IS MOST LIKELY TO OCCUR WHEN\n//         ONE COMPONENT (IN ABSOLUTE VALUE) IS LARGER THAN THE OTHER BY\n//         SEVERAL ORDERS OF MAGNITUDE. IF ONE COMPONENT IS 10**K LARGER\n//         THAN THE OTHER, { ONE CAN EXPECT ONLY MATH.MAX(MATH.ABS(MATH.LOG10(P))-K,\n//         0) SIGNIFICANT DIGITS; OR, STATED ANOTHER WAY, WHEN K EXCEEDS\n//         THE EXPONENT OF P, NO SIGNIFICANT DIGITS REMAIN IN THE SMALLER\n//         COMPONENT. HOWEVER, THE PHASE ANGLE RETAINS ABSOLUTE ACCURACY\n//         BECAUSE, IN COMPLEX ARITHMETIC WITH PRECISION P, THE SMALLER\n//         COMPONENT WILL NOT (AS A RULE) DECREASE BELOW P TIMES THE\n//         MAGNITUDE OF THE LARGER COMPONENT. IN THESE EXTREME CASES,\n//         THE PRINCIPAL PHASE ANGLE IS ON THE ORDER OF +P, -P, PI/2-P,\n//         OR -PI/2+P.\n//\n// **REFERENCES  HANDBOOK OF MATHEMATICAL FUNCTIONS BY M. ABRAMOWITZ\n//                 AND I. A. STEGUN, NBS AMS SERIES 55, U.S. DEPT. OF\n//                 COMMERCE, 1955.\n//\n//               COMPUTATION OF BESSEL FUNCTIONS OF COMPLEX ARGUMENT\n//                 AND LARGE ORDER BY D. E. AMOS, SAND83-0643, MAY, 1983\n//\n//               A SUBROUTINE PACKAGE FOR BESSEL FUNCTIONS OF A COMPLEX\n//                 ARGUMENT AND NONNEGATIVE ORDER BY D. E. AMOS, SAND85-\n//                 1018, MAY, 1985\n//\n//               A PORTABLE PACKAGE FOR BESSEL FUNCTIONS OF A COMPLEX\n//                 ARGUMENT AND NONNEGATIVE ORDER BY D. E. AMOS, TRANS.\n//                 MATH. SOFTWARE, 1986\n//\n// **ROUTINES ED()  ZBINU,AZABS,ZDIV,AZSQRT,D1MACH,I1MACH\n// **END PROLOGUE  ZBIRY\n//     COMPLEX BI,CONE,CSQ,CY,S1,S2,TRM1,TRM2,Z,ZTA,Z3\n\n\nexports.zbiry = zbiry;\n\nvar _i1mach = require('../../utils/fortran-utils/i1mach.js');\n\nvar _d1mach = require('../../utils/fortran-utils/d1mach.js');\n\nvar _zbinu = require('./zbinu.js');\n\nvar _zdiv3 = require('./zdiv.js');\n\nvar _zsqrt = require('./zsqrt.js');\n\nvar _zabs = require('./zabs.js');\n\nfunction zbiry(zr, zi, id, kode) {\n  var aa = void 0,\n      ad = void 0,\n      ak = void 0,\n      alim = void 0,\n      atrm = void 0,\n      az = void 0,\n      az3 = void 0,\n      bb = void 0,\n      bk = void 0,\n      bii = void 0,\n      bir = void 0,\n      cc = void 0,\n      ck = void 0,\n      coef = void 0,\n      conei = void 0,\n      coner = void 0,\n      csqi = void 0,\n      csqr = void 0,\n      cyi = void 0,\n      cyr = void 0,\n      c1 = void 0,\n      c2 = void 0,\n      dig = void 0,\n      dk = void 0,\n      d1 = void 0,\n      d2 = void 0,\n      eaa = void 0,\n      elim = void 0,\n      fid = void 0,\n      fmr = void 0,\n      fnu = void 0,\n      fnul = void 0,\n      pi = void 0,\n      rl = void 0,\n      r1m5 = void 0,\n      sfac = void 0,\n      sti = void 0,\n      str = void 0,\n      s1i = void 0,\n      s1r = void 0,\n      s2i = void 0,\n      s2r = void 0,\n      tol = void 0,\n      trm1i = void 0,\n      trm1r = void 0,\n      trm2i = void 0,\n      trm2r = void 0,\n      tth = void 0,\n      ztai = void 0,\n      ztar = void 0,\n      z3i = void 0,\n      z3r = void 0,\n      k = void 0,\n      k1 = void 0,\n      k2 = void 0,\n      nz = void 0,\n      ierr = void 0;\n\n  cyr = new Float64Array(2);\n  cyi = new Float64Array(2);\n  var goToLabel = 0;\n  mainExecutionLoop: while (true) {\n    switch (goToLabel) {\n      case 0:\n        tth = 6.66666666666666667e-01;\n        c1 = 6.14926627446000736e-01;\n        c2 = 4.48288357353826359e-01;\n        coef = 5.77350269189625765e-01;\n        pi = 3.14159265358979324e+00;\n\n        //* **first executable statement  zbiry\n        coner = 1.0e0;\n        conei = 0.0e0;\n        ierr = 0;\n        nz = 0;\n        if (id < 0 || id > 1) ierr = 1;\n        if (kode < 1 || kode > 2) ierr = 1;\n        if (ierr !== 0) return;\n        az = (0, _zabs.azabs)(zr, zi);\n        tol = Math.max((0, _d1mach.d1mach)(4), 1.0e-18);\n        fid = id;\n        if (az > 1.0e0) {\n          goToLabel = 70;break;\n        }\n        // -----------------------------------------------------------------------\n        //     power series for cabs(z) <= 1.\n        // -----------------------------------------------------------------------\n        s1r = coner;\n        s1i = conei;\n        s2r = coner;\n        s2i = conei;\n        if (az < tol) {\n          goToLabel = 130;break;\n        }\n        aa = az * az;\n        if (aa < tol / az) {\n          goToLabel = 40;break;\n        }\n        trm1r = coner;\n        trm1i = conei;\n        trm2r = coner;\n        trm2i = conei;\n        atrm = 1.0e0;\n        str = zr * zr - zi * zi;\n        sti = zr * zi + zi * zr;\n        z3r = str * zr - sti * zi;\n        z3i = str * zi + sti * zr;\n        az3 = az * aa;\n        ak = 2.0e0 + fid;\n        bk = 3.0e0 - fid - fid;\n        ck = 4.0e0 - fid;\n        dk = 3.0e0 + fid + fid;\n        d1 = ak * dk;\n        d2 = bk * ck;\n        ad = Math.min(d1, d2);\n        ak = 24.0e0 + 9.0e0 * fid;\n        bk = 30.0e0 - 9.0e0 * fid;\n        for (k = 1; k <= 25; k++) {\n          str = (trm1r * z3r - trm1i * z3i) / d1;\n          trm1i = (trm1r * z3i + trm1i * z3r) / d1;\n          trm1r = str;\n          s1r = s1r + trm1r;\n          s1i = s1i + trm1i;\n          str = (trm2r * z3r - trm2i * z3i) / d2;\n          trm2i = (trm2r * z3i + trm2i * z3r) / d2;\n          trm2r = str;\n          s2r = s2r + trm2r;\n          s2i = s2i + trm2i;\n          atrm = atrm * az3 / ad;\n          d1 = d1 + ak;\n          d2 = d2 + bk;\n          ad = Math.min(d1, d2);\n          if (atrm < tol * ad) break;\n          ak = ak + 18.0e0;\n          bk = bk + 18.0e0;\n        }\n      case 40:\n\n        if (id === 1) {\n          goToLabel = 50;break;\n        }\n        bir = c1 * s1r + c2 * (zr * s2r - zi * s2i);\n        bii = c1 * s1i + c2 * (zr * s2i + zi * s2r);\n        if (kode === 1) break mainExecutionLoop;\n\n        var _azsqrt = (0, _zsqrt.azsqrt)(zr, zi);\n\n        var _azsqrt2 = _slicedToArray(_azsqrt, 2);\n\n        str = _azsqrt2[0];\n        sti = _azsqrt2[1];\n\n        ztar = tth * (zr * str - zi * sti);\n        ztai = tth * (zr * sti + zi * str);\n        aa = ztar;\n        aa = -Math.abs(aa);\n        eaa = Math.exp(aa);\n        bir = bir * eaa;\n        bii = bii * eaa;\n        return;\n      case 50:\n\n        bir = s2r * c2;\n        bii = s2i * c2;\n        if (az <= tol) {\n          goToLabel = 60;break;\n        }\n        cc = c1 / (1.0e0 + fid);\n        str = s1r * zr - s1i * zi;\n        sti = s1r * zi + s1i * zr;\n        bir = bir + cc * (str * zr - sti * zi);\n        bii = bii + cc * (str * zi + sti * zr);\n      case 60:\n\n        if (kode === 1) return;\n\n        var _azsqrt3 = (0, _zsqrt.azsqrt)(zr, zi);\n\n        var _azsqrt4 = _slicedToArray(_azsqrt3, 2);\n\n        str = _azsqrt4[0];\n        sti = _azsqrt4[1];\n\n        ztar = tth * (zr * str - zi * sti);\n        ztai = tth * (zr * sti + zi * str);\n        aa = ztar;\n        aa = -Math.abs(aa);\n        eaa = Math.exp(aa);\n        bir = bir * eaa;\n        bii = bii * eaa;\n        return;\n      // -----------------------------------------------------------------------\n      //     case for cabs(z) > 1.0\n      // -----------------------------------------------------------------------\n      case 70:\n\n        fnu = (1.0e0 + fid) / 3.0e0;\n        // -----------------------------------------------------------------------\n        //     set parameters related to machine constants.\n        //     tol is the approximate unit roundoff limited to 1.0e-18.\n        //     elim is the approximate exponential over- and underflow limit.\n        //     Math.exp(-elim) < Math.exp(-alim)=Math.exp(-elim)/tol    and\n        //     Math.exp(elim) > Math.exp(alim)=Math.exp(elim)*tol       are intervals near\n        //     underflow and overflow limits where scaled arithmetic is done.\n        //     rl is the lower boundary of the asymptotic expansion for large z.\n        //     dig = number of base 10 digits in tol = 10**(-dig).\n        //     fnul is the lower boundary of the asymptotic series for large fnu.\n        // -----------------------------------------------------------------------\n        k1 = (0, _i1mach.i1mach)(15);\n        k2 = (0, _i1mach.i1mach)(16);\n        r1m5 = (0, _d1mach.d1mach)(5);\n        k = Math.min(Math.abs(k1), Math.abs(k2));\n        elim = 2.303e0 * (k * r1m5 - 3.0e0);\n        k1 = (0, _i1mach.i1mach)(14) - 1;\n        aa = r1m5 * k1;\n        dig = Math.min(aa, 18.0e0);\n        aa = aa * 2.303e0;\n        alim = elim + Math.max(-aa, -41.45e0);\n        rl = 1.2e0 * dig + 3.0e0;\n        fnul = 10.0e0 + 6.0e0 * (dig - 3.0e0);\n        // -----------------------------------------------------------------------\n        //     test for range\n        // -----------------------------------------------------------------------\n        aa = 0.5e0 / tol;\n        bb = (0, _i1mach.i1mach)(9) * 0.5e0;\n        aa = Math.min(aa, bb);\n        aa = aa ** tth;\n        if (az > aa) {\n          goToLabel = 260;break;\n        }\n        aa = Math.sqrt(aa);\n        if (az > aa) ierr = 3;\n\n        var _azsqrt5 = (0, _zsqrt.azsqrt)(zr, zi);\n\n        var _azsqrt6 = _slicedToArray(_azsqrt5, 2);\n\n        csqr = _azsqrt6[0];\n        csqi = _azsqrt6[1];\n\n        ztar = tth * (zr * csqr - zi * csqi);\n        ztai = tth * (zr * csqi + zi * csqr);\n        // -----------------------------------------------------------------------\n        //     re(zta) <= 0 when re(z) < 0, especially when im(z) is small\n        // -----------------------------------------------------------------------\n        sfac = 1.0e0;\n        ak = ztai;\n        if (zr >= 0.0e0) {\n          goToLabel = 80;break;\n        }\n        bk = ztar;\n        ck = -Math.abs(bk);\n        ztar = ck;\n        ztai = ak;\n      case 80:\n\n        if (zi !== 0.0e0 || zr > 0.0e0) {\n          goToLabel = 90;break;\n        }\n        ztar = 0.0e0;\n        ztai = ak;\n      case 90:\n\n        aa = ztar;\n        if (kode === 2) {\n          goToLabel = 100;break;\n        }\n        // -----------------------------------------------------------------------\n        //     overflow test\n        // -----------------------------------------------------------------------\n        bb = Math.abs(aa);\n        if (bb < alim) {\n          goToLabel = 100;break;\n        }\n        bb = bb + 0.25e0 * Math.log(az);\n        sfac = tol;\n        if (bb > elim) {\n          goToLabel = 190;break;\n        }\n      case 100:\n\n        fmr = 0.0e0;\n        if (aa >= 0.0e0 && zr > 0.0e0) {\n          goToLabel = 110;break;\n        }\n        fmr = pi;\n        if (zi < 0.0e0) fmr = -pi;\n        ztar = -ztar;\n        ztai = -ztai;\n      case 110:\n\n        // -----------------------------------------------------------------------\n        //     aa=factor for analytic continuation of i(fnu,zta)\n        //     kode=2 returns Math.exp(-Math.abs(xzta))*i(fnu,zta) from cbesi\n        // -----------------------------------------------------------------------\n        nz = (0, _zbinu.zbinu)(ztar, ztai, fnu, kode, 1, cyr, cyi, rl, fnul, tol, elim, alim);\n        if (nz < 0) {\n          goToLabel = 200;break;\n        }\n        aa = fmr * fnu;\n        z3r = sfac;\n        str = Math.cos(aa);\n        sti = Math.sin(aa);\n        s1r = (str * cyr[0] - sti * cyi[0]) * z3r;\n        s1i = (str * cyi[0] + sti * cyr[0]) * z3r;\n        fnu = (2.0e0 - fid) / 3.0e0;\n        nz = (0, _zbinu.zbinu)(ztar, ztai, fnu, kode, 2, cyr, cyi, rl, fnul, tol, elim, alim);\n        cyr[0] = cyr[0] * z3r;\n        cyi[0] = cyi[0] * z3r;\n        cyr[1] = cyr[1] * z3r;\n        cyi[1] = cyi[1] * z3r;\n        // -----------------------------------------------------------------------\n        //     backward recur one step for orders -Math.trunc(1/3) or -Math.trunc(2/3)\n        // -----------------------------------------------------------------------\n\n        var _zdiv = (0, _zdiv3.zdiv)(cyr[0], cyi[0], ztar, ztai);\n\n        var _zdiv2 = _slicedToArray(_zdiv, 2);\n\n        str = _zdiv2[0];\n        sti = _zdiv2[1];\n\n        s2r = (fnu + fnu) * str + cyr[1];\n        s2i = (fnu + fnu) * sti + cyi[1];\n        aa = fmr * (fnu - 1.0e0);\n        str = Math.cos(aa);\n        sti = Math.sin(aa);\n        s1r = coef * (s1r + s2r * str - s2i * sti);\n        s1i = coef * (s1i + s2r * sti + s2i * str);\n        if (id === 1) {\n          goToLabel = 120;break;\n        }\n        str = csqr * s1r - csqi * s1i;\n        s1i = csqr * s1i + csqi * s1r;\n        s1r = str;\n        bir = s1r / sfac;\n        bii = s1i / sfac;\n        break mainExecutionLoop;\n      case 120:\n\n        str = zr * s1r - zi * s1i;\n        s1i = zr * s1i + zi * s1r;\n        s1r = str;\n        bir = s1r / sfac;\n        bii = s1i / sfac;\n        break mainExecutionLoop;\n      case 130:\n        aa = c1 * (1.0e0 - fid) + fid * c2;\n        bir = aa;\n        bii = 0.0e0;\n        break mainExecutionLoop;\n      case 190:\n\n        ierr = 2;\n        nz = 0;\n        break mainExecutionLoop;\n      case 200:\n\n        if (nz === -1) {\n          goToLabel = 190;break;\n        }\n        nz = 0;\n        ierr = 5;\n        break mainExecutionLoop;\n      case 260:\n\n        ierr = 4;\n        nz = 0;\n\n      default:\n        break mainExecutionLoop;\n    }\n  }\n  return [bir, bii, nz, ierr];\n}\n},{\"../../utils/fortran-utils/d1mach.js\":91,\"../../utils/fortran-utils/i1mach.js\":92,\"./zabs.js\":11,\"./zbinu.js\":21,\"./zdiv.js\":26,\"./zsqrt.js\":36}],23:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); /* eslint-disable no-labels */\n/* eslint-disable no-fallthrough */\n// SUBROUTINE ZBKNU(ZR, ZI, FNU, KODE, N, YR, YI, NZ, TOL, ELIM, ALIM)\n// ***BEGIN PROLOGUE  ZBKNU\n// ***REFER TO  ZBESI,ZBESK,ZAIRY,ZBESH\n//\n//      ZBKNU COMPUTES THE K BESSEL FUNCTION IN THE RIGHT HALF Z PLANE.\n//\n// ***ROUTINES CALLED  DGAMLN,I1MACH,D1MACH,ZKSCL,ZSHCH,ZUCHK,AZABS,ZDIV,\n//                     AZEXP,AZLOG,ZMLT,AZSQRT\n// ***END PROLOGUE  ZBKNU\n//\n\n\nexports.zbknu = zbknu;\n\nvar _dgamln = require('./dgamln.js');\n\nvar _i1mach = require('../../utils/fortran-utils/i1mach.js');\n\nvar _d1mach = require('../../utils/fortran-utils/d1mach.js');\n\nvar _zkscl = require('./zkscl.js');\n\nvar _zshch3 = require('./zshch.js');\n\nvar _zuchk = require('./zuchk.js');\n\nvar _zabs = require('./zabs.js');\n\nvar _zdiv7 = require('./zdiv.js');\n\nvar _zexp = require('./zexp.js');\n\nvar _zlog = require('./zlog.js');\n\nvar _zmlt23 = require('./zmlt.js');\n\nvar _zsqrt = require('./zsqrt.js');\n\nfunction zbknu(zr, zi, fnu, kode, n, yr, yi, tol, elim, alim) {\n  var aa = void 0,\n      ak = void 0,\n      ascle = void 0,\n      a1 = void 0,\n      a2 = void 0,\n      bb = void 0,\n      bk = void 0,\n      bry = void 0,\n      caz = void 0,\n      cbi = void 0,\n      cbr = void 0,\n      cc = void 0,\n      cchi = void 0,\n      cchr = void 0,\n      cki = void 0,\n      ckr = void 0,\n      coefi = void 0,\n      coefr = void 0,\n      conei = void 0,\n      coner = void 0,\n      crscr = void 0,\n      csclr = void 0,\n      cshi = void 0,\n      cshr = void 0,\n      csi = void 0,\n      csr = void 0,\n      csrr = void 0,\n      cssr = void 0,\n      ctwor = void 0,\n      czeroi = void 0,\n      czeror = void 0,\n      czi = void 0,\n      czr = void 0,\n      dnu = void 0,\n      dnu2 = void 0,\n      dpi = void 0,\n      etest = void 0,\n      fc = void 0,\n      fhs = void 0,\n      fi = void 0,\n      fk = void 0,\n      fks = void 0,\n      fmui = void 0,\n      fmur = void 0,\n      fpi = void 0,\n      fr = void 0,\n      g1 = void 0,\n      g2 = void 0,\n      hpi = void 0,\n      pi = void 0,\n      pr = void 0,\n      pti = void 0,\n      ptr = void 0,\n      p1i = void 0,\n      p1r = void 0,\n      p2i = void 0,\n      p2m = void 0,\n      p2r = void 0,\n      qi = void 0,\n      qr = void 0,\n      rak = void 0,\n      rcaz = void 0,\n      rthpi = void 0,\n      rzi = void 0,\n      rzr = void 0,\n      r1 = void 0,\n      s = void 0,\n      smui = void 0,\n      smur = void 0,\n      spi = void 0,\n      sti = void 0,\n      str = void 0,\n      s1i = void 0,\n      s1r = void 0,\n      s2i = void 0,\n      s2r = void 0,\n      tm = void 0,\n      tth = void 0,\n      t1 = void 0,\n      t2 = void 0,\n      elm = void 0,\n      celmr = void 0,\n      zdr = void 0,\n      zdi = void 0,\n      as = void 0,\n      alas = void 0,\n      helim = void 0,\n      cyr = void 0,\n      cyi = void 0,\n      i = void 0,\n      iflag = void 0,\n      inu = void 0,\n      k = void 0,\n      kflag = void 0,\n      kk = void 0,\n      kmax = void 0,\n      koded = void 0,\n      nz = void 0,\n      idum = void 0,\n      j = void 0,\n      ic = void 0,\n      inub = void 0,\n      nw = void 0;\n\n  cssr = new Array(3);\n  csrr = new Array(3);\n  bry = new Array(3);\n  cyr = new Array(2);\n  cyi = new Array(2);\n\n  kmax = 30;\n\n  czeror = 0.0;\n  czeroi = 0.0;\n  coner = 1.0;\n  conei = 0.0;\n  ctwor = 2.0;\n  r1 = 2.0;\n  dpi = 3.14159265358979324;\n  rthpi = 1.25331413731550025;\n  spi = 1.90985931710274403;\n  hpi = 1.57079632679489662;\n  fpi = 1.89769999331517738;\n  tth = 6.66666666666666666e-01;\n\n\n  cc = [5.77215664901532861e-01, -4.20026350340952355e-02, -4.21977345555443367e-02, 7.21894324666309954e-03, -2.15241674114950973e-04, -2.01348547807882387e-05, 1.13302723198169588e-06, 6.11609510448141582e-09];\n\n  var goToLabel = 0;\n  mainExecutionLoop: while (true) {\n    switch (goToLabel) {\n      case 0:\n        caz = (0, _zabs.azabs)(zr, zi);\n        csclr = 1.0 / tol;\n        crscr = tol;\n        cssr[0] = csclr;\n        cssr[1] = 1.0;\n        cssr[2] = crscr;\n        csrr[0] = crscr;\n        csrr[1] = 1.0;\n        csrr[2] = csclr;\n        bry[0] = 1.0e+3 * (0, _d1mach.d1mach)(1) / tol;\n        bry[1] = 1.0 / bry[0];\n        bry[2] = (0, _d1mach.d1mach)(2);\n        nz = 0;\n        iflag = 0;\n        koded = kode;\n        rcaz = 1.0 / caz;\n        str = zr * rcaz;\n        sti = -zi * rcaz;\n        rzr = (str + str) * rcaz;\n        rzi = (sti + sti) * rcaz;\n        inu = Math.trunc(fnu + 0.5);\n        dnu = fnu - inu;\n        if (Math.abs(dnu) === 0.5) {\n          goToLabel = 110;break;\n        }\n        dnu2 = 0.0;\n        if (Math.abs(dnu) > tol) dnu2 = dnu * dnu;\n        if (caz > r1) {\n          goToLabel = 110;break;\n        }\n        // c-----------------------------------------------------------------------\n        // c     series for cabs(z) <= r1\n        // c-----------------------------------------------------------------------\n        fc = 1.0;\n\n        var _azlog = (0, _zlog.azlog)(rzr, rzi);\n\n        var _azlog2 = _slicedToArray(_azlog, 3);\n\n        smur = _azlog2[0];\n        smui = _azlog2[1];\n        idum = _azlog2[2];\n\n        fmur = smur * dnu;\n        fmui = smui * dnu;\n\n        var _zshch = (0, _zshch3.zshch)(fmur, fmui);\n\n        var _zshch2 = _slicedToArray(_zshch, 4);\n\n        cshr = _zshch2[0];\n        cshi = _zshch2[1];\n        cchr = _zshch2[2];\n        cchi = _zshch2[3];\n\n        if (dnu === 0.0) {\n          goToLabel = 10;break;\n        }\n        fc = dnu * dpi;\n        fc = fc / Math.sin(fc);\n        smur = cshr / dnu;\n        smui = cshi / dnu;\n      case 10:\n        a2 = 1.0 + dnu;\n        // c-----------------------------------------------------------------------\n        // c     gam(1-z)*gam(1+z)=pi*z/sin(pi*z), t1=1/gam(1-dnu), t2=1/gam(1+dnu)\n        // c-----------------------------------------------------------------------\n        t2 = Math.exp(-(0, _dgamln.dgamln)(a2, idum));\n        t1 = 1.0 / (t2 * fc);\n        if (Math.abs(dnu) > 0.1) {\n          goToLabel = 40;break;\n        }\n        // c-----------------------------------------------------------------------\n        // c     series for f0 to resolve indeterminacy for small abs(dnu)\n        // c-----------------------------------------------------------------------\n        ak = 1.0;\n        s = cc[0];\n        // do 20 k=2,8\n        for (k = 2; k <= 8; k++) {\n          ak = ak * dnu2;\n          tm = cc[k - 1] * ak;\n          s = s + tm;\n          if (Math.abs(tm) < tol) break;\n        }\n        // 20 continue\n        g1 = -s;\n        goToLabel = 50;break;\n      case 40:\n        g1 = (t1 - t2) / (dnu + dnu);\n      case 50:\n        g2 = (t1 + t2) * 0.5;\n        fr = fc * (cchr * g1 + smur * g2);\n        fi = fc * (cchi * g1 + smui * g2);\n\n        var _azexp = (0, _zexp.azexp)(fmur, fmui);\n\n        var _azexp2 = _slicedToArray(_azexp, 2);\n\n        str = _azexp2[0];\n        sti = _azexp2[1];\n\n        pr = 0.5 * str / t2;\n        pi = 0.5 * sti / t2;\n\n        var _zdiv = (0, _zdiv7.zdiv)(0.5, 0.0, str, sti);\n\n        var _zdiv2 = _slicedToArray(_zdiv, 2);\n\n        ptr = _zdiv2[0];\n        pti = _zdiv2[1];\n\n        qr = ptr / t1;\n        qi = pti / t1;\n        s1r = fr;\n        s1i = fi;\n        s2r = pr;\n        s2i = pi;\n        ak = 1.0;\n        a1 = 1.0;\n        ckr = coner;\n        cki = conei;\n        bk = 1.0 - dnu2;\n        if (inu > 0 || n > 1) {\n          goToLabel = 80;break;\n        }\n        // c-----------------------------------------------------------------------\n        // c     generate k(fnu,z), 0.0  <=  fnu  <  0.5 and n=1\n        // c-----------------------------------------------------------------------\n        if (caz < tol) {\n          goToLabel = 70;break;\n        }\n\n        var _zmlt = (0, _zmlt23.zmlt)(zr, zi, zr, zi);\n\n        var _zmlt2 = _slicedToArray(_zmlt, 2);\n\n        czr = _zmlt2[0];\n        czi = _zmlt2[1];\n\n        czr = 0.25 * czr;\n        czi = 0.25 * czi;\n        t1 = 0.25 * caz * caz;\n      case 60:\n        fr = (fr * ak + pr + qr) / bk;\n        fi = (fi * ak + pi + qi) / bk;\n        str = 1.0 / (ak - dnu);\n        pr = pr * str;\n        pi = pi * str;\n        str = 1.0 / (ak + dnu);\n        qr = qr * str;\n        qi = qi * str;\n        str = ckr * czr - cki * czi;\n        rak = 1.0 / ak;\n        cki = (ckr * czi + cki * czr) * rak;\n        ckr = str * rak;\n        s1r = ckr * fr - cki * fi + s1r;\n        s1i = ckr * fi + cki * fr + s1i;\n        a1 = a1 * t1 * rak;\n        bk = bk + ak + ak + 1.0;\n        ak = ak + 1.0;\n        if (a1 > tol) {\n          goToLabel = 60;break;\n        }\n      case 70:\n        yr[0] = s1r;\n        yi[0] = s1i;\n        if (koded === 1) break mainExecutionLoop;\n\n        var _azexp3 = (0, _zexp.azexp)(zr, zi);\n\n        var _azexp4 = _slicedToArray(_azexp3, 2);\n\n        str = _azexp4[0];\n        sti = _azexp4[1];\n\n        var _zmlt3 = (0, _zmlt23.zmlt)(s1r, s1i, str, sti);\n\n        var _zmlt4 = _slicedToArray(_zmlt3, 2);\n\n        yr[0] = _zmlt4[0];\n        yi[0] = _zmlt4[1];\n\n        break mainExecutionLoop;\n      // c-----------------------------------------------------------------------\n      // c     generate k(dnu,z) and k(dnu+1,z) for forward recurrence\n      // c-----------------------------------------------------------------------\n      case 80:\n        if (caz < tol) {\n          goToLabel = 100;break;\n        }\n\n        var _zmlt5 = (0, _zmlt23.zmlt)(zr, zi, zr, zi);\n\n        var _zmlt6 = _slicedToArray(_zmlt5, 2);\n\n        czr = _zmlt6[0];\n        czi = _zmlt6[1];\n\n        czr = 0.25 * czr;\n        czi = 0.25 * czi;\n        t1 = 0.25 * caz * caz;\n      case 90:\n        fr = (fr * ak + pr + qr) / bk;\n        fi = (fi * ak + pi + qi) / bk;\n        str = 1.0 / (ak - dnu);\n        pr = pr * str;\n        pi = pi * str;\n        str = 1.0 / (ak + dnu);\n        qr = qr * str;\n        qi = qi * str;\n        str = ckr * czr - cki * czi;\n        rak = 1.0 / ak;\n        cki = (ckr * czi + cki * czr) * rak;\n        ckr = str * rak;\n        s1r = ckr * fr - cki * fi + s1r;\n        s1i = ckr * fi + cki * fr + s1i;\n        str = pr - fr * ak;\n        sti = pi - fi * ak;\n        s2r = ckr * str - cki * sti + s2r;\n        s2i = ckr * sti + cki * str + s2i;\n        a1 = a1 * t1 * rak;\n        bk = bk + ak + ak + 1.0;\n        ak = ak + 1.0;\n        if (a1 > tol) {\n          goToLabel = 90;break;\n        }\n      case 100:\n        kflag = 2;\n        a1 = fnu + 1.0;\n        ak = a1 * Math.abs(smur);\n        if (ak > alim) kflag = 3;\n        str = cssr[kflag - 1];\n        p2r = s2r * str;\n        p2i = s2i * str;\n\n        var _zmlt7 = (0, _zmlt23.zmlt)(p2r, p2i, rzr, rzi);\n\n        var _zmlt8 = _slicedToArray(_zmlt7, 2);\n\n        s2r = _zmlt8[0];\n        s2i = _zmlt8[1];\n\n        s1r = s1r * str;\n        s1i = s1i * str;\n        if (koded === 1) {\n          goToLabel = 210;break;\n        }\n\n        var _azexp5 = (0, _zexp.azexp)(zr, zi);\n\n        var _azexp6 = _slicedToArray(_azexp5, 2);\n\n        fr = _azexp6[0];\n        fi = _azexp6[1];\n\n        var _zmlt9 = (0, _zmlt23.zmlt)(s1r, s1i, fr, fi);\n\n        var _zmlt10 = _slicedToArray(_zmlt9, 2);\n\n        s1r = _zmlt10[0];\n        s1i = _zmlt10[1];\n\n        var _zmlt11 = (0, _zmlt23.zmlt)(s2r, s2i, fr, fi);\n\n        var _zmlt12 = _slicedToArray(_zmlt11, 2);\n\n        s2r = _zmlt12[0];\n        s2i = _zmlt12[1];\n\n        goToLabel = 210;break;\n      // c-----------------------------------------------------------------------\n      // c     iflag=0 means no underflow occurred\n      // c     iflag=1 means an underflow occurred- computation proceeds with\n      // c     koded=2 and a test for on scale values is made during forward\n      // c     recursion\n      // c-----------------------------------------------------------------------\n      case 110:\n        var _azsqrt = (0, _zsqrt.azsqrt)(zr, zi);\n\n        var _azsqrt2 = _slicedToArray(_azsqrt, 2);\n\n        str = _azsqrt2[0];\n        sti = _azsqrt2[1];\n\n        var _zdiv3 = (0, _zdiv7.zdiv)(rthpi, czeroi, str, sti);\n\n        var _zdiv4 = _slicedToArray(_zdiv3, 2);\n\n        coefr = _zdiv4[0];\n        coefi = _zdiv4[1];\n\n        kflag = 2;\n        if (koded === 2) {\n          goToLabel = 120;break;\n        }\n        if (zr > alim) {\n          goToLabel = 290;break;\n        }\n        // c     blank line\n        str = Math.exp(-zr) * cssr[kflag - 1];\n        sti = -str * Math.sin(zi);\n        str = str * Math.cos(zi);\n\n        var _zmlt13 = (0, _zmlt23.zmlt)(coefr, coefi, str, sti);\n\n        var _zmlt14 = _slicedToArray(_zmlt13, 2);\n\n        coefr = _zmlt14[0];\n        coefi = _zmlt14[1];\n\n      case 120:\n        if (Math.abs(dnu) === 0.5) {\n          goToLabel = 300;break;\n        }\n        // c-----------------------------------------------------------------------\n        // c     miller algorithm for cabs(z) > r1\n        // c-----------------------------------------------------------------------\n        ak = Math.cos(dpi * dnu);\n        ak = Math.abs(ak);\n        if (ak === czeror) {\n          goToLabel = 300;break;\n        }\n        fhs = Math.abs(0.25 - dnu2);\n        if (fhs === czeror) {\n          goToLabel = 300;break;\n        }\n        // c-----------------------------------------------------------------------\n        // c     compute r2=f(e). if cabs(z) >= r2, use forward recurrence to\n        // c     determine the backward index k. r2=f(e) is a straight line on\n        // c     12 <= e <= 60. e is computed from 2**(-e)=b**(1-i1mach(14))=\n        // c     tol where b is the base of the arithmetic.\n        // c-----------------------------------------------------------------------\n        t1 = (0, _i1mach.i1mach)(14) - 1;\n        t1 = t1 * (0, _d1mach.d1mach)(5) * 3.321928094;\n        t1 = Math.max(t1, 12.0);\n        t1 = Math.min(t1, 60.0);\n        t2 = tth * t1 - 6.0;\n        if (zr !== 0.0) {\n          goToLabel = 130;break;\n        }\n        t1 = hpi;\n        goToLabel = 140;break;\n      case 130:\n        t1 = Math.atan(zi / zr);\n        t1 = Math.abs(t1);\n      case 140:\n        if (t2 > caz) {\n          goToLabel = 170;break;\n        }\n        // c-----------------------------------------------------------------------\n        // c     forward recurrence loop when cabs(z) >= r2\n        // c-----------------------------------------------------------------------\n        etest = ak / (dpi * caz * tol);\n        fk = coner;\n        if (etest < coner) {\n          goToLabel = 180;break;\n        }\n        fks = ctwor;\n        ckr = caz + caz + ctwor;\n        p1r = czeror;\n        p2r = coner;\n        // do 150 i=1,kmax\n        for (i = 1; i <= kmax; i++) {\n          ak = fhs / fks;\n          cbr = ckr / (fk + coner);\n          ptr = p2r;\n          p2r = cbr * p2r - p1r * ak;\n          p1r = ptr;\n          ckr = ckr + ctwor;\n          fks = fks + fk + fk + ctwor;\n          fhs = fhs + fk + fk;\n          fk = fk + coner;\n          str = Math.abs(p2r) * fk;\n          if (etest < str) {\n            goToLabel = 160;break;\n          }\n        }\n        // 150 continue\n        if (goToLabel === 160) break;\n        goToLabel = 310;break;\n      case 160:\n        fk = fk + spi * t1 * Math.sqrt(t2 / caz);\n        fhs = Math.abs(0.25 - dnu2);\n        goToLabel = 180;break;\n      case 170:\n        // c-----------------------------------------------------------------------\n        // c     compute backward index k for cabs(z) < r2\n        // c-----------------------------------------------------------------------\n        a2 = Math.sqrt(caz);\n        ak = fpi * ak / (tol * Math.sqrt(a2));\n        aa = 3.0 * t1 / (1.0 + caz);\n        bb = 14.7 * t1 / (28.0 + caz);\n        ak = (Math.log(ak) + caz * Math.cos(aa) / (1.0 + 0.008 * caz)) / Math.cos(bb);\n        fk = 0.12125 * ak * ak / caz + 1.5;\n      case 180:\n        // c-----------------------------------------------------------------------\n        // c     backward recurrence loop for miller algorithm\n        // c-----------------------------------------------------------------------\n        k = Math.trunc(fk);\n        fk = k;\n        fks = fk * fk;\n        p1r = czeror;\n        p1i = czeroi;\n        p2r = tol;\n        p2i = czeroi;\n        csr = p2r;\n        csi = p2i;\n        // do 190 i=1,k\n        for (i = 1; i <= k; i++) {\n          a1 = fks - fk;\n          ak = (fks + fk) / (a1 + fhs);\n          rak = 2.0 / (fk + coner);\n          cbr = (fk + zr) * rak;\n          cbi = zi * rak;\n          ptr = p2r;\n          pti = p2i;\n          p2r = (ptr * cbr - pti * cbi - p1r) * ak;\n          p2i = (pti * cbr + ptr * cbi - p1i) * ak;\n          p1r = ptr;\n          p1i = pti;\n          csr = csr + p2r;\n          csi = csi + p2i;\n          fks = a1 - fk + coner;\n          fk = fk - coner;\n        }\n        // 190 continue\n        // c-----------------------------------------------------------------------\n        // c     compute (p2/cs)=(p2/cabs(cs))*(conjg(cs)/cabs(cs)) for better\n        // c     scaling\n        // c-----------------------------------------------------------------------\n        tm = (0, _zabs.azabs)(csr, csi);\n        ptr = 1.0 / tm;\n        s1r = p2r * ptr;\n        s1i = p2i * ptr;\n        csr = csr * ptr;\n        csi = -csi * ptr;\n\n        var _zmlt15 = (0, _zmlt23.zmlt)(coefr, coefi, s1r, s1i);\n\n        var _zmlt16 = _slicedToArray(_zmlt15, 2);\n\n        str = _zmlt16[0];\n        sti = _zmlt16[1];\n\n        var _zmlt17 = (0, _zmlt23.zmlt)(str, sti, csr, csi);\n\n        var _zmlt18 = _slicedToArray(_zmlt17, 2);\n\n        s1r = _zmlt18[0];\n        s1i = _zmlt18[1];\n\n        if (inu > 0 || n > 1) {\n          goToLabel = 200;break;\n        }\n        zdr = zr;\n        zdi = zi;\n        if (iflag === 1) {\n          goToLabel = 270;break;\n        }\n        goToLabel = 240;break;\n      case 200:\n        // c-----------------------------------------------------------------------\n        // c     compute p1/p2=(p1/cabs(p2)*conjg(p2)/cabs(p2) for scaling\n        // c-----------------------------------------------------------------------\n        tm = (0, _zabs.azabs)(p2r, p2i);\n        ptr = 1.0 / tm;\n        p1r = p1r * ptr;\n        p1i = p1i * ptr;\n        p2r = p2r * ptr;\n        p2i = -p2i * ptr;\n\n        var _zmlt19 = (0, _zmlt23.zmlt)(p1r, p1i, p2r, p2i);\n\n        var _zmlt20 = _slicedToArray(_zmlt19, 2);\n\n        ptr = _zmlt20[0];\n        pti = _zmlt20[1];\n\n        str = dnu + 0.5 - ptr;\n        sti = -pti;\n\n        var _zdiv5 = (0, _zdiv7.zdiv)(str, sti, zr, zi);\n\n        var _zdiv6 = _slicedToArray(_zdiv5, 2);\n\n        str = _zdiv6[0];\n        sti = _zdiv6[1];\n\n        str = str + 1.0;\n\n        var _zmlt21 = (0, _zmlt23.zmlt)(str, sti, s1r, s1i);\n\n        var _zmlt22 = _slicedToArray(_zmlt21, 2);\n\n        s2r = _zmlt22[0];\n        s2i = _zmlt22[1];\n\n      // c-----------------------------------------------------------------------\n      // c     forward recursion on the three term recursion with relation with\n      // c     scaling near exponent extremes on kflag=1 or kflag=3\n      // c-----------------------------------------------------------------------\n      case 210:\n        str = dnu + 1.0;\n        ckr = str * rzr;\n        cki = str * rzi;\n        if (n === 1) inu = inu - 1;\n        if (inu > 0) {\n          goToLabel = 220;break;\n        }\n        if (n > 1) {\n          goToLabel = 215;break;\n        }\n        s1r = s2r;\n        s1i = s2i;\n      case 215:\n        zdr = zr;\n        zdi = zi;\n        if (iflag === 1) {\n          goToLabel = 270;break;\n        }\n        goToLabel = 240;break;\n      case 220:\n        inub = 1;\n        if (iflag === 1) {\n          goToLabel = 261;break;\n        }\n      case 225:\n        p1r = csrr[kflag - 1];\n        ascle = bry[kflag - 1];\n        // do 230 i=inub,inu\n        for (i = inub; i <= inu; i++) {\n          str = s2r;\n          sti = s2i;\n          s2r = ckr * str - cki * sti + s1r;\n          s2i = ckr * sti + cki * str + s1i;\n          s1r = str;\n          s1i = sti;\n          ckr = ckr + rzr;\n          cki = cki + rzi;\n          if (kflag >= 3) continue;\n          p2r = s2r * p1r;\n          p2i = s2i * p1r;\n          str = Math.abs(p2r);\n          sti = Math.abs(p2i);\n          p2m = Math.max(str, sti);\n          if (p2m <= ascle) continue;\n          kflag = kflag + 1;\n          ascle = bry[kflag - 1];\n          s1r = s1r * p1r;\n          s1i = s1i * p1r;\n          s2r = p2r;\n          s2i = p2i;\n          str = cssr[kflag - 1];\n          s1r = s1r * str;\n          s1i = s1i * str;\n          s2r = s2r * str;\n          s2i = s2i * str;\n          p1r = csrr[kflag - 1];\n        }\n        // 230 continue\n        if (n !== 1) {\n          goToLabel = 240;break;\n        }\n        s1r = s2r;\n        s1i = s2i;\n      case 240:\n        str = csrr[kflag - 1];\n        yr[0] = s1r * str;\n        yi[0] = s1i * str;\n        if (n === 1) break mainExecutionLoop;\n        yr[1] = s2r * str;\n        yi[1] = s2i * str;\n        if (n === 2) break mainExecutionLoop;\n        kk = 2;\n      case 250:\n        kk = kk + 1;\n        if (kk > n) break mainExecutionLoop;\n        p1r = csrr[kflag - 1];\n        ascle = bry[kflag - 1];\n        // do 260 i=kk,n\n        for (i = kk; i <= n; i++) {\n          p2r = s2r;\n          p2i = s2i;\n          s2r = ckr * p2r - cki * p2i + s1r;\n          s2i = cki * p2r + ckr * p2i + s1i;\n          s1r = p2r;\n          s1i = p2i;\n          ckr = ckr + rzr;\n          cki = cki + rzi;\n          p2r = s2r * p1r;\n          p2i = s2i * p1r;\n          yr[i - 1] = p2r;\n          yi[i - 1] = p2i;\n          if (kflag >= 3) continue;\n          str = Math.abs(p2r);\n          sti = Math.abs(p2i);\n          p2m = Math.max(str, sti);\n          if (p2m <= ascle) continue;\n          kflag = kflag + 1;\n          ascle = bry[kflag - 1];\n          s1r = s1r * p1r;\n          s1i = s1i * p1r;\n          s2r = p2r;\n          s2i = p2i;\n          str = cssr[kflag - 1];\n          s1r = s1r * str;\n          s1i = s1i * str;\n          s2r = s2r * str;\n          s2i = s2i * str;\n          p1r = csrr[kflag - 1];\n        }\n        // 260 continue\n        break mainExecutionLoop;\n      // c-----------------------------------------------------------------------\n      // c     iflag=1 cases, forward recurrence on scaled values on underflow\n      // c-----------------------------------------------------------------------\n      case 261:\n        helim = 0.5 * elim;\n        elm = Math.exp(-elim);\n        celmr = elm;\n        ascle = bry[0];\n        zdr = zr;\n        zdi = zi;\n        ic = -1;\n        j = 2;\n        // do 262 i=1,inu\n        for (i = 1; i <= inu; i++) {\n          str = s2r;\n          sti = s2i;\n          s2r = str * ckr - sti * cki + s1r;\n          s2i = sti * ckr + str * cki + s1i;\n          s1r = str;\n          s1i = sti;\n          ckr = ckr + rzr;\n          cki = cki + rzi;\n          as = (0, _zabs.azabs)(s2r, s2i);\n          alas = Math.log(as);\n          p2r = -zdr + alas;\n          if (p2r < -elim) {\n            // go to 263\n          } else {\n            var _azlog3 = (0, _zlog.azlog)(s2r, s2i);\n\n            var _azlog4 = _slicedToArray(_azlog3, 3);\n\n            str = _azlog4[0];\n            sti = _azlog4[1];\n            idum = _azlog4[2];\n\n            p2r = -zdr + str;\n            p2i = -zdi + sti;\n            p2m = Math.exp(p2r) / tol;\n            p1r = p2m * Math.cos(p2i);\n            p1i = p2m * Math.sin(p2i);\n            nw = (0, _zuchk.zuchk)(p1r, p1i, ascle, tol);\n            if (nw !== 0) {\n              // go to 263\n            } else {\n              j = 3 - j;\n              cyr[j - 1] = p1r;\n              cyi[j - 1] = p1i;\n              if (ic === i - 1) {\n                goToLabel = 264;break;\n              }\n              ic = i;\n              continue;\n            }\n          }\n          // 263   continue\n          if (alas < helim) continue;\n          zdr = zdr - elim;\n          s1r = s1r * celmr;\n          s1i = s1i * celmr;\n          s2r = s2r * celmr;\n          s2i = s2i * celmr;\n        }\n        // 262 continue\n        if (goToLabel === 264) break;\n        if (n !== 1) {\n          goToLabel = 270;break;\n        }\n        s1r = s2r;\n        s1i = s2i;\n        goToLabel = 270;break;\n      case 264:\n        kflag = 1;\n        inub = i + 1;\n        s2r = cyr[j - 1];\n        s2i = cyi[j - 1];\n        j = 3 - j;\n        s1r = cyr[j - 1];\n        s1i = cyi[j - 1];\n        if (inub <= inu) {\n          goToLabel = 225;break;\n        }\n        if (n !== 1) {\n          goToLabel = 240;break;\n        }\n        s1r = s2r;\n        s1i = s2i;\n        goToLabel = 240;break;\n      case 270:\n        yr[0] = s1r;\n        yi[0] = s1i;\n        if (n === 1) {\n          goToLabel = 280;break;\n        }\n        yr[1] = s2r;\n        yi[1] = s2i;\n      case 280:\n        ascle = bry[0];\n        nz = (0, _zkscl.zkscl)(zdr, zdi, fnu, n, yr, yi, rzr, rzi, ascle, tol, elim);\n        inu = n - nz;\n        if (inu <= 0) break mainExecutionLoop;\n        kk = nz + 1;\n        s1r = yr[kk - 1];\n        s1i = yi[kk - 1];\n        yr[kk - 1] = s1r * csrr[0];\n        yi[kk - 1] = s1i * csrr[0];\n        if (inu === 1) break mainExecutionLoop;\n        kk = nz + 2;\n        s2r = yr[kk - 1];\n        s2i = yi[kk - 1];\n        yr[kk - 1] = s2r * csrr[0];\n        yi[kk - 1] = s2i * csrr[0];\n        if (inu === 2) break mainExecutionLoop;\n        t2 = fnu + (kk - 1);\n        ckr = t2 * rzr;\n        cki = t2 * rzi;\n        kflag = 1;\n        goToLabel = 250;break;\n      case 290:\n        // c-----------------------------------------------------------------------\n        // c     scale by Math.exp(z), iflag = 1 cases\n        // c-----------------------------------------------------------------------\n        koded = 2;\n        iflag = 1;\n        kflag = 2;\n        goToLabel = 120;break;\n      // c-----------------------------------------------------------------------\n      // c     fnu=half odd integer case, dnu=-0.5\n      // c-----------------------------------------------------------------------\n      case 300:\n        s1r = coefr;\n        s1i = coefi;\n        s2r = coefr;\n        s2i = coefi;\n        goToLabel = 210;break;\n      // c\n      // c\n      case 310:\n        nz = -2;\n      default:\n        break mainExecutionLoop;\n    }\n  }\n\n  return nz;\n}\n},{\"../../utils/fortran-utils/d1mach.js\":91,\"../../utils/fortran-utils/i1mach.js\":92,\"./dgamln.js\":10,\"./zabs.js\":11,\"./zdiv.js\":26,\"./zexp.js\":27,\"./zkscl.js\":28,\"./zlog.js\":29,\"./zmlt.js\":31,\"./zshch.js\":35,\"./zsqrt.js\":36,\"./zuchk.js\":37}],24:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); /* eslint-disable no-labels */\n/* eslint-disable no-fallthrough */\n// SUBROUTINE ZBUNI(ZR, ZI, FNU, KODE, N, YR, YI, NZ, NUI, NLAST,\n// * FNUL, TOL, ELIM, ALIM)\n// ***BEGIN PROLOGUE  ZBUNI\n// ***REFER TO  ZBESI,ZBESK\n//\n//      ZBUNI COMPUTES THE I BESSEL FUNCTION FOR LARGE CABS(Z).GT.\n//      FNUL AND FNU+N-1.LT.FNUL. THE ORDER IS INCREASED FROM\n//      FNU+N-1 GREATER THAN FNUL BY ADDING NUI AND COMPUTING\n//      ACCORDING TO THE UNIFORM ASYMPTOTIC EXPANSION FOR I(FNU,Z)\n//      ON IFORM=1 AND THE EXPANSION FOR J(FNU,Z) ON IFORM=2\n//\n// ***ROUTINES CALLED  ZUNI1,ZUNI2,AZABS,D1MACH\n// ***END PROLOGUE  ZBUNI\n\n\nexports.zbuni = zbuni;\n\nvar _zuni9 = require('./zuni1.js');\n\nvar _zuni10 = require('./zuni2.js');\n\nvar _zabs = require('./zabs.js');\n\nvar _d1mach = require('../../utils/fortran-utils/d1mach.js');\n\nfunction zbuni(zr, zi, fnu, kode, n, yr, yi, nui, nlast, fnul, tol, elim, alim) {\n  var ax = void 0,\n      ay = void 0,\n      csclr = void 0,\n      cscrr = void 0,\n      cyi = void 0,\n      cyr = void 0,\n      dfnu = void 0,\n      fnui = void 0,\n      gnu = void 0,\n      raz = void 0,\n      rzi = void 0,\n      rzr = void 0,\n      sti = void 0,\n      str = void 0,\n      s1i = void 0,\n      s1r = void 0,\n      s2i = void 0,\n      s2r = void 0,\n      ascle = void 0,\n      bry = void 0,\n      c1r = void 0,\n      c1i = void 0,\n      c1m = void 0,\n      i = void 0,\n      iflag = void 0,\n      iform = void 0,\n      k = void 0,\n      nl = void 0,\n      nw = void 0,\n      nz = void 0;\n\n  cyr = new Array(2);\n  cyi = new Array(2);\n  bry = new Array(3);\n\n  var goToLabel = 0;\n  mainExecutionLoop: while (true) {\n    switch (goToLabel) {\n      case 0:\n        nz = 0;\n        ax = Math.abs(zr) * 1.7321;\n        ay = Math.abs(zi);\n        iform = 1;\n        if (ay > ax) iform = 2;\n        if (nui === 0) {\n          goToLabel = 60;break;\n        }\n        fnui = nui;\n        dfnu = fnu + (n - 1);\n        gnu = dfnu + fnui;\n        if (iform === 2) {\n          goToLabel = 10;break;\n        }\n        // c-----------------------------------------------------------------------\n        // c     asymptotic expansion for i(fnu,z) for large fnu applied in\n        // c     -pi/3 <= arg(z) <= pi/3\n        // c-----------------------------------------------------------------------\n\n        var _zuni = (0, _zuni9.zuni1)(zr, zi, gnu, kode, 2, cyr, cyi, fnul, tol, elim, alim);\n\n        var _zuni2 = _slicedToArray(_zuni, 2);\n\n        nw = _zuni2[0];\n        nlast = _zuni2[1];\n\n        goToLabel = 20;break;\n      case 10:\n        var _zuni3 = (0, _zuni10.zuni2)(zr, zi, gnu, kode, 2, cyr, cyi, fnul, tol, elim, alim);\n        // c-----------------------------------------------------------------------\n        // c     asymptotic expansion for j(fnu,z*exp(m*hpi)) for large fnu\n        // c     applied in pi/3 < abs(arg(z)) <= pi/2 where m=+i or -i\n        // c     and hpi=pi/2\n        // c-----------------------------------------------------------------------\n\n\n        var _zuni4 = _slicedToArray(_zuni3, 2);\n\n        nw = _zuni4[0];\n        nlast = _zuni4[1];\n\n      case 20:\n        if (nw < 0) {\n          goToLabel = 50;break;\n        }\n        if (nw !== 0) {\n          goToLabel = 90;break;\n        }\n        str = (0, _zabs.azabs)(cyr[0], cyi[0]);\n        // c----------------------------------------------------------------------\n        // c     scale backward recurrence, bry(3) is defined but never used\n        // c----------------------------------------------------------------------\n        bry[0] = 1.0e+3 * (0, _d1mach.d1mach)(1) / tol;\n        bry[1] = 1.0 / bry[0];\n        bry[2] = bry[1];\n        iflag = 2;\n        ascle = bry[1];\n        csclr = 1.0;\n        if (str > bry[0]) {\n          goToLabel = 21;break;\n        }\n        iflag = 1;\n        ascle = bry[0];\n        csclr = 1.0 / tol;\n        goToLabel = 25;break;\n      case 21:\n        if (str < bry[1]) {\n          goToLabel = 25;break;\n        }\n        iflag = 3;\n        ascle = bry[2];\n        csclr = tol;\n      case 25:\n        cscrr = 1.0 / csclr;\n        s1r = cyr[1] * csclr;\n        s1i = cyi[1] * csclr;\n        s2r = cyr[0] * csclr;\n        s2i = cyi[0] * csclr;\n        raz = 1.0 / (0, _zabs.azabs)(zr, zi);\n        str = zr * raz;\n        sti = -zi * raz;\n        rzr = (str + str) * raz;\n        rzi = (sti + sti) * raz;\n        // do 30 i=1,nui\n        for (i = 1; i <= nui; i++) {\n          str = s2r;\n          sti = s2i;\n          s2r = (dfnu + fnui) * (rzr * str - rzi * sti) + s1r;\n          s2i = (dfnu + fnui) * (rzr * sti + rzi * str) + s1i;\n          s1r = str;\n          s1i = sti;\n          fnui = fnui - 1.0;\n          if (iflag >= 3) continue;\n          str = s2r * cscrr;\n          sti = s2i * cscrr;\n          c1r = Math.abs(str);\n          c1i = Math.abs(sti);\n          c1m = Math.max(c1r, c1i);\n          if (c1m <= ascle) continue;\n          iflag = iflag + 1;\n          ascle = bry[iflag - 1];\n          s1r = s1r * cscrr;\n          s1i = s1i * cscrr;\n          s2r = str;\n          s2i = sti;\n          csclr = csclr * tol;\n          cscrr = 1.0 / csclr;\n          s1r = s1r * csclr;\n          s1i = s1i * csclr;\n          s2r = s2r * csclr;\n          s2i = s2i * csclr;\n        }\n        // 30 continue\n        yr[n - 1] = s2r * cscrr;\n        yi[n - 1] = s2i * cscrr;\n        if (n === 1) break mainExecutionLoop;\n        nl = n - 1;\n        fnui = nl;\n        k = nl;\n        // do 40 i=1,nl\n        for (i = 1; i <= nl; i++) {\n          str = s2r;\n          sti = s2i;\n          s2r = (fnu + fnui) * (rzr * str - rzi * sti) + s1r;\n          s2i = (fnu + fnui) * (rzr * sti + rzi * str) + s1i;\n          s1r = str;\n          s1i = sti;\n          str = s2r * cscrr;\n          sti = s2i * cscrr;\n          yr[k - 1] = str;\n          yi[k - 1] = sti;\n          fnui = fnui - 1.0;\n          k = k - 1;\n          if (iflag >= 3) continue;\n          c1r = Math.abs(str);\n          c1i = Math.abs(sti);\n          c1m = Math.max(c1r, c1i);\n          if (c1m <= ascle) continue;\n          iflag = iflag + 1;\n          ascle = bry[iflag - 1];\n          s1r = s1r * cscrr;\n          s1i = s1i * cscrr;\n          s2r = str;\n          s2i = sti;\n          csclr = csclr * tol;\n          cscrr = 1.0 / csclr;\n          s1r = s1r * csclr;\n          s1i = s1i * csclr;\n          s2r = s2r * csclr;\n          s2i = s2i * csclr;\n        }\n        // 40 continue\n        break mainExecutionLoop;\n      case 50:\n        nz = -1;\n        if (nw === -2) nz = -2;\n        break mainExecutionLoop;\n      case 60:\n        if (iform === 2) {\n          goToLabel = 70;break;\n        }\n        // c-----------------------------------------------------------------------\n        // c     asymptotic expansion for i(fnu,z) for large fnu applied in\n        // c     -pi/3 <= arg(z) <= pi/3\n        // c-----------------------------------------------------------------------\n\n        var _zuni5 = (0, _zuni9.zuni1)(zr, zi, fnu, kode, n, yr, yi, fnul, tol, elim, alim);\n\n        var _zuni6 = _slicedToArray(_zuni5, 2);\n\n        nw = _zuni6[0];\n        nlast = _zuni6[1];\n\n        goToLabel = 80;break;\n      case 70:\n        var _zuni7 = (0, _zuni10.zuni2)(zr, zi, fnu, kode, n, yr, yi, fnul, tol, elim, alim);\n        // c-----------------------------------------------------------------------\n        // c     asymptotic expansion for j(fnu,z*exp(m*hpi)) for large fnu\n        // c     applied in pi/3 < abs(arg(z)) <= pi/2 where m=+i or -i\n        // c     and hpi=pi/2\n        // c-----------------------------------------------------------------------\n\n\n        var _zuni8 = _slicedToArray(_zuni7, 2);\n\n        nw = _zuni8[0];\n        nlast = _zuni8[1];\n\n      case 80:\n        if (nw < 0) {\n          goToLabel = 50;break;\n        }\n        nz = nw;\n        break mainExecutionLoop;\n      case 90:\n        nlast = n;\n      default:\n        break mainExecutionLoop;\n    }\n  }\n\n  return [nz, nlast];\n}\n},{\"../../utils/fortran-utils/d1mach.js\":91,\"./zabs.js\":11,\"./zuni1.js\":39,\"./zuni2.js\":40}],25:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.zbunk = zbunk;\n\nvar _zunk = require('./zunk1.js');\n\nvar _zunk2 = require('./zunk2.js');\n\n// SUBROUTINE ZBUNK(ZR, ZI, FNU, KODE, MR, N, YR, YI, NZ, TOL, ELIM, ALIM)\n// ***BEGIN PROLOGUE  ZBUNK\n// ***REFER TO  ZBESK,ZBESH\n//\n//      ZBUNK COMPUTES THE K BESSEL FUNCTION FOR FNU.GT.FNUL.\n//      ACCORDING TO THE UNIFORM ASYMPTOTIC EXPANSION FOR K(FNU,Z)\n//      IN ZUNK1 AND THE EXPANSION FOR H(2,FNU,Z) IN ZUNK2\n//\n// ***ROUTINES CALLED  ZUNK1,ZUNK2\n// ***END PROLOGUE  ZBUNK\nfunction zbunk(zr, zi, fnu, kode, mr, n, yr, yi, tol, elim, alim) {\n  var ax = void 0,\n      ay = void 0;\n  ax = Math.abs(zr) * 1.7321;\n  ay = Math.abs(zi);\n  if (ay > ax) {\n    return (0, _zunk2.zunk2)(zr, zi, fnu, kode, mr, n, yr, yi, tol, elim, alim);\n  } else {\n    return (0, _zunk.zunk1)(zr, zi, fnu, kode, mr, n, yr, yi, tol, elim, alim);\n  }\n}\n},{\"./zunk1.js\":42,\"./zunk2.js\":43}],26:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.zdiv = zdiv;\n\nvar _zabs = require('./zabs.js');\n\nfunction zdiv(ar, ai, br, bi) {\n  var cr = void 0,\n      ci = void 0,\n      bm = void 0,\n      ca = void 0,\n      cb = void 0,\n      cc = void 0,\n      cd = void 0;\n  bm = 1 / (0, _zabs.azabs)(br, bi);\n  cc = br * bm;\n  cd = bi * bm;\n  ca = (ar * cc + ai * cd) * bm;\n  cb = (ai * cc - ar * cd) * bm;\n  cr = ca;\n  ci = cb;\n  return [cr, ci];\n} // SUBROUTINE ZDIV(AR, AI, BR, BI, CR, CI)\n// ***BEGIN PROLOGUE  ZDIV\n// ***REFER TO  ZBESH,ZBESI,ZBESJ,ZBESK,ZBESY,ZAIRY,ZBIRY\n//\n//      DOUBLE PRECISION COMPLEX DIVIDE C=A/B.\n//\n// ***ROUTINES CALLED  AZABS\n// ***END PROLOGUE  ZDIV\n},{\"./zabs.js\":11}],27:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.azexp = azexp;\n// SUBROUTINE AZEXP(AR, AI, BR, BI)\n// ***BEGIN PROLOGUE  AZEXP\n// ***REFER TO  ZBESH,ZBESI,ZBESJ,ZBESK,ZBESY,ZAIRY,ZBIRY\n//\n//      DOUBLE PRECISION COMPLEX EXPONENTIAL FUNCTION B=EXP(A)\n//\n// ***ROUTINES CALLED  (NONE)\n// ***END PROLOGUE  AZEXP\nfunction azexp(ar, ai) {\n  var zm = Math.exp(ar);\n  return [zm * Math.cos(ai), zm * Math.sin(ai)];\n}\n},{}],28:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); /* eslint-disable no-labels */\n/* eslint-disable no-fallthrough */\n//* **BEGIN PROLOGUE  ZKSCL\n//* **REFER TO  ZBESK\n//\n//     SET K FUNCTIONS TO ZERO ON UNDERFLOW,  RECURRENCE\n//     ON SCALED FUNCTIONS UNTIL TWO MEMBERS COME ON SCALE, {\n//     RETURN WITH MIN(NZ+2,N) VALUES SCALED BY 1/TOL.\n//\n//* **ROUTINES ED()  ZUCHK,AZABS,AZLOG\n//* **END PROLOGUE  ZKSCL\n//     COMPLEX CK,CS,CY,CZERO,RZ,S1,S2,Y,ZR,ZD,CELM\n\n\nexports.zkscl = zkscl;\n\nvar _zabs = require('./zabs.js');\n\nvar _zlog = require('./zlog.js');\n\nvar _zuchk = require('./zuchk.js');\n\nfunction zkscl(zrr, zri, fnu, n, yr, yi, nz, rzr, rzi, ascle, tol, elim) {\n  var acs = void 0,\n      as = void 0,\n      cki = void 0,\n      ckr = void 0,\n      csi = void 0,\n      csr = void 0,\n      cyi = void 0,\n      cyr = void 0,\n      fn = void 0,\n      str = void 0,\n      s1i = void 0,\n      s1r = void 0,\n      s2i = void 0,\n      s2r = void 0,\n      zeroi = void 0,\n      zeror = void 0,\n      zdr = void 0,\n      zdi = void 0,\n      celmr = void 0,\n      elm = void 0,\n      helim = void 0,\n      alas = void 0,\n      i = void 0,\n      ic = void 0,\n      kk = void 0,\n      nn = void 0,\n      nw = void 0;\n\n  cyr = new Float64Array(2);\n  cyi = new Float64Array(2);\n\n  var goToLabel = 0;\n  console.log('zkscl');\n  mainExecutionLoop: while (true) {\n    switch (goToLabel) {\n      case 0:\n        //\n        zeror = 0.0e0;\n        // double precision acs, as, ascle, cki, ckr, csi, csr, cyi, cyr, elim, fn, fnu, rzi, rzr, str, s1i, s1r, s2i, s2r, tol, yi, yr, zeroi, zeror, zri, zrr, azabs, zdr, zdi, celmr, elm, helim, alas\n        // integer i, ic, kk, n, nn, nw, nz\n        // dimension yr(n), yi(n), cyr(2), cyi(2)\n\n        zeroi = 0.0e0;\n        nz = 0;\n        ic = 0;\n        nn = Math.min(2, n);\n        for (i = 1; i <= nn; i++) {\n          s1r = yr[i - 1];\n          s1i = yi[i - 1];\n          cyr[i - 1] = s1r;\n          cyi[i - 1] = s1i;\n          as = (0, _zabs.azabs)(s1r, s1i);\n          acs = -zrr + Math.log(as);\n          nz = nz + 1;\n          yr[i - 1] = zeror;\n          yi[i - 1] = zeroi;\n          if (acs < -elim) continue;\n\n          var _azlog = (0, _zlog.azlog)(s1r, s1i);\n\n          var _azlog2 = _slicedToArray(_azlog, 2);\n\n          csr = _azlog2[0];\n          csi = _azlog2[1];\n\n          csr = csr - zrr;\n          csi = csi - zri;\n          str = Math.exp(csr) / tol;\n          csr = str * Math.cos(csi);\n          csi = str * Math.sin(csi);\n          (0, _zuchk.zuchk)(csr, csi, nw, ascle, tol);\n          if (nw !== 0) continue;\n          yr[i - 1] = csr;\n          yi[i - 1] = csi;\n          ic = i;\n          nz = nz - 1;\n        }\n        if (n === 1) break mainExecutionLoop;\n        if (ic > 1) {\n          goToLabel = 20;break;\n        }\n        yr[0] = zeror;\n        yi[0] = zeroi;\n        nz = 2;\n      case 20:\n        if (n === 2) break mainExecutionLoop;\n        if (nz === 0) break mainExecutionLoop;\n        fn = fnu + 1.0e0;\n        ckr = fn * rzr;\n        cki = fn * rzi;\n        s1r = cyr[0];\n        s1i = cyi[0];\n        s2r = cyr[1];\n        s2i = cyi[1];\n        helim = 0.5e0 * elim;\n        elm = Math.exp(-elim);\n        celmr = elm;\n        zdr = zrr;\n        zdi = zri;\n        //\n        //     find two consecutive y values on scale. scale recurrence if\n        //     s2 gets larger than Math.exp(elim/2)\n        //\n        for (i = 3; i <= n; i++) {\n          kk = i;\n          csr = s2r;\n          csi = s2i;\n          s2r = ckr * csr - cki * csi + s1r;\n          s2i = cki * csr + ckr * csi + s1i;\n          s1r = csr;\n          s1i = csi;\n          ckr = ckr + rzr;\n          cki = cki + rzi;\n          as = (0, _zabs.azabs)(s2r, s2i);\n          alas = Math.log(as);\n          acs = -zdr + alas;\n          nz = nz + 1;\n          yr[i - 1] = zeror;\n          yi[i - 1] = zeroi;\n          if (acs < -elim) {\n            // goToLabel = 25; break;\n          } else {\n            var _azlog3 = (0, _zlog.azlog)(s2r, s2i);\n\n            var _azlog4 = _slicedToArray(_azlog3, 2);\n\n            csr = _azlog4[0];\n            csi = _azlog4[1];\n\n            csr = csr - zdr;\n            csi = csi - zdi;\n            str = Math.exp(csr) / tol;\n            csr = str * Math.cos(csi);\n            csi = str * Math.sin(csi);\n            (0, _zuchk.zuchk)(csr, csi, nw, ascle, tol);\n            if (nw !== 0) {\n              // goToLabel = 25; break;\n            } else {\n              yr[i - 1] = csr;\n              yi[i - 1] = csi;\n              nz = nz - 1;\n              if (ic === kk - 1) {\n                goToLabel = 40;break;\n              }\n              ic = kk;\n              continue;\n            }\n          }\n          // case 25:\n          if (alas < helim) continue;\n          zdr = zdr - elim;\n          s1r = s1r * celmr;\n          s1i = s1i * celmr;\n          s2r = s2r * celmr;\n          s2i = s2i * celmr;\n        }\n        if (goToLabel > 30) break;\n        nz = n;\n        if (ic === n) nz = n - 1;\n        goToLabel = 45;break;\n      case 40:\n        nz = kk - 2;\n      case 45:\n        for (i = 1; i <= nz; i++) {\n          yr[i - 1] = zeror;\n          yi[i - 1] = zeroi;\n        }\n      default:\n        break mainExecutionLoop;\n    }\n  }\n  return nz;\n}\n},{\"./zabs.js\":11,\"./zlog.js\":29,\"./zuchk.js\":37}],29:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.azlog = azlog;\n\nvar _zabs = require('./zabs.js');\n\nfunction azlog(ar, ai, br, bi, ierr) {\n  var zm = void 0,\n      dtheta = void 0,\n      dpi = void 0,\n      dhpi = void 0;\n  var goToLabel = 0;\n  mainExecutionLoop: while (true) {\n    switch (goToLabel) {\n      case 0:\n        dpi = 3.141592653589793238462643383;\n        // double precision ar, ai, br, bi, zm, dtheta, dpi, dhpi\n        // double precision azabs\n\n        dhpi = 1.570796326794896619231321696;\n\n        ierr = 0;\n        if (ar === 0.0e+0) {\n          goToLabel = 10;break;\n        }\n        if (ai === 0.0e+0) {\n          goToLabel = 20;break;\n        }\n        dtheta = Math.atan(ai / ar);\n        if (dtheta <= 0.0e+0) {\n          goToLabel = 40;break;\n        }\n        if (ar < 0.0e+0) dtheta = dtheta - dpi;\n        goToLabel = 50;break;\n      case 10:\n        if (ai === 0.0e+0) {\n          goToLabel = 60;break;\n        }\n        bi = dhpi;\n        br = Math.log(Math.abs(ai));\n        if (ai < 0.0e+0) bi = -bi;\n        break mainExecutionLoop;\n      case 20:\n        if (ar > 0.0e+0) {\n          goToLabel = 30;break;\n        }\n        br = Math.log(Math.abs(ar));\n        bi = dpi;\n        break mainExecutionLoop;\n      case 30:\n        br = Math.log(ar);\n        bi = 0.0e+0;\n        break mainExecutionLoop;\n      case 40:\n        if (ar < 0.0e+0) dtheta = dtheta + dpi;\n      case 50:\n        zm = (0, _zabs.azabs)(ar, ai);\n        br = Math.log(zm);\n        bi = dtheta;\n        break mainExecutionLoop;\n      case 60:\n\n        ierr = 1;\n      default:\n        break mainExecutionLoop;\n    }\n  }\n  return [br, bi, ierr];\n} /* eslint-disable no-labels */\n/* eslint-disable no-fallthrough */\n//     DOUBLE PRECISION COMPLEX LOGARITHM B=CLOG(A)\n//     IERR=0,NORMAL RETURN      IERR=1, Z=CMPLX(0.0,0.0)\n},{\"./zabs.js\":11}],30:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); /* eslint-disable no-labels */\n/* eslint-disable no-fallthrough */\n// SUBROUTINE ZMLRI(ZR, ZI, FNU, KODE, N, YR, YI, NZ, TOL)\n// ***BEGIN PROLOGUE  ZMLRI\n// ***REFER TO  ZBESI,ZBESK\n//\n//      ZMLRI COMPUTES THE I BESSEL FUNCTION FOR RE(Z).GE.0.0 BY THE\n//      MILLER ALGORITHM NORMALIZED BY A NEUMANN SERIES.\n//\n// ***ROUTINES CALLED  DGAMLN,D1MACH,AZABS,AZEXP,AZLOG,ZMLT\n// ***END PROLOGUE  ZMLRI\n\n\nexports.zmlri = zmlri;\n\nvar _dgamln = require('./dgamln.js');\n\nvar _d1mach = require('../../utils/fortran-utils/d1mach.js');\n\nvar _zabs = require('./zabs.js');\n\nvar _zexp = require('./zexp.js');\n\nvar _zlog = require('./zlog.js');\n\nvar _zmlt3 = require('./zmlt.js');\n\nfunction zmlri(zr, zi, fnu, kode, n, yr, yi, tol) {\n  var ack = void 0,\n      ak = void 0,\n      ap = void 0,\n      at = void 0,\n      az = void 0,\n      bk = void 0,\n      cki = void 0,\n      ckr = void 0,\n      cnormi = void 0,\n      cnormr = void 0,\n      conei = void 0,\n      coner = void 0,\n      fkap = void 0,\n      fkk = void 0,\n      flam = void 0,\n      fnf = void 0,\n      pti = void 0,\n      ptr = void 0,\n      p1i = void 0,\n      p1r = void 0,\n      p2i = void 0,\n      p2r = void 0,\n      raz = void 0,\n      rho = void 0,\n      rho2 = void 0,\n      rzi = void 0,\n      rzr = void 0,\n      scle = void 0,\n      sti = void 0,\n      str = void 0,\n      sumi = void 0,\n      sumr = void 0,\n      tfnf = void 0,\n      tst = void 0,\n      zeroi = void 0,\n      zeror = void 0,\n      i = void 0,\n      iaz = void 0,\n      ifnu = void 0,\n      inu = void 0,\n      itime = void 0,\n      k = void 0,\n      kk = void 0,\n      km = void 0,\n      m = void 0,\n      nz = void 0;\n  zeror = 0.0;\n  zeroi = 0.0;\n  coner = 1.0;\n  conei = 0.0;\n\n\n  var goToLabel = 0;\n  mainExecutionLoop: while (true) {\n    mainSwitch: switch (goToLabel) {\n      case 0:\n        scle = (0, _d1mach.d1mach)(1) / tol;\n        nz = 0;\n        az = (0, _zabs.azabs)(zr, zi);\n        iaz = Math.trunc(az);\n        ifnu = Math.trunc(fnu);\n        inu = ifnu + n - 1;\n        at = iaz + 1.0;\n        raz = 1.0 / az;\n        str = zr * raz;\n        sti = -zi * raz;\n        ckr = str * at * raz;\n        cki = sti * at * raz;\n        rzr = (str + str) * raz;\n        rzi = (sti + sti) * raz;\n        p1r = zeror;\n        p1i = zeroi;\n        p2r = coner;\n        p2i = conei;\n        ack = (at + 1.0) * raz;\n        rho = ack + Math.sqrt(ack * ack - 1.0);\n        rho2 = rho * rho;\n        tst = (rho2 + rho2) / ((rho2 - 1.0) * (rho - 1.0));\n        tst = tst / tol;\n        // c-----------------------------------------------------------------------\n        // c     compute relative truncation error index for series\n        // c-----------------------------------------------------------------------\n        ak = at;\n        // do 10 i=1,80\n        for (i = 1; i <= 80; i++) {\n          ptr = p2r;\n          pti = p2i;\n          p2r = p1r - (ckr * ptr - cki * pti);\n          p2i = p1i - (cki * ptr + ckr * pti);\n          p1r = ptr;\n          p1i = pti;\n          ckr = ckr + rzr;\n          cki = cki + rzi;\n          ap = (0, _zabs.azabs)(p2r, p2i);\n          if (ap > tst * ak * ak) {\n            goToLabel = 20;break mainSwitch;\n          }\n          ak = ak + 1.0;\n        }\n        goToLabel = 110;break;\n      case 20:\n        i = i + 1;\n        k = 0;\n        if (inu < iaz) {\n          goToLabel = 40;break;\n        }\n        // c-----------------------------------------------------------------------\n        // c     compute relative truncation error for ratios\n        // c-----------------------------------------------------------------------\n        p1r = zeror;\n        p1i = zeroi;\n        p2r = coner;\n        p2i = conei;\n        at = inu + 1.0;\n        str = zr * raz;\n        sti = -zi * raz;\n        ckr = str * at * raz;\n        cki = sti * at * raz;\n        ack = at * raz;\n        tst = Math.sqrt(ack / tol);\n        itime = 1;\n        // do 30 k=1,80\n        for (k = 1; k <= 80; k++) {\n          ptr = p2r;\n          pti = p2i;\n          p2r = p1r - (ckr * ptr - cki * pti);\n          p2i = p1i - (ckr * pti + cki * ptr);\n          p1r = ptr;\n          p1i = pti;\n          ckr = ckr + rzr;\n          cki = cki + rzi;\n          ap = (0, _zabs.azabs)(p2r, p2i);\n          if (ap < tst) continue;\n          if (itime === 2) {\n            goToLabel = 40;break;\n          }\n          ack = (0, _zabs.azabs)(ckr, cki);\n          flam = ack + Math.sqrt(ack * ack - 1.0);\n          fkap = ap / (0, _zabs.azabs)(p1r, p1i);\n          rho = Math.min(flam, fkap);\n          tst = tst * Math.sqrt(rho / (rho * rho - 1.0));\n          itime = 2;\n        }\n        if (goToLabel < 40) {\n          goToLabel = 110;break;\n        }\n      case 40:\n        // c-----------------------------------------------------------------------\n        // c     backward recurrence and sum normalizing relation\n        // c-----------------------------------------------------------------------\n        k = k + 1;\n        kk = Math.max(i + iaz, k + inu);\n        fkk = kk;\n        p1r = zeror;\n        p1i = zeroi;\n        // c-----------------------------------------------------------------------\n        // c     scale p2 and sum by scle\n        // c-----------------------------------------------------------------------\n        p2r = scle;\n        p2i = zeroi;\n        fnf = fnu - ifnu;\n        tfnf = fnf + fnf;\n        bk = (0, _dgamln.dgamln)(fkk + tfnf + 1.0) - (0, _dgamln.dgamln)(fkk + 1.0) - (0, _dgamln.dgamln)(tfnf + 1.0);\n        bk = Math.exp(bk);\n        sumr = zeror;\n        sumi = zeroi;\n        km = kk - inu;\n        // do 50 i=1,km\n        for (i = 1; i <= km; i++) {\n          ptr = p2r;\n          pti = p2i;\n          p2r = p1r + (fkk + fnf) * (rzr * ptr - rzi * pti);\n          p2i = p1i + (fkk + fnf) * (rzi * ptr + rzr * pti);\n          p1r = ptr;\n          p1i = pti;\n          ak = 1.0 - tfnf / (fkk + tfnf);\n          ack = bk * ak;\n          sumr = sumr + (ack + bk) * p1r;\n          sumi = sumi + (ack + bk) * p1i;\n          bk = ack;\n          fkk = fkk - 1.0;\n        }\n        yr[n - 1] = p2r;\n        yi[n - 1] = p2i;\n        if (n === 1) {\n          goToLabel = 70;break;\n        }\n        // do 60 i=2,n\n        for (i = 2; i <= n; i++) {\n          ptr = p2r;\n          pti = p2i;\n          p2r = p1r + (fkk + fnf) * (rzr * ptr - rzi * pti);\n          p2i = p1i + (fkk + fnf) * (rzi * ptr + rzr * pti);\n          p1r = ptr;\n          p1i = pti;\n          ak = 1.0 - tfnf / (fkk + tfnf);\n          ack = bk * ak;\n          sumr = sumr + (ack + bk) * p1r;\n          sumi = sumi + (ack + bk) * p1i;\n          bk = ack;\n          fkk = fkk - 1.0;\n          m = n - i + 1;\n          yr[m - 1] = p2r;\n          yi[m - 1] = p2i;\n        }\n      case 70:\n        if (ifnu <= 0) {\n          goToLabel = 90;break;\n        }\n        // do 80 i=1,ifnu\n        for (i = 1; i <= fnu; i++) {\n          ptr = p2r;\n          pti = p2i;\n          p2r = p1r + (fkk + fnf) * (rzr * ptr - rzi * pti);\n          p2i = p1i + (fkk + fnf) * (rzr * pti + rzi * ptr);\n          p1r = ptr;\n          p1i = pti;\n          ak = 1.0 - tfnf / (fkk + tfnf);\n          ack = bk * ak;\n          sumr = sumr + (ack + bk) * p1r;\n          sumi = sumi + (ack + bk) * p1i;\n          bk = ack;\n          fkk = fkk - 1.0;\n        }\n      case 90:\n        ptr = zr;\n        pti = zi;\n        if (kode === 2) ptr = zeror;\n\n        var _azlog = (0, _zlog.azlog)(rzr, rzi);\n\n        var _azlog2 = _slicedToArray(_azlog, 2);\n\n        str = _azlog2[0];\n        sti = _azlog2[1];\n\n        p1r = -fnf * str + ptr;\n        p1i = -fnf * sti + pti;\n        ap = (0, _dgamln.dgamln)(1.0 + fnf);\n        ptr = p1r - ap;\n        pti = p1i;\n        // c-----------------------------------------------------------------------\n        // c     the division cexp(pt)/(sum+p2) is altered to avoid overflow\n        // c     in the denominator by squaring large quantities\n        // c-----------------------------------------------------------------------\n        p2r = p2r + sumr;\n        p2i = p2i + sumi;\n        ap = (0, _zabs.azabs)(p2r, p2i);\n        p1r = 1.0 / ap;\n\n        var _azexp = (0, _zexp.azexp)(ptr, pti);\n\n        var _azexp2 = _slicedToArray(_azexp, 2);\n\n        str = _azexp2[0];\n        sti = _azexp2[1];\n\n        ckr = str * p1r;\n        cki = sti * p1r;\n        ptr = p2r * p1r;\n        pti = -p2i * p1r;\n\n        // do 100 i=1,n\n        var _zmlt = (0, _zmlt3.zmlt)(ckr, cki, ptr, pti);\n\n        var _zmlt2 = _slicedToArray(_zmlt, 2);\n\n        cnormr = _zmlt2[0];\n        cnormi = _zmlt2[1];\n        for (i = 1; i <= n; i++) {\n          str = yr[i - 1] * cnormr - yi[i - 1] * cnormi;\n          yi[i - 1] = yr[i - 1] * cnormi + yi[i - 1] * cnormr;\n          yr[i - 1] = str;\n        }\n        break mainExecutionLoop;\n      case 110:\n        nz = -2;\n      default:\n        break mainExecutionLoop;\n    }\n  }\n\n  return nz;\n}\n},{\"../../utils/fortran-utils/d1mach.js\":91,\"./dgamln.js\":10,\"./zabs.js\":11,\"./zexp.js\":27,\"./zlog.js\":29,\"./zmlt.js\":31}],31:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.zmlt = zmlt;\n// SUBROUTINE ZMLT(AR, AI, BR, BI, CR, CI)\n// ***BEGIN PROLOGUE  ZMLT\n// ***REFER TO  ZBESH,ZBESI,ZBESJ,ZBESK,ZBESY,ZAIRY,ZBIRY\n//\n//      DOUBLE PRECISION COMPLEX MULTIPLY, C=A*B.\n//\n// ***ROUTINES CALLED  (NONE)\n// ***END PROLOGUE  ZMLT\nfunction zmlt(ar, ai, br, bi) {\n  return [ar * br - ai * bi, ar * bi + ai * br];\n}\n},{}],32:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); /* eslint-disable no-labels */\n/* eslint-disable no-fallthrough */\n// SUBROUTINE ZRATI(ZR, ZI, FNU, N, CYR, CYI, TOL)\n// ***BEGIN PROLOGUE  ZRATI\n// ***REFER TO  ZBESI,ZBESK,ZBESH\n//\n//      ZRATI COMPUTES RATIOS OF I BESSEL FUNCTIONS BY BACKWARD\n//      RECURRENCE.  THE STARTING INDEX IS DETERMINED BY FORWARD\n//      RECURRENCE AS DESCRIBED IN J. RES. OF NAT. BUR. OF STANDARDS-B,\n//      MATHEMATICAL SCIENCES, VOL 77B, P111-114, SEPTEMBER, 1973,\n//      BESSEL FUNCTIONS I AND J OF COMPLEX ARGUMENT AND INTEGER ORDER,\n//      BY D. J. SOOKNE.\n//\n// ***ROUTINES CALLED  AZABS,ZDIV\n// ***END PROLOGUE  ZRATI\n\n\nexports.zrati = zrati;\n\nvar _zabs = require('./zabs.js');\n\nvar _zdiv3 = require('./zdiv.js');\n\nfunction zrati(zr, zi, fnu, n, cyr, cyi, tol) {\n  var ak = void 0,\n      amagz = void 0,\n      ap1 = void 0,\n      ap2 = void 0,\n      arg = void 0,\n      az = void 0,\n      cdfnui = void 0,\n      cdfnur = void 0,\n      conei = void 0,\n      coner = void 0,\n      czeroi = void 0,\n      czeror = void 0,\n      dfnu = void 0,\n      fdnu = void 0,\n      flam = void 0,\n      fnup = void 0,\n      pti = void 0,\n      ptr = void 0,\n      p1i = void 0,\n      p1r = void 0,\n      p2i = void 0,\n      p2r = void 0,\n      rak = void 0,\n      rap1 = void 0,\n      rho = void 0,\n      rt2 = void 0,\n      rzi = void 0,\n      rzr = void 0,\n      test = void 0,\n      test1 = void 0,\n      tti = void 0,\n      ttr = void 0,\n      t1i = void 0,\n      t1r = void 0,\n      i = void 0,\n      id = void 0,\n      idnu = void 0,\n      inu = void 0,\n      itime = void 0,\n      k = void 0,\n      kk = void 0,\n      magz = void 0;\n\n  czeror = 0.0;\n  czeroi = 0.0;\n  coner = 1.0;\n  conei = 0.0;\n  rt2 = 1.41421356237309505;\n\n\n  var goToLabel = 0;\n  mainExecutionLoop: while (true) {\n    switch (goToLabel) {\n      case 0:\n        az = (0, _zabs.azabs)(zr, zi);\n        inu = Math.trunc(fnu);\n        idnu = inu + n - 1;\n        magz = Math.trunc(az);\n        amagz = magz + 1;\n        fdnu = idnu;\n        fnup = Math.max(amagz, fdnu);\n        id = idnu - magz - 1;\n        itime = 1;\n        k = 1;\n        ptr = 1.0 / az;\n        rzr = ptr * (zr + zr) * ptr;\n        rzi = -ptr * (zi + zi) * ptr;\n        t1r = rzr * fnup;\n        t1i = rzi * fnup;\n        p2r = -t1r;\n        p2i = -t1i;\n        p1r = coner;\n        p1i = conei;\n        t1r = t1r + rzr;\n        t1i = t1i + rzi;\n        if (id > 0) id = 0;\n        ap2 = (0, _zabs.azabs)(p2r, p2i);\n        ap1 = (0, _zabs.azabs)(p1r, p1i);\n        // c-----------------------------------------------------------------------\n        // c     the overflow test on k(fnu+i-1,z) before the call to cbknu\n        // c     guarantees that p2 is on scale. scale test1 and all subsequent\n        // c     p2 values by ap1 to ensure that an overflow does not occur\n        // c     prematurely.\n        // c-----------------------------------------------------------------------\n        arg = (ap2 + ap2) / (ap1 * tol);\n        test1 = Math.sqrt(arg);\n        test = test1;\n        rap1 = 1.0 / ap1;\n        p1r = p1r * rap1;\n        p1i = p1i * rap1;\n        p2r = p2r * rap1;\n        p2i = p2i * rap1;\n        ap2 = ap2 * rap1;\n      case 10:\n        k = k + 1;\n        ap1 = ap2;\n        ptr = p2r;\n        pti = p2i;\n        p2r = p1r - (t1r * ptr - t1i * pti);\n        p2i = p1i - (t1r * pti + t1i * ptr);\n        p1r = ptr;\n        p1i = pti;\n        t1r = t1r + rzr;\n        t1i = t1i + rzi;\n        ap2 = (0, _zabs.azabs)(p2r, p2i);\n        if (ap1 <= test) {\n          goToLabel = 10;break;\n        }\n        if (itime === 2) {\n          goToLabel = 20;break;\n        }\n        ak = (0, _zabs.azabs)(t1r, t1i) * 0.5;\n        flam = ak + Math.sqrt(ak * ak - 1.0);\n        rho = Math.min(ap2 / ap1, flam);\n        test = test1 * Math.sqrt(rho / (rho * rho - 1.0));\n        itime = 2;\n        goToLabel = 10;break;\n      case 20:\n        kk = k + 1 - id;\n        ak = kk;\n        t1r = ak;\n        t1i = czeroi;\n        dfnu = fnu + (n - 1);\n        p1r = 1.0 / ap2;\n        p1i = czeroi;\n        p2r = czeror;\n        p2i = czeroi;\n        // do 30 i=1,kk\n        for (i = 1; i <= kk; i++) {\n          ptr = p1r;\n          pti = p1i;\n          rap1 = dfnu + t1r;\n          ttr = rzr * rap1;\n          tti = rzi * rap1;\n          p1r = ptr * ttr - pti * tti + p2r;\n          p1i = ptr * tti + pti * ttr + p2i;\n          p2r = ptr;\n          p2i = pti;\n          t1r = t1r - coner;\n        }\n        // 30 continue\n        if (p1r !== czeror || p1i !== czeroi) {\n          goToLabel = 40;break;\n        }\n        p1r = tol;\n        p1i = tol;\n      case 40:\n        var _zdiv = (0, _zdiv3.zdiv)(p2r, p2i, p1r, p1i);\n\n        var _zdiv2 = _slicedToArray(_zdiv, 2);\n\n        cyr[n - 1] = _zdiv2[0];\n        cyi[n - 1] = _zdiv2[1];\n\n        if (n === 1) break mainExecutionLoop;\n        k = n - 1;\n        ak = k;\n        t1r = ak;\n        t1i = czeroi;\n        cdfnur = fnu * rzr;\n        cdfnui = fnu * rzi;\n        // do 60 i=2,n\n        for (i = 2; i <= n; i++) {\n          ptr = cdfnur + (t1r * rzr - t1i * rzi) + cyr[k];\n          pti = cdfnui + (t1r * rzi + t1i * rzr) + cyi[k];\n          ak = (0, _zabs.azabs)(ptr, pti);\n          if (ak !== czeror) {\n            // go to 50\n          } else {\n            ptr = tol;\n            pti = tol;\n            ak = tol * rt2;\n          }\n          // 50   continue\n          rak = coner / ak;\n          cyr[k - 1] = rak * ptr * rak;\n          cyi[k - 1] = -rak * pti * rak;\n          t1r = t1r - coner;\n          k = k - 1;\n        }\n      // 60 continue\n      default:\n        break mainExecutionLoop;\n    }\n  }\n}\n},{\"./zabs.js\":11,\"./zdiv.js\":26}],33:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); // SUBROUTINE ZS1S2(ZRR, ZRI, S1R, S1I, S2R, S2I, NZ, ASCLE, ALIM, IUF)\n// ***BEGIN PROLOGUE  ZS1S2\n// ***REFER TO  ZBESK,ZAIRY\n//\n//      ZS1S2 TESTS FOR A POSSIBLE UNDERFLOW RESULTING FROM THE\n//      ADDITION OF THE I AND K FUNCTIONS IN THE ANALYTIC CON-\n//      TINUATION FORMULA WHERE S1=K FUNCTION AND S2=I FUNCTION.\n//      ON KODE=1 THE I AND K FUNCTIONS ARE DIFFERENT ORDERS OF\n//      MAGNITUDE, BUT FOR KODE=2 THEY CAN BE OF THE SAME ORDER\n//      OF MAGNITUDE AND THE MAXIMUM MUST BE AT LEAST ONE\n//      PRECISION ABOVE THE UNDERFLOW LIMIT.\n//\n// ***ROUTINES CALLED  AZABS,AZEXP,AZLOG\n// ***END PROLOGUE  ZS1S2\n\n\nexports.zs1s2 = zs1s2;\n\nvar _zabs = require('./zabs.js');\n\nvar _zexp = require('./zexp.js');\n\nvar _zlog = require('./zlog.js');\n\nfunction zs1s2(zrr, zri, s1r, s1i, s2r, s2i, ascle, alim, iuf) {\n  var aa = void 0,\n      aln = void 0,\n      as1 = void 0,\n      as2 = void 0,\n      c1i = void 0,\n      c1r = void 0,\n      s1di = void 0,\n      s1dr = void 0,\n      zeroi = void 0,\n      zeror = void 0,\n      nz = void 0;\n  zeror = 0;\n  zeroi = 0;\n  nz = 0;\n  as1 = (0, _zabs.azabs)(s1r, s1i);\n  as2 = (0, _zabs.azabs)(s2r, s2i);\n  if (s1r === 0 && s1i === 0 || as1 === 0) {\n    // go to 10\n  } else {\n    aln = -zrr - zrr + Math.log(as1);\n    s1dr = s1r;\n    s1di = s1i;\n    s1r = zeror;\n    s1i = zeroi;\n    as1 = zeror;\n    if (aln < -alim) {\n      // go to 10\n    } else {\n      var _azlog = (0, _zlog.azlog)(s1dr, s1di);\n\n      var _azlog2 = _slicedToArray(_azlog, 2);\n\n      c1r = _azlog2[0];\n      c1i = _azlog2[1];\n\n      c1r = c1r - zrr - zrr;\n      c1i = c1i - zri - zri;\n\n      var _azexp = (0, _zexp.azexp)(c1r, c1i);\n\n      var _azexp2 = _slicedToArray(_azexp, 2);\n\n      s1r = _azexp2[0];\n      s1i = _azexp2[1];\n\n      as1 = (0, _zabs.azabs)(s1r, s1i);\n      iuf = iuf + 1;\n    }\n  }\n  // 10 continue\n  aa = Math.max(as1, as2);\n  if (aa > ascle) {\n    return [s1r, s1i, s2r, s2i, nz, iuf];\n  }\n  s1r = zeror;\n  s1i = zeroi;\n  s2r = zeror;\n  s2i = zeroi;\n  nz = 1;\n  iuf = 0;\n  return [s1r, s1i, s2r, s2i, nz, iuf];\n}\n},{\"./zabs.js\":11,\"./zexp.js\":27,\"./zlog.js\":29}],34:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); /* eslint-disable no-labels */\n/* eslint-disable no-fallthrough */\n// SUBROUTINE ZSERI(ZR, ZI, FNU, KODE, N, YR, YI, NZ, TOL, ELIM, ALIM)\n// ***BEGIN PROLOGUE  ZSERI\n// ***REFER TO  ZBESI,ZBESK\n//\n//      ZSERI COMPUTES THE I BESSEL FUNCTION FOR REAL(Z).GE.0.0 BY\n//      MEANS OF THE POWER SERIES FOR LARGE CABS(Z) IN THE\n//      REGION CABS(Z).LE.2*SQRT(FNU+1). NZ=0 IS A NORMAL RETURN.\n//      NZ.GT.0 MEANS THAT THE LAST NZ COMPONENTS WERE SET TO ZERO\n//      DUE TO UNDERFLOW. NZ.LT.0 MEANS UNDERFLOW OCCURRED, BUT THE\n//      CONDITION CABS(Z).LE.2*SQRT(FNU+1) WAS VIOLATED AND THE\n//      COMPUTATION MUST BE COMPLETED IN ANOTHER ROUTINE WITH N=N-ABS(NZ).\n//\n// ***ROUTINES CALLED  DGAMLN,D1MACH,ZUCHK,AZABS,ZDIV,AZLOG,ZMLT\n// ***END PROLOGUE  ZSERI\n\n\nexports.zseri = zseri;\n\nvar _dgamln = require('./dgamln.js');\n\nvar _d1mach = require('../../utils/fortran-utils/d1mach.js');\n\nvar _zuchk = require('./zuchk.js');\n\nvar _zabs = require('./zabs.js');\n\nvar _zdiv3 = require('./zdiv.js');\n\nvar _zlog = require('./zlog.js');\n\nvar _zmlt3 = require('./zmlt.js');\n\nfunction zseri(zr, zi, fnu, kode, n, yr, yi, tol, elim, alim) {\n  var aa = void 0,\n      acz = void 0,\n      ak = void 0,\n      ak1i = void 0,\n      ak1r = void 0,\n      arm = void 0,\n      ascle = void 0,\n      atol = void 0,\n      az = void 0,\n      cki = void 0,\n      ckr = void 0,\n      coefi = void 0,\n      coefr = void 0,\n      conei = void 0,\n      coner = void 0,\n      crscr = void 0,\n      czi = void 0,\n      czr = void 0,\n      dfnu = void 0,\n      fnup = void 0,\n      hzi = void 0,\n      hzr = void 0,\n      raz = void 0,\n      rs = void 0,\n      rtr1 = void 0,\n      rzi = void 0,\n      rzr = void 0,\n      s = void 0,\n      ss = void 0,\n      sti = void 0,\n      str = void 0,\n      s1i = void 0,\n      s1r = void 0,\n      s2i = void 0,\n      s2r = void 0,\n      wi = void 0,\n      wr = void 0,\n      zeroi = void 0,\n      zeror = void 0,\n      i = void 0,\n      ib = void 0,\n      iflag = void 0,\n      il = void 0,\n      k = void 0,\n      l = void 0,\n      m = void 0,\n      nn = void 0,\n      nz = void 0,\n      nw = void 0;\n\n  wr = new Array(2);\n  wi = new Array(2);\n\n  zeror = 0.0;\n  zeroi = 0.0;\n  coner = 1.0;\n  conei = 0.0;\n\n\n  var goToLabel = 0;\n  mainExecutionLoop: while (true) {\n    switch (goToLabel) {\n      case 0:\n\n        nz = 0;\n        az = (0, _zabs.azabs)(zr, zi);\n        if (az === 0.0) {\n          goToLabel = 160;break;\n        }\n        arm = 1.0e+3 * (0, _d1mach.d1mach)(1);\n        rtr1 = Math.sqrt(arm);\n        crscr = 1.0;\n        iflag = 0;\n        if (az < arm) {\n          goToLabel = 150;break;\n        }\n        hzr = 0.5 * zr;\n        hzi = 0.5 * zi;\n        czr = zeror;\n        czi = zeroi;\n        if (az <= rtr1) {\n          goToLabel = 10;break;\n        }\n\n        var _zmlt = (0, _zmlt3.zmlt)(hzr, hzi, hzr, hzi);\n\n        var _zmlt2 = _slicedToArray(_zmlt, 2);\n\n        czr = _zmlt2[0];\n        czi = _zmlt2[1];\n\n      case 10:\n        acz = (0, _zabs.azabs)(czr, czi);\n        nn = n;\n\n        var _azlog = (0, _zlog.azlog)(hzr, hzi);\n\n        var _azlog2 = _slicedToArray(_azlog, 2);\n\n        ckr = _azlog2[0];\n        cki = _azlog2[1];\n\n      case 20:\n        dfnu = fnu + (nn - 1);\n        fnup = dfnu + 1.0;\n        // c-----------------------------------------------------------------------\n        // c     underflow test\n        // c-----------------------------------------------------------------------\n        ak1r = ckr * dfnu;\n        ak1i = cki * dfnu;\n        ak = (0, _dgamln.dgamln)(fnup);\n        ak1r = ak1r - ak;\n        if (kode === 2) ak1r = ak1r - zr;\n        if (ak1r > -elim) {\n          goToLabel = 40;break;\n        }\n      case 30:\n        nz = nz + 1;\n        yr[nn - 1] = zeror;\n        yi[nn - 1] = zeroi;\n        if (acz > dfnu) {\n          goToLabel = 190;break;\n        }\n        nn = nn - 1;\n        if (nn === 0) break mainExecutionLoop;\n        goToLabel = 20;break;\n      case 40:\n        if (ak1r > -alim) {\n          goToLabel = 50;break;\n        }\n        iflag = 1;\n        ss = 1.0 / tol;\n        crscr = tol;\n        ascle = arm * ss;\n      case 50:\n        aa = Math.exp(ak1r);\n        if (iflag === 1) aa = aa * ss;\n        coefr = aa * Math.cos(ak1i);\n        coefi = aa * Math.sin(ak1i);\n        atol = tol * acz / fnup;\n        il = Math.min(2, nn);\n        // do 90 i=1,il\n        for (i = 1; i <= il; i++) {\n          dfnu = fnu + (nn - i);\n          fnup = dfnu + 1.0;\n          s1r = coner;\n          s1i = conei;\n          if (acz < tol * fnup) {\n            // go to 70\n          } else {\n            ak1r = coner;\n            ak1i = conei;\n            ak = fnup + 2.0;\n            s = fnup;\n            aa = 2.0;\n            // 60   continue\n            while (aa > atol) {\n              rs = 1.0 / s;\n              str = ak1r * czr - ak1i * czi;\n              sti = ak1r * czi + ak1i * czr;\n              ak1r = str * rs;\n              ak1i = sti * rs;\n              s1r = s1r + ak1r;\n              s1i = s1i + ak1i;\n              s = s + ak;\n              ak = ak + 2.0;\n              aa = aa * acz * rs;\n            }\n            // if (aa > atol) go to 60\n          }\n          // 70   continue\n          s2r = s1r * coefr - s1i * coefi;\n          s2i = s1r * coefi + s1i * coefr;\n          wr[i - 1] = s2r;\n          wi[i - 1] = s2i;\n          if (iflag === 0) {\n            // go to 80\n          } else {\n            nw = (0, _zuchk.zuchk)(s2r, s2i, ascle, tol);\n            if (nw !== 0) {\n              goToLabel = 30;break;\n            }\n          }\n          // 80   continue\n          m = nn - i + 1;\n          yr[m - 1] = s2r * crscr;\n          yi[m - 1] = s2i * crscr;\n          if (i === il) continue;\n\n          var _zdiv = (0, _zdiv3.zdiv)(coefr, coefi, hzr, hzi);\n\n          var _zdiv2 = _slicedToArray(_zdiv, 2);\n\n          str = _zdiv2[0];\n          sti = _zdiv2[1];\n\n          coefr = str * dfnu;\n          coefi = sti * dfnu;\n        }\n        if (goToLabel === 30) break;\n      case 90:\n        if (nn <= 2) break mainExecutionLoop;\n        k = nn - 2;\n        ak = k;\n        raz = 1.0 / az;\n        str = zr * raz;\n        sti = -zi * raz;\n        rzr = (str + str) * raz;\n        rzi = (sti + sti) * raz;\n        if (iflag === 1) {\n          goToLabel = 120;break;\n        }\n        ib = 3;\n      case 100:\n        // do 110 i=ib,nn\n        for (i = ib; i <= nn; i++) {\n          yr[k - 1] = (ak + fnu) * (rzr * yr[k] - rzi * yi[k]) + yr[k + 1];\n          yi[k - 1] = (ak + fnu) * (rzr * yi[k] + rzi * yr[k]) + yi[k + 1];\n          ak = ak - 1.0;\n          k = k - 1;\n        }\n        break mainExecutionLoop;\n      // c-----------------------------------------------------------------------\n      // c     recur backward with scaled values\n      // c-----------------------------------------------------------------------\n      case 120:\n        // c-----------------------------------------------------------------------\n        // c     exp(-alim)=exp(-elim)/tol=approx. one precision above the\n        // c     underflow limit = ascle = d1mach(1)*ss*1.0e+3\n        // c-----------------------------------------------------------------------\n        s1r = wr[0];\n        s1i = wi[0];\n        s2r = wr[1];\n        s2i = wi[1];\n        // do 130 l=3,nn\n        for (l = 3; l <= nn; l++) {\n          ckr = s2r;\n          cki = s2i;\n          s2r = s1r + (ak + fnu) * (rzr * ckr - rzi * cki);\n          s2i = s1i + (ak + fnu) * (rzr * cki + rzi * ckr);\n          s1r = ckr;\n          s1i = cki;\n          ckr = s2r * crscr;\n          cki = s2i * crscr;\n          yr[k - 1] = ckr;\n          yi[k - 1] = cki;\n          ak = ak - 1.0;\n          k = k - 1;\n          if ((0, _zabs.azabs)(ckr, cki) > ascle) {\n            goToLabel = 140;break;\n          }\n        }\n        // 130 continue\n        if (goToLabel !== 140) break mainExecutionLoop;\n        ib = l + 1;\n        if (ib > nn) break mainExecutionLoop;\n        goToLabel = 100;break;\n      case 150:\n        nz = n;\n        if (fnu === 0.0) nz = nz - 1;\n      case 160:\n        yr[0] = zeror;\n        yi[0] = zeroi;\n        if (fnu !== 0.0) {\n          goToLabel = 170;break;\n        }\n        yr[0] = coner;\n        yi[0] = conei;\n      case 170:\n        if (n === 1) break mainExecutionLoop;\n        // do 180 i=2,n\n        for (i = 2; i <= n; i++) {\n          yr[i - 1] = zeror;\n          yi[i - 1] = zeroi;\n        }\n        // 180 continue\n        break mainExecutionLoop;\n      // c-----------------------------------------------------------------------\n      // c     return with nz < 0 if cabs(z*z/4) > fnu+n-nz-1 complete\n      // c     the calculation in cbinu with n=n-iabs(nz)\n      // c-----------------------------------------------------------------------\n      case 190:\n        nz = -nz;\n      default:\n        break mainExecutionLoop;\n    }\n  }\n\n  return nz;\n}\n},{\"../../utils/fortran-utils/d1mach.js\":91,\"./dgamln.js\":10,\"./zabs.js\":11,\"./zdiv.js\":26,\"./zlog.js\":29,\"./zmlt.js\":31,\"./zuchk.js\":37}],35:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.zshch = zshch;\n// SUBROUTINE ZSHCH(ZR, ZI, CSHR, CSHI, CCHR, CCHI)\n// ***BEGIN PROLOGUE  ZSHCH\n// ***REFER TO  ZBESK,ZBESH\n//\n//      ZSHCH COMPUTES THE COMPLEX HYPERBOLIC FUNCTIONS CSH=SINH(X+I*Y)\n//      AND CCH=COSH(X+I*Y), WHERE I**2=-1.\n//\n// ***ROUTINES CALLED  (NONE)\n// ***END PROLOGUE  ZSHCH\n//\nfunction zshch(zr, zi) {\n  var sh = Math.sinh(zr);\n  var ch = Math.cosh(zr);\n  var sn = Math.sin(zi);\n  var cn = Math.cos(zi);\n  //     [ cshr,  cshi,  cchr,  cchi]\n  return [sh * cn, ch * sn, ch * cn, sh * sn];\n}\n},{}],36:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.azsqrt = azsqrt;\n\nvar _zabs = require('./zabs.js');\n\nfunction azsqrt(ar, ai) {\n  var br = void 0,\n      bi = void 0,\n      zm = void 0,\n      dtheta = void 0,\n      dpi = void 0,\n      drt = void 0;\n  drt = 7.071067811865475244008443621e-1;\n  dpi = 3.141592653589793238462643383;\n\n\n  var goToLabel = 0;\n  mainExecutionLoop: while (true) {\n    switch (goToLabel) {\n      case 0:\n        zm = (0, _zabs.azabs)(ar, ai);\n        zm = Math.sqrt(zm);\n        if (ar === 0.0) {\n          goToLabel = 10;break;\n        }\n        if (ai === 0.0) {\n          goToLabel = 20;break;\n        }\n        dtheta = Math.atan(ai / ar);\n        if (dtheta <= 0.0) {\n          goToLabel = 40;break;\n        }\n        if (ar < 0.0) dtheta = dtheta - dpi;\n        goToLabel = 50;break;\n      case 10:\n        if (ai > 0.0) {\n          goToLabel = 60;break;\n        }\n        if (ai < 0.0) {\n          goToLabel = 70;break;\n        }\n        br = 0.0;\n        bi = 0.0;\n        break mainExecutionLoop;\n      case 20:\n        if (ar > 0.0) {\n          goToLabel = 30;break;\n        }\n        br = 0.0;\n        bi = Math.sqrt(Math.abs(ar));\n        break mainExecutionLoop;\n      case 30:\n        br = Math.sqrt(ar);\n        bi = 0.0;\n        break mainExecutionLoop;\n      case 40:\n        if (ar < 0.0) dtheta = dtheta + dpi;\n      case 50:\n        dtheta = dtheta * 0.5;\n        br = zm * Math.cos(dtheta);\n        bi = zm * Math.sin(dtheta);\n        break mainExecutionLoop;\n      case 60:\n        br = zm * drt;\n        bi = zm * drt;\n        break mainExecutionLoop;\n      case 70:\n        br = zm * drt;\n        bi = -zm * drt;\n      default:\n        break mainExecutionLoop;\n    }\n  }\n\n  return [br, bi];\n} /* eslint-disable no-labels */\n/* eslint-disable no-fallthrough */\n// SUBROUTINE AZSQRT(AR, AI, BR, BI)\n// ***BEGIN PROLOGUE  AZSQRT\n// ***REFER TO  ZBESH,ZBESI,ZBESJ,ZBESK,ZBESY,ZAIRY,ZBIRY\n//\n//      DOUBLE PRECISION COMPLEX SQUARE ROOT, B=CSQRT(A)\n//\n// ***ROUTINES CALLED  AZABS\n// ***END PROLOGUE  AZSQRT\n},{\"./zabs.js\":11}],37:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.zuchk = zuchk;\n/* eslint-disable no-labels */\n/* eslint-disable no-fallthrough */\n// SUBROUTINE ZUCHK(YR, YI, NZ, ASCLE, TOL)\n// ***BEGIN PROLOGUE  ZUCHK\n// ***REFER TO ZSERI,ZUOIK,ZUNK1,ZUNK2,ZUNI1,ZUNI2,ZKSCL\n//\n//       Y ENTERS AS A SCALED QUANTITY WHOSE MAGNITUDE IS GREATER THAN\n//       EXP(-ALIM)=ASCLE=1.0E+3*D1MACH(1)/TOL. THE TEST IS MADE TO SEE\n//       IF THE MAGNITUDE OF THE REAL OR IMAGINARY PART WOULD UNDERFLOW\n//       WHEN Y IS SCALED (BY TOL) TO ITS PROPER VALUE. Y IS ACCEPTED\n//       IF THE UNDERFLOW IS AT LEAST ONE PRECISION BELOW THE MAGNITUDE\n//       OF THE LARGEST COMPONENT; OTHERWISE THE PHASE ANGLE DOES NOT HAVE\n//       ABSOLUTE ACCURACY AND AN UNDERFLOW IS ASSUMED.\n//\n// ***ROUTINES CALLED  (NONE)\n// ***END PROLOGUE  ZUCHK\n//\n//      COMPLEX Y\nfunction zuchk(yr, yi, ascle, tol) {\n  var nz = void 0,\n      ss = void 0,\n      st = void 0,\n      wr = void 0,\n      wi = void 0;\n  nz = 0;\n  wr = Math.abs(yr);\n  wi = Math.abs(yi);\n  st = Math.min(wr, wi);\n  if (st > ascle) {\n    return nz;\n  }\n  ss = Math.max(wr, wi);\n  st = st / tol;\n  if (ss < st) {\n    nz = 1;\n  }\n  return nz;\n}\n},{}],38:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); /* eslint-disable no-labels */\n/* eslint-disable no-fallthrough */\n// SUBROUTINE ZUNHJ(ZR, ZI, FNU, IPMTR, TOL, PHIR, PHII, ARGR, ARGI,\n// * ZETA1R, ZETA1I, ZETA2R, ZETA2I, ASUMR, ASUMI, BSUMR, BSUMI)\n// ***BEGIN PROLOGUE  ZUNHJ\n// ***REFER TO  ZBESI,ZBESK\n//\n//      REFERENCES\n//          HANDBOOK OF MATHEMATICAL FUNCTIONS BY M. ABRAMOWITZ AND I.A.\n//          STEGUN, AMS55, NATIONAL BUREAU OF STANDARDS, 1965, CHAPTER 9.\n//\n//          ASYMPTOTICS AND SPECIAL FUNCTIONS BY F.W.J. OLVER, ACADEMIC\n//          PRESS, N.Y., 1974, PAGE 420\n//\n//      ABSTRACT\n//          ZUNHJ COMPUTES PARAMETERS FOR BESSEL FUNCTIONS C(FNU,Z) =\n//          J(FNU,Z), Y(FNU,Z) OR H(I,FNU,Z) I=1,2 FOR LARGE ORDERS FNU\n//          BY MEANS OF THE UNIFORM ASYMPTOTIC EXPANSION\n//\n//          C(FNU,Z)=C1*PHI*( ASUM*AIRY(ARG) + C2*BSUM*DAIRY(ARG) )\n//\n//          FOR PROPER CHOICES OF C1, C2, AIRY AND DAIRY WHERE AIRY IS\n//          AN AIRY FUNCTION AND DAIRY IS ITS DERIVATIVE.\n//\n//                (2/3)*FNU*ZETA**1.5 = ZETA1-ZETA2,\n//\n//          ZETA1=0.5*FNU*CLOG((1+W)/(1-W)), ZETA2=FNU*W FOR SCALING\n//          PURPOSES IN AIRY FUNCTIONS FROM CAIRY OR CBIRY.\n//\n//          MCONJ=SIGN OF AIMAG(Z), BUT IS AMBIGUOUS WHEN Z IS REAL AND\n//          MUST BE SPECIFIED. IPMTR=0 RETURNS ALL PARAMETERS. IPMTR=\n//          1 COMPUTES ALL EXCEPT ASUM AND BSUM.\n//\n// ***ROUTINES CALLED  AZABS,ZDIV,AZLOG,AZSQRT,D1MACH\n// ***END PROLOGUE  ZUNHJ\n//      COMPLEX ARG,ASUM,BSUM,CFNU,CONE,CR,CZERO,DR,P,PHI,PRZTH,PTFN,\n//     *RFN13,RTZTA,RZTH,SUMA,SUMB,TFN,T2,UP,W,W2,Z,ZA,ZB,ZC,ZETA,ZETA1,\n\n\nexports.zunhj = zunhj;\n\nvar _zabs = require('./zabs.js');\n\nvar _zdiv9 = require('./zdiv.js');\n\nvar _zlog = require('./zlog.js');\n\nvar _zsqrt = require('./zsqrt.js');\n\nvar _d1mach = require('../../utils/fortran-utils/d1mach.js');\n\nfunction zunhj(zr, zi, fnu, ipmtr, tol) {\n  var alfa = void 0,\n      ang = void 0,\n      ap = void 0,\n      ar = void 0,\n      argi = void 0,\n      argr = void 0,\n      asumi = void 0,\n      asumr = void 0,\n      atol = void 0,\n      aw2 = void 0,\n      azth = void 0,\n      beta = void 0,\n      br = void 0,\n      bsumi = void 0,\n      bsumr = void 0,\n      btol = void 0,\n      c = void 0,\n      conei = void 0,\n      coner = void 0,\n      cri = void 0,\n      crr = void 0,\n      dri = void 0,\n      drr = void 0,\n      ex1 = void 0,\n      ex2 = void 0,\n      fn13 = void 0,\n      fn23 = void 0,\n      gama = void 0,\n      gpi = void 0,\n      hpi = void 0,\n      phii = void 0,\n      phir = void 0,\n      pi = void 0,\n      pp = void 0,\n      pr = void 0,\n      przthi = void 0,\n      przthr = void 0,\n      ptfni = void 0,\n      ptfnr = void 0,\n      raw = void 0,\n      raw2 = void 0,\n      razth = void 0,\n      rfnu = void 0,\n      rfnu2 = void 0,\n      rfn13 = void 0,\n      rtzti = void 0,\n      rtztr = void 0,\n      rzthi = void 0,\n      rzthr = void 0,\n      sti = void 0,\n      str = void 0,\n      sumai = void 0,\n      sumar = void 0,\n      sumbi = void 0,\n      sumbr = void 0,\n      test = void 0,\n      tfni = void 0,\n      tfnr = void 0,\n      thpi = void 0,\n      tzai = void 0,\n      tzar = void 0,\n      t2i = void 0,\n      t2r = void 0,\n      upi = void 0,\n      upr = void 0,\n      wi = void 0,\n      wr = void 0,\n      w2i = void 0,\n      w2r = void 0,\n      zai = void 0,\n      zar = void 0,\n      zbi = void 0,\n      zbr = void 0,\n      zci = void 0,\n      zcr = void 0,\n      zeroi = void 0,\n      zeror = void 0,\n      zetai = void 0,\n      zetar = void 0,\n      zeta1i = void 0,\n      zeta1r = void 0,\n      zeta2i = void 0,\n      zeta2r = void 0,\n      zthi = void 0,\n      zthr = void 0,\n      ac = void 0,\n      ias = void 0,\n      ibs = void 0,\n      is = void 0,\n      j = void 0,\n      jr = void 0,\n      ju = void 0,\n      k = void 0,\n      kmax = void 0,\n      kp1 = void 0,\n      ks = void 0,\n      l = void 0,\n      lr = void 0,\n      lrp1 = void 0,\n      l1 = void 0,\n      l2 = void 0,\n      m = void 0;\n\n  ap = new Array(30);\n  pr = new Array(30);\n  pi = new Array(30);\n  upr = new Array(14);\n  upi = new Array(14);\n  crr = new Array(14);\n  cri = new Array(14);\n  drr = new Array(14);\n  dri = new Array(14);\n\n  ar = [1.00000000000000000e+00, 1.04166666666666667e-01, 8.35503472222222222e-02, 1.28226574556327160e-01, 2.91849026464140464e-01, 8.81627267443757652e-01, 3.32140828186276754e+00, 1.49957629868625547e+01, 7.89230130115865181e+01, 4.74451538868264323e+02, 3.20749009089066193e+03, 2.40865496408740049e+04, 1.98923119169509794e+05, 1.79190200777534383e+06];\n  br = [1.00000000000000000e+00, -1.45833333333333333e-01, -9.87413194444444444e-02, -1.43312053915895062e-01, -3.17227202678413548e-01, -9.42429147957120249e-01, -3.51120304082635426e+00, -1.57272636203680451e+01, -8.22814390971859444e+01, -4.92355370523670524e+02, -3.31621856854797251e+03, -2.48276742452085896e+04, -2.04526587315129788e+05, -1.83844491706820990e+06];\n  c = [1.00000000000000000e+00, -2.08333333333333333e-01, 1.25000000000000000e-01, 3.34201388888888889e-01, -4.01041666666666667e-01, 7.03125000000000000e-02, -1.02581259645061728e+00, 1.84646267361111111e+00, -8.91210937500000000e-01, 7.32421875000000000e-02, 4.66958442342624743e+00, -1.12070026162229938e+01, 8.78912353515625000e+00, -2.36408691406250000e+00, 1.12152099609375000e-01, -2.82120725582002449e+01, 8.46362176746007346e+01, -9.18182415432400174e+01, 4.25349987453884549e+01, -7.36879435947963170e+00, 2.27108001708984375e-01, 2.12570130039217123e+02, -7.65252468141181642e+02, 1.05999045252799988e+03, -6.99579627376132541e+02, 2.18190511744211590e+02, -2.64914304869515555e+01, 5.72501420974731445e-01, -1.91945766231840700e+03, 8.06172218173730938e+03, -1.35865500064341374e+04, 1.16553933368645332e+04, -5.30564697861340311e+03, 1.20090291321635246e+03, -1.08090919788394656e+02, 1.72772750258445740e+00, 2.02042913309661486e+04, -9.69805983886375135e+04, 1.92547001232531532e+05, -2.03400177280415534e+05, 1.22200464983017460e+05, -4.11926549688975513e+04, 7.10951430248936372e+03, -4.93915304773088012e+02, 6.07404200127348304e+00, -2.42919187900551333e+05, 1.31176361466297720e+06, -2.99801591853810675e+06, 3.76327129765640400e+06, -2.81356322658653411e+06, 1.26836527332162478e+06, -3.31645172484563578e+05, 4.52187689813627263e+04, -2.49983048181120962e+03, 2.43805296995560639e+01, 3.28446985307203782e+06, -1.97068191184322269e+07, 5.09526024926646422e+07, -7.41051482115326577e+07, 6.63445122747290267e+07, -3.75671766607633513e+07, 1.32887671664218183e+07, -2.78561812808645469e+06, 3.08186404612662398e+05, -1.38860897537170405e+04, 1.10017140269246738e+02, -4.93292536645099620e+07, 3.25573074185765749e+08, -9.39462359681578403e+08, 1.55359689957058006e+09, -1.62108055210833708e+09, 1.10684281682301447e+09, -4.95889784275030309e+08, 1.42062907797533095e+08, -2.44740627257387285e+07, 2.24376817792244943e+06, -8.40054336030240853e+04, 5.51335896122020586e+02, 8.14789096118312115e+08, -5.86648149205184723e+09, 1.86882075092958249e+10, -3.46320433881587779e+10, 4.12801855797539740e+10, -3.30265997498007231e+10, 1.79542137311556001e+10, -6.56329379261928433e+09, 1.55927986487925751e+09, -2.25105661889415278e+08, 1.73951075539781645e+07, -5.49842327572288687e+05, 3.03809051092238427e+03, -1.46792612476956167e+10, 1.14498237732025810e+11, -3.99096175224466498e+11, 8.19218669548577329e+11, -1.09837515608122331e+12, 1.00815810686538209e+12, -6.45364869245376503e+11, 2.87900649906150589e+11, -8.78670721780232657e+10, 1.76347306068349694e+10, -2.16716498322379509e+09, 1.43157876718888981e+08, -3.87183344257261262e+06, 1.82577554742931747e+04];\n  alfa = [-4.44444444444444444e-03, -9.22077922077922078e-04, -8.84892884892884893e-05, 1.65927687832449737e-04, 2.46691372741792910e-04, 2.65995589346254780e-04, 2.61824297061500945e-04, 2.48730437344655609e-04, 2.32721040083232098e-04, 2.16362485712365082e-04, 2.00738858762752355e-04, 1.86267636637545172e-04, 1.73060775917876493e-04, 1.61091705929015752e-04, 1.50274774160908134e-04, 1.40503497391269794e-04, 1.31668816545922806e-04, 1.23667445598253261e-04, 1.16405271474737902e-04, 1.09798298372713369e-04, 1.03772410422992823e-04, 9.82626078369363448e-05, 9.32120517249503256e-05, 8.85710852478711718e-05, 8.42963105715700223e-05, 8.03497548407791151e-05, 7.66981345359207388e-05, 7.33122157481777809e-05, 7.01662625163141333e-05, 6.72375633790160292e-05, 6.93735541354588974e-04, 2.32241745182921654e-04, -1.41986273556691197e-05, -1.16444931672048640e-04, -1.50803558053048762e-04, -1.55121924918096223e-04, -1.46809756646465549e-04, -1.33815503867491367e-04, -1.19744975684254051e-04, -1.06184319207974020e-04, -9.37699549891194492e-05, -8.26923045588193274e-05, -7.29374348155221211e-05, -6.44042357721016283e-05, -5.69611566009369048e-05, -5.04731044303561628e-05, -4.48134868008882786e-05, -3.98688727717598864e-05, -3.55400532972042498e-05, -3.17414256609022480e-05, -2.83996793904174811e-05, -2.54522720634870566e-05, -2.28459297164724555e-05, -2.05352753106480604e-05, -1.84816217627666085e-05, -1.66519330021393806e-05, -1.50179412980119482e-05, -1.35554031379040526e-05, -1.22434746473858131e-05, -1.10641884811308169e-05, -3.54211971457743841e-04, -1.56161263945159416e-04, 3.04465503594936410e-05, 1.30198655773242693e-04, 1.67471106699712269e-04, 1.70222587683592569e-04, 1.56501427608594704e-04, 1.36339170977445120e-04, 1.14886692029825128e-04, 9.45869093034688111e-05, 7.64498419250898258e-05, 6.07570334965197354e-05, 4.74394299290508799e-05, 3.62757512005344297e-05, 2.69939714979224901e-05, 1.93210938247939253e-05, 1.30056674793963203e-05, 7.82620866744496661e-06, 3.59257485819351583e-06, 1.44040049814251817e-07, -2.65396769697939116e-06, -4.91346867098485910e-06, -6.72739296091248287e-06, -8.17269379678657923e-06, -9.31304715093561232e-06, -1.02011418798016441e-05, -1.08805962510592880e-05, -1.13875481509603555e-05, -1.17519675674556414e-05, -1.19987364870944141e-05, 3.78194199201772914e-04, 2.02471952761816167e-04, -6.37938506318862408e-05, -2.38598230603005903e-04, -3.10916256027361568e-04, -3.13680115247576316e-04, -2.78950273791323387e-04, -2.28564082619141374e-04, -1.75245280340846749e-04, -1.25544063060690348e-04, -8.22982872820208365e-05, -4.62860730588116458e-05, -1.72334302366962267e-05, 5.60690482304602267e-06, 2.31395443148286800e-05, 3.62642745856793957e-05, 4.58006124490188752e-05, 5.24595294959114050e-05, 5.68396208545815266e-05, 5.94349820393104052e-05, 6.06478527578421742e-05, 6.08023907788436497e-05, 6.01577894539460388e-05, 5.89199657344698500e-05, 5.72515823777593053e-05, 5.52804375585852577e-05, 5.31063773802880170e-05, 5.08069302012325706e-05, 4.84418647620094842e-05, 4.60568581607475370e-05, -6.91141397288294174e-04, -4.29976633058871912e-04, 1.83067735980039018e-04, 6.60088147542014144e-04, 8.75964969951185931e-04, 8.77335235958235514e-04, 7.49369585378990637e-04, 5.63832329756980918e-04, 3.68059319971443156e-04, 1.88464535514455599e-04, 3.70663057664904149e-05, -8.28520220232137023e-05, -1.72751952869172998e-04, -2.36314873605872983e-04, -2.77966150694906658e-04, -3.02079514155456919e-04, -3.12594712643820127e-04, -3.12872558758067163e-04, -3.05678038466324377e-04, -2.93226470614557331e-04, -2.77255655582934777e-04, -2.59103928467031709e-04, -2.39784014396480342e-04, -2.20048260045422848e-04, -2.00443911094971498e-04, -1.81358692210970687e-04, -1.63057674478657464e-04, -1.45712672175205844e-04, -1.29425421983924587e-04, -1.14245691942445952e-04, 1.92821964248775885e-03, 1.35592576302022234e-03, -7.17858090421302995e-04, -2.58084802575270346e-03, -3.49271130826168475e-03, -3.46986299340960628e-03, -2.82285233351310182e-03, -1.88103076404891354e-03, -8.89531718383947600e-04, 3.87912102631035228e-06, 7.28688540119691412e-04, 1.26566373053457758e-03, 1.62518158372674427e-03, 1.83203153216373172e-03, 1.91588388990527909e-03, 1.90588846755546138e-03, 1.82798982421825727e-03, 1.70389506421121530e-03, 1.55097127171097686e-03, 1.38261421852276159e-03, 1.20881424230064774e-03, 1.03676532638344962e-03, 8.71437918068619115e-04, 7.16080155297701002e-04, 5.72637002558129372e-04, 4.42089819465802277e-04, 3.24724948503090564e-04, 2.20342042730246599e-04, 1.28412898401353882e-04, 4.82005924552095464e-05];\n  beta = [1.79988721413553309e-02, 5.59964911064388073e-03, 2.88501402231132779e-03, 1.80096606761053941e-03, 1.24753110589199202e-03, 9.22878876572938311e-04, 7.14430421727287357e-04, 5.71787281789704872e-04, 4.69431007606481533e-04, 3.93232835462916638e-04, 3.34818889318297664e-04, 2.88952148495751517e-04, 2.52211615549573284e-04, 2.22280580798883327e-04, 1.97541838033062524e-04, 1.76836855019718004e-04, 1.59316899661821081e-04, 1.44347930197333986e-04, 1.31448068119965379e-04, 1.20245444949302884e-04, 1.10449144504599392e-04, 1.01828770740567258e-04, 9.41998224204237509e-05, 8.74130545753834437e-05, 8.13466262162801467e-05, 7.59002269646219339e-05, 7.09906300634153481e-05, 6.65482874842468183e-05, 6.25146958969275078e-05, 5.88403394426251749e-05, -1.49282953213429172e-03, -8.78204709546389328e-04, -5.02916549572034614e-04, -2.94822138512746025e-04, -1.75463996970782828e-04, -1.04008550460816434e-04, -5.96141953046457895e-05, -3.12038929076098340e-05, -1.26089735980230047e-05, -2.42892608575730389e-07, 8.05996165414273571e-06, 1.36507009262147391e-05, 1.73964125472926261e-05, 1.98672978842133780e-05, 2.14463263790822639e-05, 2.23954659232456514e-05, 2.28967783814712629e-05, 2.30785389811177817e-05, 2.30321976080909144e-05, 2.28236073720348722e-05, 2.25005881105292418e-05, 2.20981015361991429e-05, 2.16418427448103905e-05, 2.11507649256220843e-05, 2.06388749782170737e-05, 2.01165241997081666e-05, 1.95913450141179244e-05, 1.90689367910436740e-05, 1.85533719641636667e-05, 1.80475722259674218e-05, 5.52213076721292790e-04, 4.47932581552384646e-04, 2.79520653992020589e-04, 1.52468156198446602e-04, 6.93271105657043598e-05, 1.76258683069991397e-05, -1.35744996343269136e-05, -3.17972413350427135e-05, -4.18861861696693365e-05, -4.69004889379141029e-05, -4.87665447413787352e-05, -4.87010031186735069e-05, -4.74755620890086638e-05, -4.55813058138628452e-05, -4.33309644511266036e-05, -4.09230193157750364e-05, -3.84822638603221274e-05, -3.60857167535410501e-05, -3.37793306123367417e-05, -3.15888560772109621e-05, -2.95269561750807315e-05, -2.75978914828335759e-05, -2.58006174666883713e-05, -2.41308356761280200e-05, -2.25823509518346033e-05, -2.11479656768912971e-05, -1.98200638885294927e-05, -1.85909870801065077e-05, -1.74532699844210224e-05, -1.63997823854497997e-05, -4.74617796559959808e-04, -4.77864567147321487e-04, -3.20390228067037603e-04, -1.61105016119962282e-04, -4.25778101285435204e-05, 3.44571294294967503e-05, 7.97092684075674924e-05, 1.03138236708272200e-04, 1.12466775262204158e-04, 1.13103642108481389e-04, 1.08651634848774268e-04, 1.01437951597661973e-04, 9.29298396593363896e-05, 8.40293133016089978e-05, 7.52727991349134062e-05, 6.69632521975730872e-05, 5.92564547323194704e-05, 5.22169308826975567e-05, 4.58539485165360646e-05, 4.01445513891486808e-05, 3.50481730031328081e-05, 3.05157995034346659e-05, 2.64956119950516039e-05, 2.29363633690998152e-05, 1.97893056664021636e-05, 1.70091984636412623e-05, 1.45547428261524004e-05, 1.23886640995878413e-05, 1.04775876076583236e-05, 8.79179954978479373e-06, 7.36465810572578444e-04, 8.72790805146193976e-04, 6.22614862573135066e-04, 2.85998154194304147e-04, 3.84737672879366102e-06, -1.87906003636971558e-04, -2.97603646594554535e-04, -3.45998126832656348e-04, -3.53382470916037712e-04, -3.35715635775048757e-04, -3.04321124789039809e-04, -2.66722723047612821e-04, -2.27654214122819527e-04, -1.89922611854562356e-04, -1.55058918599093870e-04, -1.23778240761873630e-04, -9.62926147717644187e-05, -7.25178327714425337e-05, -5.22070028895633801e-05, -3.50347750511900522e-05, -2.06489761035551757e-05, -8.70106096849767054e-06, 1.13698686675100290e-06, 9.16426474122778849e-06, 1.56477785428872620e-05, 2.08223629482466847e-05, 2.48923381004595156e-05, 2.80340509574146325e-05, 3.03987774629861915e-05, 3.21156731406700616e-05, -1.80182191963885708e-03, -2.43402962938042533e-03, -1.83422663549856802e-03, -7.62204596354009765e-04, 2.39079475256927218e-04, 9.49266117176881141e-04, 1.34467449701540359e-03, 1.48457495259449178e-03, 1.44732339830617591e-03, 1.30268261285657186e-03, 1.10351597375642682e-03, 8.86047440419791759e-04, 6.73073208165665473e-04, 4.77603872856582378e-04, 3.05991926358789362e-04, 1.60315694594721630e-04, 4.00749555270613286e-05, -5.66607461635251611e-05, -1.32506186772982638e-04, -1.90296187989614057e-04, -2.32811450376937408e-04, -2.62628811464668841e-04, -2.82050469867598672e-04, -2.93081563192861167e-04, -2.97435962176316616e-04, -2.96557334239348078e-04, -2.91647363312090861e-04, -2.83696203837734166e-04, -2.73512317095673346e-04, -2.61750155806768580e-04, 6.38585891212050914e-03, 9.62374215806377941e-03, 7.61878061207001043e-03, 2.83219055545628054e-03, -2.09841352012720090e-03, -5.73826764216626498e-03, -7.70804244495414620e-03, -8.21011692264844401e-03, -7.65824520346905413e-03, -6.47209729391045177e-03, -4.99132412004966473e-03, -3.45612289713133280e-03, -2.01785580014170775e-03, -7.59430686781961401e-04, 2.84173631523859138e-04, 1.10891667586337403e-03, 1.72901493872728771e-03, 2.16812590802684701e-03, 2.45357710494539735e-03, 2.61281821058334862e-03, 2.67141039656276912e-03, 2.65203073395980430e-03, 2.57411652877287315e-03, 2.45389126236094427e-03, 2.30460058071795494e-03, 2.13684837686712662e-03, 1.95896528478870911e-03, 1.77737008679454412e-03, 1.59690280765839059e-03, 1.42111975664438546e-03];\n  gama = [6.29960524947436582e-01, 2.51984209978974633e-01, 1.54790300415655846e-01, 1.10713062416159013e-01, 8.57309395527394825e-02, 6.97161316958684292e-02, 5.86085671893713576e-02, 5.04698873536310685e-02, 4.42600580689154809e-02, 3.93720661543509966e-02, 3.54283195924455368e-02, 3.21818857502098231e-02, 2.94646240791157679e-02, 2.71581677112934479e-02, 2.51768272973861779e-02, 2.34570755306078891e-02, 2.19508390134907203e-02, 2.06210828235646240e-02, 1.94388240897880846e-02, 1.83810633800683158e-02, 1.74293213231963172e-02, 1.65685837786612353e-02, 1.57865285987918445e-02, 1.50729501494095594e-02, 1.44193250839954639e-02, 1.38184805735341786e-02, 1.32643378994276568e-02, 1.27517121970498651e-02, 1.22761545318762767e-02, 1.18338262398482403e-02];\n  ex1 = 3.33333333333333333e-01;\n  ex2 = 6.66666666666666667e-01;\n  hpi = 1.57079632679489662;\n  gpi = 3.14159265358979324;\n  thpi = 4.71238898038468986;\n  zeror = 0;\n  zeroi = 0;\n  coner = 1;\n  conei = 0;\n\n\n  var goToLabel = 0;\n  mainExecutionLoop: while (true) {\n    switch (goToLabel) {\n      case 0:\n        rfnu = 1.0 / fnu;\n        // c-----------------------------------------------------------------------\n        // c     overflow test (z/fnu too small)\n        // c-----------------------------------------------------------------------\n        test = (0, _d1mach.d1mach)(1) * 1.0e+3;\n        ac = fnu * test;\n        if (Math.abs(zr) > ac || Math.abs(zi) > ac) {\n          goToLabel = 15;break;\n        }\n        zeta1r = 2.0 * Math.abs(Math.log(test)) + fnu;\n        zeta1i = 0.0;\n        zeta2r = fnu;\n        zeta2i = 0.0;\n        phir = 1.0;\n        phii = 0.0;\n        argr = 1.0;\n        argi = 0.0;\n        break mainExecutionLoop;\n      case 15:\n        zbr = zr * rfnu;\n        zbi = zi * rfnu;\n        rfnu2 = rfnu * rfnu;\n        // c-----------------------------------------------------------------------\n        // c     compute in the fourth quadrant\n        // c-----------------------------------------------------------------------\n        fn13 = fnu ** ex1;\n        fn23 = fn13 * fn13;\n        rfn13 = 1.0 / fn13;\n        w2r = coner - zbr * zbr + zbi * zbi;\n        w2i = conei - zbr * zbi - zbr * zbi;\n        aw2 = (0, _zabs.azabs)(w2r, w2i);\n        if (aw2 > 0.25) {\n          goToLabel = 130;break;\n        }\n        // c-----------------------------------------------------------------------\n        // c     power series for cabs(w2) <= 0.25\n        // c-----------------------------------------------------------------------\n        k = 1;\n        pr[0] = coner;\n        pi[0] = conei;\n        sumar = gama[0];\n        sumai = zeroi;\n        ap[0] = 1.0;\n        if (aw2 < tol) {\n          goToLabel = 20;break;\n        }\n        // do 10 k=2,30\n        for (k = 2; k <= 30; k++) {\n          pr[k - 1] = pr[k - 2] * w2r - pi[k - 2] * w2i;\n          pi[k - 1] = pr[k - 2] * w2i + pi[k - 2] * w2r;\n          sumar = sumar + pr[k - 1] * gama[k - 1];\n          sumai = sumai + pi[k - 1] * gama[k - 1];\n          ap[k - 1] = ap[k - 2] * aw2;\n          if (ap[k - 1] < tol) {\n            goToLabel = 20;break;\n          }\n        }\n        // 10 continue\n        if (goToLabel < 20) k = 30;\n      case 20:\n        kmax = k;\n        zetar = w2r * sumar - w2i * sumai;\n        zetai = w2r * sumai + w2i * sumar;\n        argr = zetar * fn23;\n        argi = zetai * fn23;\n\n        var _azsqrt = (0, _zsqrt.azsqrt)(sumar, sumai);\n\n        var _azsqrt2 = _slicedToArray(_azsqrt, 2);\n\n        zar = _azsqrt2[0];\n        zai = _azsqrt2[1];\n\n        var _azsqrt3 = (0, _zsqrt.azsqrt)(w2r, w2i);\n\n        var _azsqrt4 = _slicedToArray(_azsqrt3, 2);\n\n        str = _azsqrt4[0];\n        sti = _azsqrt4[1];\n\n        zeta2r = str * fnu;\n        zeta2i = sti * fnu;\n        str = coner + ex2 * (zetar * zar - zetai * zai);\n        sti = conei + ex2 * (zetar * zai + zetai * zar);\n        zeta1r = str * zeta2r - sti * zeta2i;\n        zeta1i = str * zeta2i + sti * zeta2r;\n        zar = zar + zar;\n        zai = zai + zai;\n\n        var _azsqrt5 = (0, _zsqrt.azsqrt)(zar, zai);\n\n        var _azsqrt6 = _slicedToArray(_azsqrt5, 2);\n\n        str = _azsqrt6[0];\n        sti = _azsqrt6[1];\n\n        phir = str * rfn13;\n        phii = sti * rfn13;\n        if (ipmtr === 1) {\n          goToLabel = 120;break;\n        }\n        // c-----------------------------------------------------------------------\n        // c     sum series for asum and bsum\n        // c-----------------------------------------------------------------------\n        sumbr = zeror;\n        sumbi = zeroi;\n        // do 30 k=1,kmax\n        for (k = 1; k <= kmax; k++) {\n          sumbr = sumbr + pr[k - 1] * beta[k - 1];\n          sumbi = sumbi + pi[k - 1] * beta[k - 1];\n        }\n        // 30 continue\n        asumr = zeror;\n        asumi = zeroi;\n        bsumr = sumbr;\n        bsumi = sumbi;\n        l1 = 0;\n        l2 = 30;\n        btol = tol * (Math.abs(bsumr) + Math.abs(bsumi));\n        atol = tol;\n        pp = 1.0;\n        ias = 0;\n        ibs = 0;\n        if (rfnu2 < tol) {\n          goToLabel = 110;break;\n        }\n        // do 100 is=2,7\n        for (is = 2; is <= 7; is++) {\n          atol = atol / rfnu2;\n          pp = pp * rfnu2;\n          if (ias === 1) {\n            // go to 60\n          } else {\n            sumar = zeror;\n            sumai = zeroi;\n            // do 40 k=1,kmax\n            for (k = 1; k <= kmax; k++) {\n              m = l1 + k;\n              sumar = sumar + pr[k - 1] * alfa[m - 1];\n              sumai = sumai + pi[k - 1] * alfa[m - 1];\n              if (ap[k - 1] < atol) break;\n            }\n            // 40   continue\n            // 50   continue\n            asumr = asumr + sumar * pp;\n            asumi = asumi + sumai * pp;\n            if (pp < tol) ias = 1;\n          }\n          // 60   continue\n          if (ibs === 1) {\n            // go to 90\n          } else {\n            sumbr = zeror;\n            sumbi = zeroi;\n            // do 70 k=1,kmax\n            for (k = 1; k <= kmax; k++) {\n              m = l2 + k;\n              sumbr = sumbr + pr[k - 1] * beta[m - 1];\n              sumbi = sumbi + pi[k - 1] * beta[m - 1];\n              if (ap[k - 1] < atol) break;\n            }\n            // 70   continue\n            // 80   continue\n            bsumr = bsumr + sumbr * pp;\n            bsumi = bsumi + sumbi * pp;\n            if (pp < btol) ibs = 1;\n          }\n          // 90   continue\n          if (ias === 1 && ibs === 1) break;\n          l1 = l1 + 30;\n          l2 = l2 + 30;\n        }\n      // 100 continue\n      case 110:\n        asumr = asumr + coner;\n        pp = rfnu * rfn13;\n        bsumr = bsumr * pp;\n        bsumi = bsumi * pp;\n      case 120:\n        break mainExecutionLoop;\n      // c-----------------------------------------------------------------------\n      // c     cabs(w2) > 0.25\n      // c-----------------------------------------------------------------------\n      case 130:\n        var _azsqrt7 = (0, _zsqrt.azsqrt)(w2r, w2i);\n\n        var _azsqrt8 = _slicedToArray(_azsqrt7, 2);\n\n        wr = _azsqrt8[0];\n        wi = _azsqrt8[1];\n\n        if (wr < 0.0) wr = 0.0;\n        if (wi < 0.0) wi = 0.0;\n        str = coner + wr;\n        sti = wi;\n\n        var _zdiv = (0, _zdiv9.zdiv)(str, sti, zbr, zbi);\n\n        var _zdiv2 = _slicedToArray(_zdiv, 2);\n\n        zar = _zdiv2[0];\n        zai = _zdiv2[1];\n\n        var _azlog = (0, _zlog.azlog)(zar, zai);\n\n        var _azlog2 = _slicedToArray(_azlog, 2);\n\n        zcr = _azlog2[0];\n        zci = _azlog2[1];\n\n        if (zci < 0.0) zci = 0.0;\n        if (zci > hpi) zci = hpi;\n        if (zcr < 0.0) zcr = 0.0;\n        zthr = (zcr - wr) * 1.5;\n        zthi = (zci - wi) * 1.5;\n        zeta1r = zcr * fnu;\n        zeta1i = zci * fnu;\n        zeta2r = wr * fnu;\n        zeta2i = wi * fnu;\n        azth = (0, _zabs.azabs)(zthr, zthi);\n        ang = thpi;\n        if (zthr >= 0.0 && zthi < 0.0) {\n          goToLabel = 140;break;\n        }\n        ang = hpi;\n        if (zthr === 0.0) {\n          goToLabel = 140;break;\n        }\n        ang = Math.atan(zthi / zthr);\n        if (zthr < 0.0) ang = ang + gpi;\n      case 140:\n        pp = azth ** ex2;\n        ang = ang * ex2;\n        zetar = pp * Math.cos(ang);\n        zetai = pp * Math.sin(ang);\n        if (zetai < 0.0) zetai = 0.0;\n        argr = zetar * fn23;\n        argi = zetai * fn23;\n\n        var _zdiv3 = (0, _zdiv9.zdiv)(zthr, zthi, zetar, zetai);\n\n        var _zdiv4 = _slicedToArray(_zdiv3, 2);\n\n        rtztr = _zdiv4[0];\n        rtzti = _zdiv4[1];\n\n        var _zdiv5 = (0, _zdiv9.zdiv)(rtztr, rtzti, wr, wi);\n\n        var _zdiv6 = _slicedToArray(_zdiv5, 2);\n\n        zar = _zdiv6[0];\n        zai = _zdiv6[1];\n\n        tzar = zar + zar;\n        tzai = zai + zai;\n\n        var _azsqrt9 = (0, _zsqrt.azsqrt)(tzar, tzai);\n\n        var _azsqrt10 = _slicedToArray(_azsqrt9, 2);\n\n        str = _azsqrt10[0];\n        sti = _azsqrt10[1];\n\n        phir = str * rfn13;\n        phii = sti * rfn13;\n        if (ipmtr === 1) {\n          goToLabel = 120;break;\n        }\n        raw = 1.0 / Math.sqrt(aw2);\n        str = wr * raw;\n        sti = -wi * raw;\n        tfnr = str * rfnu * raw;\n        tfni = sti * rfnu * raw;\n        razth = 1.0 / azth;\n        str = zthr * razth;\n        sti = -zthi * razth;\n        rzthr = str * razth * rfnu;\n        rzthi = sti * razth * rfnu;\n        zcr = rzthr * ar[1];\n        zci = rzthi * ar[1];\n        raw2 = 1.0 / aw2;\n        str = w2r * raw2;\n        sti = -w2i * raw2;\n        t2r = str * raw2;\n        t2i = sti * raw2;\n        str = t2r * c[1] + c[2];\n        sti = t2i * c[1];\n        upr[1] = str * tfnr - sti * tfni;\n        upi[1] = str * tfni + sti * tfnr;\n        bsumr = upr[1] + zcr;\n        bsumi = upi[1] + zci;\n        asumr = zeror;\n        asumi = zeroi;\n        if (rfnu < tol) {\n          goToLabel = 220;break;\n        }\n        przthr = rzthr;\n        przthi = rzthi;\n        ptfnr = tfnr;\n        ptfni = tfni;\n        upr[0] = coner;\n        upi[0] = conei;\n        pp = 1.0;\n        btol = tol * (Math.abs(bsumr) + Math.abs(bsumi));\n        ks = 0;\n        kp1 = 2;\n        l = 3;\n        ias = 0;\n        ibs = 0;\n        // do 210 lr=2,12,2\n        for (lr = 2; lr <= 12; lr += 2) {\n          lrp1 = lr + 1;\n          // c-----------------------------------------------------------------------\n          // c     compute two additional cr, dr, and up for two more terms in\n          // c     next suma and sumb\n          // c-----------------------------------------------------------------------\n          // do 160 k=lr,lrp1\n          for (k = lr; k <= lrp1; k++) {\n            ks = ks + 1;\n            kp1 = kp1 + 1;\n            l = l + 1;\n            zar = c[l - 1];\n            zai = zeroi;\n            // do 150 j=2,kp1\n            for (j = 2; j <= kp1; j++) {\n              l = l + 1;\n              str = zar * t2r - t2i * zai + c[l - 1];\n              zai = zar * t2i + zai * t2r;\n              zar = str;\n            }\n            // 150 continue\n            str = ptfnr * tfnr - ptfni * tfni;\n            ptfni = ptfnr * tfni + ptfni * tfnr;\n            ptfnr = str;\n            upr[kp1 - 1] = ptfnr * zar - ptfni * zai;\n            upi[kp1 - 1] = ptfni * zar + ptfnr * zai;\n            crr[ks - 1] = przthr * br[ks];\n            cri[ks - 1] = przthi * br[ks];\n            str = przthr * rzthr - przthi * rzthi;\n            przthi = przthr * rzthi + przthi * rzthr;\n            przthr = str;\n            drr[ks - 1] = przthr * ar[ks + 1];\n            dri[ks - 1] = przthi * ar[ks + 1];\n          }\n          pp = pp * rfnu2;\n          if (ias === 1) {\n            // go to 180\n          } else {\n            sumar = upr[lrp1 - 1];\n            sumai = upi[lrp1 - 1];\n            ju = lrp1;\n            // do 170 jr=1,lr\n            for (jr = 1; jr <= lr; jr++) {\n              ju = ju - 1;\n              sumar = sumar + crr[jr - 1] * upr[ju - 1] - cri[jr - 1] * upi[ju - 1];\n              sumai = sumai + crr[jr - 1] * upi[ju - 1] + cri[jr - 1] * upr[ju - 1];\n            }\n            // 170 continue\n            asumr = asumr + sumar;\n            asumi = asumi + sumai;\n            test = Math.abs(sumar) + Math.abs(sumai);\n            if (pp < tol && test < tol) ias = 1;\n          }\n          // 180   continue\n          if (ibs === 1) {\n            // go to 200\n          } else {\n            sumbr = upr[lr + 1] + upr[lrp1 - 1] * zcr - upi[lrp1 - 1] * zci;\n            sumbi = upi[lr + 1] + upr[lrp1 - 1] * zci + upi[lrp1 - 1] * zcr;\n            ju = lrp1;\n            // do 190 jr=1,lr\n            for (jr = 1; jr <= lr; jr++) {\n              ju = ju - 1;\n              sumbr = sumbr + drr[jr - 1] * upr[ju - 1] - dri[jr - 1] * upi[ju - 1];\n              sumbi = sumbi + drr[jr - 1] * upi[ju - 1] + dri[jr - 1] * upr[ju - 1];\n            }\n            // 190 continue\n            bsumr = bsumr + sumbr;\n            bsumi = bsumi + sumbi;\n            test = Math.abs(sumbr) + Math.abs(sumbi);\n            if (pp < btol && test < btol) ibs = 1;\n          }\n          // 200 continue\n          if (ias === 1 && ibs === 1) break;\n        }\n      // 210 continue\n      case 220:\n        asumr = asumr + coner;\n        str = -bsumr * rfn13;\n        sti = -bsumi * rfn13;\n\n        var _zdiv7 = (0, _zdiv9.zdiv)(str, sti, rtztr, rtzti);\n\n        var _zdiv8 = _slicedToArray(_zdiv7, 2);\n\n        bsumr = _zdiv8[0];\n        bsumi = _zdiv8[1];\n\n        goToLabel = 120;break;\n      default:\n        break mainExecutionLoop;\n    }\n  }\n\n  return [phir, phii, argr, argi, zeta1r, zeta1i, zeta2r, zeta2i, asumr, asumi, bsumr, bsumi];\n}\n},{\"../../utils/fortran-utils/d1mach.js\":91,\"./zabs.js\":11,\"./zdiv.js\":26,\"./zlog.js\":29,\"./zsqrt.js\":36}],39:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); /* eslint-disable no-labels */\n/* eslint-disable no-fallthrough */\n// SUBROUTINE ZUNI1(ZR, ZI, FNU, KODE, N, YR, YI, NZ, NLAST, FNUL,\n// * TOL, ELIM, ALIM)\n// ***BEGIN PROLOGUE  ZUNI1\n// ***REFER TO  ZBESI,ZBESK\n//\n//      ZUNI1 COMPUTES I(FNU,Z)  BY MEANS OF THE UNIFORM ASYMPTOTIC\n//      EXPANSION FOR I(FNU,Z) IN -PI/3.LE.ARG Z.LE.PI/3.\n//\n//      FNUL IS THE SMALLEST ORDER PERMITTED FOR THE ASYMPTOTIC\n//      EXPANSION. NLAST=0 MEANS ALL OF THE Y VALUES WERE SET.\n//      NLAST.NE.0 IS THE NUMBER LEFT TO BE COMPUTED BY ANOTHER\n//      FORMULA FOR ORDERS FNU TO FNU+NLAST-1 BECAUSE FNU+NLAST-1.LT.FNUL.\n//      Y(I)=CZERO FOR I=NLAST+1,N\n//\n// ***ROUTINES CALLED  ZUCHK,ZUNIK,ZUOIK,D1MACH,AZABS\n// ***END PROLOGUE  ZUNI1\n\n\nexports.zuni1 = zuni1;\n\nvar _zuchk = require('./zuchk.js');\n\nvar _zunik5 = require('./zunik.js');\n\nvar _zuoik = require('./zuoik.js');\n\nvar _d1mach = require('../../utils/fortran-utils/d1mach.js');\n\nvar _zabs = require('./zabs.js');\n\nfunction zuni1(zr, zi, fnu, kode, n, yr, yi, fnul, tol, elim, alim) {\n  var aphi = void 0,\n      ascle = void 0,\n      bry = void 0,\n      coner = void 0,\n      crsc = void 0,\n      cscl = void 0,\n      csrr = void 0,\n      cssr = void 0,\n      c1r = void 0,\n      c2i = void 0,\n      c2m = void 0,\n      c2r = void 0,\n      fn = void 0,\n      phii = void 0,\n      phir = void 0,\n      rast = void 0,\n      rs1 = void 0,\n      rzi = void 0,\n      rzr = void 0,\n      sti = void 0,\n      str = void 0,\n      sumi = void 0,\n      sumr = void 0,\n      s1i = void 0,\n      s1r = void 0,\n      s2i = void 0,\n      s2r = void 0,\n      zeroi = void 0,\n      zeror = void 0,\n      zeta1i = void 0,\n      zeta1r = void 0,\n      zeta2i = void 0,\n      zeta2r = void 0,\n      cyr = void 0,\n      cyi = void 0,\n      i = void 0,\n      iflag = void 0,\n      init = void 0,\n      k = void 0,\n      m = void 0,\n      nd = void 0,\n      nlast = void 0,\n      nn = void 0,\n      nuf = void 0,\n      nw = void 0,\n      nz = void 0;\n  bry = new Array(3);\n  cssr = new Array(3);\n  csrr = new Array(3);\n  cyr = new Array(2);\n  cyi = new Array(2);\n  var goToLabel = 0;\n  mainExecutionLoop: while (true) {\n    switch (goToLabel) {\n      case 0:\n        zeror = 0.0;\n        zeroi = 0.0;\n        coner = 1.0;\n\n        nz = 0;\n        nd = n;\n        nlast = 0;\n        // c-----------------------------------------------------------------------\n        // c     computed values with exponents between alim and elim in mag-\n        // c     nitude are scaled to keep intermediate arithmetic on scale,\n        // c     exp(alim)=exp(elim)*tol\n        // c-----------------------------------------------------------------------\n        cscl = 1.0 / tol;\n        crsc = tol;\n        cssr[0] = cscl;\n        cssr[1] = coner;\n        cssr[2] = crsc;\n        csrr[0] = crsc;\n        csrr[1] = coner;\n        csrr[2] = cscl;\n        bry[0] = 1.0e+3 * (0, _d1mach.d1mach)(1) / tol;\n        // c-----------------------------------------------------------------------\n        // c     check for underflow and overflow on first member\n        // c-----------------------------------------------------------------------\n        fn = Math.max(fnu, 1.0);\n        init = 0;\n\n        var _zunik = (0, _zunik5.zunik)(zr, zi, fn, 1, 1, tol, init);\n\n        var _zunik2 = _slicedToArray(_zunik, 8);\n\n        phir = _zunik2[0];\n        phii = _zunik2[1];\n        zeta1r = _zunik2[2];\n        zeta1i = _zunik2[3];\n        zeta2r = _zunik2[4];\n        zeta2i = _zunik2[5];\n        sumr = _zunik2[6];\n        sumi = _zunik2[7];\n\n        if (kode === 1) {\n          goToLabel = 10;break;\n        }\n        str = zr + zeta2r;\n        sti = zi + zeta2i;\n        rast = fn / (0, _zabs.azabs)(str, sti);\n        str = str * rast * rast;\n        sti = -sti * rast * rast;\n        s1r = -zeta1r + str;\n        s1i = -zeta1i + sti;\n        goToLabel = 20;break;\n      case 10:\n        s1r = -zeta1r + zeta2r;\n        s1i = -zeta1i + zeta2i;\n      case 20:\n        rs1 = s1r;\n        if (Math.abs(rs1) > elim) {\n          goToLabel = 130;break;\n        }\n      case 30:\n        nn = Math.min(2, nd);\n        // do 80 i=1,nn\n        forLoop80: for (i = 1; i <= nn; i++) {\n          fn = fnu + (nd - i);\n          init = 0;\n\n          var _zunik3 = (0, _zunik5.zunik)(zr, zi, fn, 1, 0, tol, init);\n\n          var _zunik4 = _slicedToArray(_zunik3, 8);\n\n          phir = _zunik4[0];\n          phii = _zunik4[1];\n          zeta1r = _zunik4[2];\n          zeta1i = _zunik4[3];\n          zeta2r = _zunik4[4];\n          zeta2i = _zunik4[5];\n          sumr = _zunik4[6];\n          sumi = _zunik4[7];\n\n          if (kode === 1) {\n            s1r = -zeta1r + zeta2r;\n            s1i = -zeta1i + zeta2i;\n          } else {\n            str = zr + zeta2r;\n            sti = zi + zeta2i;\n            rast = fn / (0, _zabs.azabs)(str, sti);\n            str = str * rast * rast;\n            sti = -sti * rast * rast;\n            s1r = -zeta1r + str;\n            s1i = -zeta1i + sti + zi;\n          }\n          // c-----------------------------------------------------------------------\n          // c     test for underflow and overflow\n          // c-----------------------------------------------------------------------\n          rs1 = s1r;\n          if (Math.abs(rs1) > elim) {\n            goToLabel = 110;break forLoop80;\n          }\n          if (i === 1) iflag = 2;\n          if (Math.abs(rs1) < alim) {\n            // go to 60\n          } else {\n            // c-----------------------------------------------------------------------\n            // c     refine  test and scale\n            // c-----------------------------------------------------------------------\n            aphi = (0, _zabs.azabs)(phir, phii);\n            rs1 = rs1 + Math.log(aphi);\n            if (Math.abs(rs1) > elim) {\n              goToLabel = 110;break forLoop80;\n            }\n            if (i === 1) iflag = 1;\n            if (rs1 < 0.0) {\n              // go to 60\n            } else {\n              if (i === 1) iflag = 3;\n            }\n          }\n          // 60   continue\n          // c-----------------------------------------------------------------------\n          // c     scale s1 if cabs(s1) < ascle\n          // c-----------------------------------------------------------------------\n          s2r = phir * sumr - phii * sumi;\n          s2i = phir * sumi + phii * sumr;\n          str = Math.exp(s1r) * cssr[iflag - 1];\n          s1r = str * Math.cos(s1i);\n          s1i = str * Math.sin(s1i);\n          str = s2r * s1r - s2i * s1i;\n          s2i = s2r * s1i + s2i * s1r;\n          s2r = str;\n          if (iflag !== 1) {\n            // go to 70\n          } else {\n            nw = (0, _zuchk.zuchk)(s2r, s2i, bry[0], tol);\n            if (nw !== 0) {\n              goToLabel = 110;break forLoop80;\n            }\n          }\n          // 70   continue\n          cyr[i - 1] = s2r;\n          cyi[i - 1] = s2i;\n          m = nd - i + 1;\n          yr[m - 1] = s2r * csrr[iflag - 1];\n          yi[m - 1] = s2i * csrr[iflag - 1];\n        }\n        // 80 continue\n        if (goToLabel > 80) {\n          break;\n        }\n        if (nd <= 2) {\n          goToLabel = 100;break;\n        }\n        rast = 1.0 / (0, _zabs.azabs)(zr, zi);\n        str = zr * rast;\n        sti = -zi * rast;\n        rzr = (str + str) * rast;\n        rzi = (sti + sti) * rast;\n        bry[1] = 1.0 / bry[0];\n        bry[2] = (0, _d1mach.d1mach)(2);\n        s1r = cyr[0];\n        s1i = cyi[0];\n        s2r = cyr[1];\n        s2i = cyi[1];\n        c1r = csrr[iflag - 1];\n        ascle = bry[iflag - 1];\n        k = nd - 2;\n        fn = k;\n\n        // do 90 i=3,nd\n        for (i = 3; i <= nd; i++) {\n          c2r = s2r;\n          c2i = s2i;\n          s2r = s1r + (fnu + fn) * (rzr * c2r - rzi * c2i);\n          s2i = s1i + (fnu + fn) * (rzr * c2i + rzi * c2r);\n          s1r = c2r;\n          s1i = c2i;\n          c2r = s2r * c1r;\n          c2i = s2i * c1r;\n          yr[k - 1] = c2r;\n          yi[k - 1] = c2i;\n          k = k - 1;\n          fn = fn - 1.0;\n          if (iflag >= 3) break;\n          str = Math.abs(c2r);\n          sti = Math.abs(c2i);\n          c2m = Math.max(str, sti);\n          if (c2m <= ascle) break;\n          iflag = iflag + 1;\n          ascle = bry[iflag - 1];\n          s1r = s1r * c1r;\n          s1i = s1i * c1r;\n          s2r = c2r;\n          s2i = c2i;\n          s1r = s1r * cssr[iflag - 1];\n          s1i = s1i * cssr[iflag - 1];\n          s2r = s2r * cssr[iflag - 1];\n          s2i = s2i * cssr[iflag - 1];\n          c1r = csrr[iflag - 1];\n        }\n      // 90 continue\n      case 100:\n        break mainExecutionLoop;\n      case 110:\n        // c-----------------------------------------------------------------------\n        // c     set underflow and update parameters\n        // c-----------------------------------------------------------------------\n        if (rs1 > 0.0) {\n          goToLabel = 120;break;\n        }\n        yr[nd - 1] = zeror;\n        yi[nd - 1] = zeroi;\n        nz = nz + 1;\n        nd = nd - 1;\n        if (nd === 0) {\n          goToLabel = 100;break;\n        }\n        nuf = (0, _zuoik.zuoik)(zr, zi, fnu, kode, 1, nd, yr, yi, tol, elim, alim);\n        if (nuf < 0) {\n          goToLabel = 120;break;\n        }\n        nd = nd - nuf;\n        nz = nz + nuf;\n        if (nd === 0) {\n          goToLabel = 100;break;\n        }\n        fn = fnu + (nd - 1);\n        if (fn >= fnul) {\n          goToLabel = 30;break;\n        }\n        nlast = nd;\n        break mainExecutionLoop;\n      case 120:\n        nz = -1;\n        break mainExecutionLoop;\n      case 130:\n        if (rs1 > 0.0) {\n          goToLabel = 120;break;\n        }\n        nz = n;\n        // do 140 i=1,n\n        for (i = 1; i <= n; i++) {\n          yr[i - 1] = zeror;\n          yi[i - 1] = zeroi;\n        }\n      // 140 continue\n      default:\n        break mainExecutionLoop;\n    }\n  }\n\n  return [nz, nlast];\n}\n},{\"../../utils/fortran-utils/d1mach.js\":91,\"./zabs.js\":11,\"./zuchk.js\":37,\"./zunik.js\":41,\"./zuoik.js\":44}],40:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); /* eslint-disable no-labels */\n/* eslint-disable no-fallthrough */\n// SUBROUTINE ZUNI2(ZR, ZI, FNU, KODE, N, YR, YI, NZ, NLAST, FNUL,\n// * TOL, ELIM, ALIM)\n// ***BEGIN PROLOGUE  ZUNI2\n// ***REFER TO  ZBESI,ZBESK\n//\n//      ZUNI2 COMPUTES I(FNU,Z) IN THE RIGHT HALF PLANE BY MEANS OF\n//      UNIFORM ASYMPTOTIC EXPANSION FOR J(FNU,ZN) WHERE ZN IS Z*I\n//      OR -Z*I AND ZN IS IN THE RIGHT HALF PLANE ALSO.\n//\n//      FNUL IS THE SMALLEST ORDER PERMITTED FOR THE ASYMPTOTIC\n//      EXPANSION. NLAST=0 MEANS ALL OF THE Y VALUES WERE SET.\n//      NLAST.NE.0 IS THE NUMBER LEFT TO BE COMPUTED BY ANOTHER\n//      FORMULA FOR ORDERS FNU TO FNU+NLAST-1 BECAUSE FNU+NLAST-1.LT.FNUL.\n//      Y(I)=CZERO FOR I=NLAST+1,N\n//\n// ***ROUTINES CALLED  ZAIRY,ZUCHK,ZUNHJ,ZUOIK,D1MACH,AZABS\n// ***END PROLOGUE  ZUNI2\n\n\nexports.zuni2 = zuni2;\n\nvar _zairy5 = require('./zairy.js');\n\nvar _zuchk = require('./zuchk.js');\n\nvar _zunhj5 = require('./zunhj.js');\n\nvar _zuoik = require('./zuoik.js');\n\nvar _zabs = require('./zabs.js');\n\nvar _d1mach = require('../../utils/fortran-utils/d1mach.js');\n\nfunction zuni2(zr, zi, fnu, kode, n, yr, yi, fnul, tol, elim, alim) {\n  var aarg = void 0,\n      aic = void 0,\n      aii = void 0,\n      air = void 0,\n      ang = void 0,\n      aphi = void 0,\n      argi = void 0,\n      argr = void 0,\n      ascle = void 0,\n      asumi = void 0,\n      asumr = void 0,\n      bry = void 0,\n      bsumi = void 0,\n      bsumr = void 0,\n      cidi = void 0,\n      cipi = void 0,\n      cipr = void 0,\n      coner = void 0,\n      crsc = void 0,\n      cscl = void 0,\n      csrr = void 0,\n      cssr = void 0,\n      c1r = void 0,\n      c2i = void 0,\n      c2m = void 0,\n      c2r = void 0,\n      daii = void 0,\n      dair = void 0,\n      fn = void 0,\n      hpi = void 0,\n      phii = void 0,\n      phir = void 0,\n      rast = void 0,\n      raz = void 0,\n      rs1 = void 0,\n      rzi = void 0,\n      rzr = void 0,\n      sti = void 0,\n      str = void 0,\n      s1i = void 0,\n      s1r = void 0,\n      s2i = void 0,\n      s2r = void 0,\n      zbi = void 0,\n      zbr = void 0,\n      zeroi = void 0,\n      zeror = void 0,\n      zeta1i = void 0,\n      zeta1r = void 0,\n      zeta2i = void 0,\n      zeta2r = void 0,\n      zni = void 0,\n      znr = void 0,\n      cyr = void 0,\n      cyi = void 0,\n      car = void 0,\n      sar = void 0,\n      i = void 0,\n      iflag = void 0,\n      index = void 0,\n      inu = void 0,\n      j = void 0,\n      k = void 0,\n      nd = void 0,\n      nlast = void 0,\n      nn = void 0,\n      nuf = void 0,\n      nw = void 0,\n      nz = void 0;\n\n  bry = new Array(3);\n  cssr = new Array(3);\n  csrr = new Array(3);\n  cyr = new Array(2);\n  cyi = new Array(2);\n\n  zeror = 0.0;\n  zeroi = 0.0;\n  coner = 1.0;\n\n  cipr = [1, 0, -1, 0];\n  cipi = [0, 1, 0, -1];\n  hpi = 1.57079632679489662;\n  aic = 1.265512123484645396;\n\n\n  var goToLabel = 0;\n  mainExecutionLoop: while (true) {\n    switch (goToLabel) {\n      case 0:\n        nz = 0;\n        nd = n;\n        nlast = 0;\n        // c-----------------------------------------------------------------------\n        // c     computed values with exponents between alim and elim in mag-\n        // c     nitude are scaled to keep intermediate arithmetic on scale,\n        // c     exp(alim)=exp(elim)*tol\n        // c-----------------------------------------------------------------------\n        cscl = 1.0 / tol;\n        crsc = tol;\n        cssr[0] = cscl;\n        cssr[1] = coner;\n        cssr[2] = crsc;\n        csrr[0] = crsc;\n        csrr[1] = coner;\n        csrr[2] = cscl;\n        bry[0] = 1.0e+3 * (0, _d1mach.d1mach)(1) / tol;\n        // c-----------------------------------------------------------------------\n        // c     zn is in the right half plane after rotation by ci or -ci\n        // c-----------------------------------------------------------------------\n        znr = zi;\n        zni = -zr;\n        zbr = zr;\n        zbi = zi;\n        cidi = -coner;\n        inu = Math.trunc(fnu);\n        ang = hpi * (fnu - inu);\n        c2r = Math.cos(ang);\n        c2i = Math.sin(ang);\n        car = c2r;\n        sar = c2i;\n        index = inu + n - 1;\n        index = index % 4 + 1;\n        str = c2r * cipr(index) - c2i * cipi(index);\n        c2i = c2r * cipi(index) + c2i * cipr(index);\n        c2r = str;\n        if (zi > 0.0) {\n          goToLabel = 10;break;\n        }\n        znr = -znr;\n        zbi = -zbi;\n        cidi = -cidi;\n        c2i = -c2i;\n      case 10:\n        // c-----------------------------------------------------------------------\n        // c     check for underflow and overflow on first member\n        // c-----------------------------------------------------------------------\n        fn = Math.max(fnu, 1.0);\n\n        var _zunhj = (0, _zunhj5.zunhj)(znr, zni, fn, 1, tol);\n\n        var _zunhj2 = _slicedToArray(_zunhj, 12);\n\n        phir = _zunhj2[0];\n        phii = _zunhj2[1];\n        argr = _zunhj2[2];\n        argi = _zunhj2[3];\n        zeta1r = _zunhj2[4];\n        zeta1i = _zunhj2[5];\n        zeta2r = _zunhj2[6];\n        zeta2i = _zunhj2[7];\n        asumr = _zunhj2[8];\n        asumi = _zunhj2[9];\n        bsumr = _zunhj2[10];\n        bsumi = _zunhj2[11];\n\n        if (kode === 1) {\n          goToLabel = 20;break;\n        }\n        str = zbr + zeta2r;\n        sti = zbi + zeta2i;\n        rast = fn / (0, _zabs.azabs)(str, sti);\n        str = str * rast * rast;\n        sti = -sti * rast * rast;\n        s1r = -zeta1r + str;\n        s1i = -zeta1i + sti;\n        goToLabel = 30;break;\n      case 20:\n        s1r = -zeta1r + zeta2r;\n        s1i = -zeta1i + zeta2i;\n      case 30:\n        rs1 = s1r;\n        if (Math.abs(rs1) > elim) {\n          goToLabel = 150;break;\n        }\n      case 40:\n        nn = Math.min(2, nd);\n        // do 90 i=1,nn\n        for (i = 1; i <= nn; i++) {\n          fn = fnu + (nd - i);\n\n          var _zunhj3 = (0, _zunhj5.zunhj)(znr, zni, fn, 0, tol);\n\n          var _zunhj4 = _slicedToArray(_zunhj3, 12);\n\n          phir = _zunhj4[0];\n          phii = _zunhj4[1];\n          argr = _zunhj4[2];\n          argi = _zunhj4[3];\n          zeta1r = _zunhj4[4];\n          zeta1i = _zunhj4[5];\n          zeta2r = _zunhj4[6];\n          zeta2i = _zunhj4[7];\n          asumr = _zunhj4[8];\n          asumi = _zunhj4[9];\n          bsumr = _zunhj4[10];\n          bsumi = _zunhj4[11];\n\n          if (kode === 1) {\n            s1r = -zeta1r + zeta2r;\n            s1i = -zeta1i + zeta2i;\n          } else {\n            str = zbr + zeta2r;\n            sti = zbi + zeta2i;\n            rast = fn / (0, _zabs.azabs)(str, sti);\n            str = str * rast * rast;\n            sti = -sti * rast * rast;\n            s1r = -zeta1r + str;\n            s1i = -zeta1i + sti + Math.abs(zi);\n          }\n          // c-----------------------------------------------------------------------\n          // c     test for underflow and overflow\n          // c-----------------------------------------------------------------------\n          rs1 = s1r;\n          if (Math.abs(rs1) > elim) {\n            goToLabel = 120;break;\n          }\n          if (i === 1) iflag = 2;\n          if (Math.abs(rs1) < alim) {//\n            // go to 70\n          } else {\n            // c-----------------------------------------------------------------------\n            // c     refine  test and scale\n            // c-----------------------------------------------------------------------\n            // c-----------------------------------------------------------------------\n            aphi = (0, _zabs.azabs)(phir, phii);\n            aarg = (0, _zabs.azabs)(argr, argi);\n            rs1 = rs1 + Math.log(aphi) - 0.25 * Math.log(aarg) - aic;\n            if (Math.abs(rs1) > elim) {\n              goToLabel = 120;break;\n            }\n            if (i === 1) iflag = 1;\n            if (rs1 < 0.0) {\n              // go to 70\n            } else {\n              if (i === 1) iflag = 3;\n            }\n          }\n          // 70   continue\n          // c-----------------------------------------------------------------------\n          // c     scale s1 to keep intermediate arithmetic on scale near\n          // c     exponent extremes\n          // c-----------------------------------------------------------------------\n\n          var _zairy = (0, _zairy5.zairy)(argr, argi, 0, 2);\n\n          var _zairy2 = _slicedToArray(_zairy, 2);\n\n          air = _zairy2[0];\n          aii = _zairy2[1];\n\n          var _zairy3 = (0, _zairy5.zairy)(argr, argi, 1, 2);\n\n          var _zairy4 = _slicedToArray(_zairy3, 2);\n\n          dair = _zairy4[0];\n          daii = _zairy4[1];\n\n          str = dair * bsumr - daii * bsumi;\n          sti = dair * bsumi + daii * bsumr;\n          str = str + (air * asumr - aii * asumi);\n          sti = sti + (air * asumi + aii * asumr);\n          s2r = phir * str - phii * sti;\n          s2i = phir * sti + phii * str;\n          str = Math.exp(s1r) * cssr[iflag - 1];\n          s1r = str * Math.cos(s1i);\n          s1i = str * Math.sin(s1i);\n          str = s2r * s1r - s2i * s1i;\n          s2i = s2r * s1i + s2i * s1r;\n          s2r = str;\n          if (iflag !== 1) {\n            // go to 80\n          } else {\n            nw = (0, _zuchk.zuchk)(s2r, s2i, bry[0], tol);\n            if (nw !== 0) {\n              goToLabel = 120;break;\n            }\n          }\n          // 80   continue\n          if (zi <= 0.0) s2i = -s2i;\n          str = s2r * c2r - s2i * c2i;\n          s2i = s2r * c2i + s2i * c2r;\n          s2r = str;\n          cyr[i - 1] = s2r;\n          cyi[i - 1] = s2i;\n          j = nd - i + 1;\n          yr[j - 1] = s2r * csrr[iflag - 1];\n          yi[j - 1] = s2i * csrr[iflag - 1];\n          str = -c2i * cidi;\n          c2i = c2r * cidi;\n          c2r = str;\n        }\n        if (goToLabel === 120) {\n          break;\n        }\n        // 90 continue\n        if (nd <= 2) {\n          goToLabel = 110;break;\n        }\n        raz = 1.0 / (0, _zabs.azabs)(zr, zi);\n        str = zr * raz;\n        sti = -zi * raz;\n        rzr = (str + str) * raz;\n        rzi = (sti + sti) * raz;\n        bry[1] = 1.0 / bry[0];\n        bry[2] = (0, _d1mach.d1mach)(2);\n        s1r = cyr[0];\n        s1i = cyi[0];\n        s2r = cyr[1];\n        s2i = cyi[1];\n        c1r = csrr[iflag - 1];\n        ascle = bry[iflag - 1];\n        k = nd - 2;\n        fn = k;\n        // do 100 i=3,nd\n        for (i = 3; i <= nd; i++) {\n          c2r = s2r;\n          c2i = s2i;\n          s2r = s1r + (fnu + fn) * (rzr * c2r - rzi * c2i);\n          s2i = s1i + (fnu + fn) * (rzr * c2i + rzi * c2r);\n          s1r = c2r;\n          s1i = c2i;\n          c2r = s2r * c1r;\n          c2i = s2i * c1r;\n          yr[k - 1] = c2r;\n          yi[k - 1] = c2i;\n          k = k - 1;\n          fn = fn - 1.0;\n          if (iflag >= 3) continue;\n          str = Math.abs(c2r);\n          sti = Math.abs(c2i);\n          c2m = Math.max(str, sti);\n          if (c2m <= ascle) continue;\n          iflag = iflag + 1;\n          ascle = bry[iflag - 1];\n          s1r = s1r * c1r;\n          s1i = s1i * c1r;\n          s2r = c2r;\n          s2i = c2i;\n          s1r = s1r * cssr[iflag - 1];\n          s1i = s1i * cssr[iflag - 1];\n          s2r = s2r * cssr[iflag - 1];\n          s2i = s2i * cssr[iflag - 1];\n          c1r = csrr[iflag - 1];\n        }\n      // 100 continue\n      case 110:\n        break mainExecutionLoop;\n      case 120:\n        if (rs1 > 0.0) {\n          goToLabel = 140;break;\n        }\n        // c-----------------------------------------------------------------------\n        // c     set underflow and update parameters\n        // c-----------------------------------------------------------------------\n        yr[nd - 1] = zeror;\n        yi[nd - 1] = zeroi;\n        nz = nz + 1;\n        nd = nd - 1;\n        if (nd === 0) {\n          goToLabel = 110;break;\n        }\n        nuf = (0, _zuoik.zuoik)(zr, zi, fnu, kode, 1, nd, yr, yi, tol, elim, alim);\n        if (nuf < 0) {\n          goToLabel = 140;break;\n        }\n        nd = nd - nuf;\n        nz = nz + nuf;\n        if (nd === 0) {\n          goToLabel = 110;break;\n        }\n        fn = fnu + (nd - 1);\n        if (fn < fnul) {\n          goToLabel = 130;break;\n        }\n        // c      fn = cidi\n        // c      j = nuf + 1\n        // c      k = mod(j,4) + 1\n        // c      s1r = cipr(k)\n        // c      s1i = cipi(k)\n        // c      if (fn < 0.0) s1i = -s1i\n        // c      str = c2r*s1r - c2i*s1i\n        // c      c2i = c2r*s1i + c2i*s1r\n        // c      c2r = str\n        index = inu + nd - 1;\n        index = index % 4 + 1;\n        c2r = car * cipr[index - 1] - sar * cipi[index - 1];\n        c2i = car * cipi[index - 1] + sar * cipr[index - 1];\n        if (zi <= 0.0) c2i = -c2i;\n        goToLabel = 40;break;\n      case 130:\n        nlast = nd;\n        break mainExecutionLoop;\n      case 140:\n        nz = -1;\n        break mainExecutionLoop;\n      case 150:\n        if (rs1 > 0.0) {\n          goToLabel = 140;break;\n        }\n        nz = n;\n        // do 160 i=1,n\n        for (i = 1; i <= n; i++) {\n          yr[i - 1] = zeror;\n          yi[i - 1] = zeroi;\n        }\n      // 160 continue\n      default:\n        break mainExecutionLoop;\n    }\n  }\n\n  return [nz, nlast];\n}\n},{\"../../utils/fortran-utils/d1mach.js\":91,\"./zabs.js\":11,\"./zairy.js\":14,\"./zuchk.js\":37,\"./zunhj.js\":38,\"./zuoik.js\":44}],41:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); // SUBROUTINE ZUNIK(ZRR, ZRI, FNU, IKFLG, IPMTR, TOL, INIT, PHIR,\n//  * PHII, ZETA1R, ZETA1I, ZETA2R, ZETA2I, SUMR, SUMI, CWRKR, CWRKI)\n// ***BEGIN PROLOGUE  ZUNIK\n// ***REFER TO  ZBESI,ZBESK\n//\n//         ZUNIK COMPUTES PARAMETERS FOR THE UNIFORM ASYMPTOTIC\n//         EXPANSIONS OF THE I AND K FUNCTIONS ON IKFLG= 1 OR 2\n//         RESPECTIVELY BY\n//\n//         W(FNU,ZR) = PHI*EXP(ZETA)*SUM\n//\n//         WHERE       ZETA=-ZETA1 + ZETA2       OR\n//                           ZETA1 - ZETA2\n//\n//         THE FIRST CALL MUST HAVE INIT=0. SUBSEQUENT CALLS WITH THE\n//         SAME ZR AND FNU WILL RETURN THE I OR K FUNCTION ON IKFLG=\n//         1 OR 2 WITH NO CHANGE IN INIT. CWRK IS A COMPLEX WORK\n//         ARRAY. IPMTR=0 COMPUTES ALL PARAMETERS. IPMTR=1 COMPUTES PHI,\n//         ZETA1,ZETA2.\n//\n// ***ROUTINES CALLED  ZDIV,AZLOG,AZSQRT,D1MACH\n// ***END PROLOGUE  ZUNIK\n//      COMPLEX CFN,CON,CONE,CRFN,CWRK,CZERO,PHI,S,SR,SUM,T,T2,ZETA1,\n//     *ZETA2,ZN,ZR\n\n\nexports.zunik = zunik;\n\nvar _zdiv7 = require('./zdiv.js');\n\nvar _zlog = require('./zlog.js');\n\nvar _zsqrt = require('./zsqrt.js');\n\nvar _d1mach = require('../../utils/fortran-utils/d1mach.js');\n\nfunction zunik(zrr, zri, fnu, ikflg, ipmtr, tol, init) {\n  var ac = void 0,\n      c = void 0,\n      con = void 0,\n      conei = void 0,\n      coner = void 0,\n      crfni = void 0,\n      crfnr = void 0,\n      cwrki = void 0,\n      cwrkr = void 0,\n      phii = void 0,\n      phir = void 0,\n      rfn = void 0,\n      si = void 0,\n      sr = void 0,\n      sri = void 0,\n      srr = void 0,\n      sti = void 0,\n      str = void 0,\n      sumi = void 0,\n      sumr = void 0,\n      test = void 0,\n      ti = void 0,\n      tr = void 0,\n      t2i = void 0,\n      t2r = void 0,\n      zeroi = void 0,\n      zeror = void 0,\n      zeta1i = void 0,\n      zeta1r = void 0,\n      zeta2i = void 0,\n      zeta2r = void 0,\n      zni = void 0,\n      znr = void 0,\n      i = void 0,\n      j = void 0,\n      k = void 0,\n      l = void 0;\n  cwrkr = new Array(16);\n  cwrki = new Array(16);\n  zeror = 0;\n  zeroi = 0;\n  coner = 1;\n  conei = 0;\n  con = [3.98942280401432678e-01, 1.25331413731550025e+00];\n  c = [1.00000000000000000e+00, -2.08333333333333333e-01, 1.25000000000000000e-01, 3.34201388888888889e-01, -4.01041666666666667e-01, 7.03125000000000000e-02, -1.02581259645061728e+00, 1.84646267361111111e+00, -8.91210937500000000e-01, 7.32421875000000000e-02, 4.66958442342624743e+00, -1.12070026162229938e+01, 8.78912353515625000e+00, -2.36408691406250000e+00, 1.12152099609375000e-01, -2.82120725582002449e+01, 8.46362176746007346e+01, -9.18182415432400174e+01, 4.25349987453884549e+01, -7.36879435947963170e+00, 2.27108001708984375e-01, 2.12570130039217123e+02, -7.65252468141181642e+02, 1.05999045252799988e+03, -6.99579627376132541e+02, 2.18190511744211590e+02, -2.64914304869515555e+01, 5.72501420974731445e-01, -1.91945766231840700e+03, 8.06172218173730938e+03, -1.35865500064341374e+04, 1.16553933368645332e+04, -5.30564697861340311e+03, 1.20090291321635246e+03, -1.08090919788394656e+02, 1.72772750258445740e+00, 2.02042913309661486e+04, -9.69805983886375135e+04, 1.92547001232531532e+05, -2.03400177280415534e+05, 1.22200464983017460e+05, -4.11926549688975513e+04, 7.10951430248936372e+03, -4.93915304773088012e+02, 6.07404200127348304e+00, -2.42919187900551333e+05, 1.31176361466297720e+06, -2.99801591853810675e+06, 3.76327129765640400e+06, -2.81356322658653411e+06, 1.26836527332162478e+06, -3.31645172484563578e+05, 4.52187689813627263e+04, -2.49983048181120962e+03, 2.43805296995560639e+01, 3.28446985307203782e+06, -1.97068191184322269e+07, 5.09526024926646422e+07, -7.41051482115326577e+07, 6.63445122747290267e+07, -3.75671766607633513e+07, 1.32887671664218183e+07, -2.78561812808645469e+06, 3.08186404612662398e+05, -1.38860897537170405e+04, 1.10017140269246738e+02, -4.93292536645099620e+07, 3.25573074185765749e+08, -9.39462359681578403e+08, 1.55359689957058006e+09, -1.62108055210833708e+09, 1.10684281682301447e+09, -4.95889784275030309e+08, 1.42062907797533095e+08, -2.44740627257387285e+07, 2.24376817792244943e+06, -8.40054336030240853e+04, 5.51335896122020586e+02, 8.14789096118312115e+08, -5.86648149205184723e+09, 1.86882075092958249e+10, -3.46320433881587779e+10, 4.12801855797539740e+10, -3.30265997498007231e+10, 1.79542137311556001e+10, -6.56329379261928433e+09, 1.55927986487925751e+09, -2.25105661889415278e+08, 1.73951075539781645e+07, -5.49842327572288687e+05, 3.03809051092238427e+03, -1.46792612476956167e+10, 1.14498237732025810e+11, -3.99096175224466498e+11, 8.19218669548577329e+11, -1.09837515608122331e+12, 1.00815810686538209e+12, -6.45364869245376503e+11, 2.87900649906150589e+11, -8.78670721780232657e+10, 1.76347306068349694e+10, -2.16716498322379509e+09, 1.43157876718888981e+08, -3.87183344257261262e+06, 1.82577554742931747e+04, 2.86464035717679043e+11, -2.40629790002850396e+12, 9.10934118523989896e+12, -2.05168994109344374e+13, 3.05651255199353206e+13, -3.16670885847851584e+13, 2.33483640445818409e+13, -1.23204913055982872e+13, 4.61272578084913197e+12, -1.19655288019618160e+12, 2.05914503232410016e+11, -2.18229277575292237e+10, 1.24700929351271032e+09, -2.91883881222208134e+07, 1.18838426256783253e+05];\n  if (init !== 0) {\n    // go to 40\n  } else {\n    // c-----------------------------------------------------------------------\n    // c     initialize all variables\n    // c-----------------------------------------------------------------------\n    rfn = 1.0 / fnu;\n    // c-----------------------------------------------------------------------\n    // c     overflow test (zr/fnu too small)\n    // c-----------------------------------------------------------------------\n    test = (0, _d1mach.d1mach)(1) * 1.0e3;\n    ac = fnu * test;\n    if (Math.abs(zrr) > ac || Math.abs(zri) > ac) {\n      // go to 15\n    } else {\n      zeta1r = 2.0 * Math.abs(Math.log(test)) + fnu;\n      zeta1i = 0.0;\n      zeta2r = fnu;\n      zeta2i = 0.0;\n      phir = 1.0;\n      phii = 0.0;\n      sumr = sumi = null;\n      return [phir, phii, zeta1r, zeta1i, zeta2r, zeta2i, sumr, sumi, cwrkr, cwrki];\n    }\n    // 15 continue\n    tr = zrr * rfn;\n    ti = zri * rfn;\n    sr = coner + (tr * tr - ti * ti);\n    si = conei + (tr * ti + ti * tr);\n\n    var _azsqrt = (0, _zsqrt.azsqrt)(sr, si);\n\n    var _azsqrt2 = _slicedToArray(_azsqrt, 2);\n\n    srr = _azsqrt2[0];\n    sri = _azsqrt2[1];\n\n    str = coner + srr;\n    sti = conei + sri;\n\n    var _zdiv = (0, _zdiv7.zdiv)(str, sti, tr, ti);\n\n    var _zdiv2 = _slicedToArray(_zdiv, 2);\n\n    znr = _zdiv2[0];\n    zni = _zdiv2[1];\n\n    var _azlog = (0, _zlog.azlog)(znr, zni);\n\n    var _azlog2 = _slicedToArray(_azlog, 2);\n\n    str = _azlog2[0];\n    sti = _azlog2[1];\n\n    zeta1r = fnu * str;\n    zeta1i = fnu * sti;\n    zeta2r = fnu * srr;\n    zeta2i = fnu * sri;\n\n    var _zdiv3 = (0, _zdiv7.zdiv)(coner, conei, srr, sri);\n\n    var _zdiv4 = _slicedToArray(_zdiv3, 2);\n\n    tr = _zdiv4[0];\n    ti = _zdiv4[1];\n\n    srr = tr * rfn;\n    sri = ti * rfn;\n\n    var _azsqrt3 = (0, _zsqrt.azsqrt)(srr, sri);\n\n    var _azsqrt4 = _slicedToArray(_azsqrt3, 2);\n\n    cwrkr[15] = _azsqrt4[0];\n    cwrki[15] = _azsqrt4[1];\n\n    phir = cwrkr[15] * con[ikflg - 1];\n    phii = cwrki[15] * con[ikflg - 1];\n    if (ipmtr !== 0) {\n      return [phir, phii, zeta1r, zeta1i, zeta2r, zeta2i, sumr, sumi, cwrkr, cwrki];\n    }\n\n    var _zdiv5 = (0, _zdiv7.zdiv)(coner, conei, sr, si);\n\n    var _zdiv6 = _slicedToArray(_zdiv5, 2);\n\n    t2r = _zdiv6[0];\n    t2i = _zdiv6[1];\n\n    cwrkr[0] = coner;\n    cwrki[0] = conei;\n    crfnr = coner;\n    crfni = conei;\n    ac = 1.0;\n    l = 1;\n    // do 20 k=2,15\n    for (k = 2; k <= 15; k++) {\n      sr = zeror;\n      si = zeroi;\n      // do 10 j=1,k\n      for (j = 1; j <= k; j++) {\n        l = l + 1;\n        str = sr * t2r - si * t2i + c[l - 1];\n        si = sr * t2i + si * t2r;\n        sr = str;\n      }\n      // 10   continue\n      str = crfnr * srr - crfni * sri;\n      crfni = crfnr * sri + crfni * srr;\n      crfnr = str;\n      cwrkr[k - 1] = crfnr * sr - crfni * si;\n      cwrki[k - 1] = crfnr * si + crfni * sr;\n      ac = ac * rfn;\n      test = Math.abs(cwrkr[k - 1]) + Math.abs(cwrki[k - 1]);\n      if (ac < tol && test < tol) {\n        break;\n      }\n    }\n    // 20 continue\n    if (k === 16) k = 15; // if loop maxed out, set to 15, last index of loop; }\n    // 30 continue\n    init = k;\n  }\n  // 40 continue\n  if (ikflg === 2) {\n    // go to 60\n  } else {\n    // c-----------------------------------------------------------------------\n    // c     compute sum for the i function\n    // c-----------------------------------------------------------------------\n    sr = zeror;\n    si = zeroi;\n    // do 50 i=1,init\n    for (i = 1; i <= init; i++) {\n      sr = sr + cwrkr[i - 1];\n      si = si + cwrki[i - 1];\n    }\n    // 50 continue\n    sumr = sr;\n    sumi = si;\n    phir = cwrkr[15] * con[0];\n    phii = cwrki[15] * con[0];\n    return [phir, phii, zeta1r, zeta1i, zeta2r, zeta2i, sumr, sumi, cwrkr, cwrki];\n  }\n  // 60 continue\n  // c-----------------------------------------------------------------------\n  // c     compute sum for the k function\n  // c-----------------------------------------------------------------------\n  sr = zeror;\n  si = zeroi;\n  tr = coner;\n  // do 70 i=1,init\n  for (i = 1; i <= init; i++) {\n    sr = sr + tr * cwrkr(i - 1);\n    si = si + tr * cwrki(i - 1);\n    tr = -tr;\n  }\n  // 70 continue\n  sumr = sr;\n  sumi = si;\n  phir = cwrkr[15] * con[1];\n  phii = cwrki[15] * con[1];\n  return [phir, phii, zeta1r, zeta1i, zeta2r, zeta2i, sumr, sumi, cwrkr, cwrki];\n}\n},{\"../../utils/fortran-utils/d1mach.js\":91,\"./zdiv.js\":26,\"./zlog.js\":29,\"./zsqrt.js\":36}],42:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); /* eslint-disable no-labels */\n/* eslint-disable no-fallthrough */\n// SUBROUTINE ZUNK1(ZR, ZI, FNU, KODE, MR, N, YR, YI, NZ, TOL, ELIM,\n// * ALIM)\n// ***BEGIN PROLOGUE  ZUNK1\n// ***REFER TO  ZBESK\n//\n//      ZUNK1 COMPUTES K(FNU,Z) AND ITS ANALYTIC CONTINUATION FROM THE\n//      RIGHT HALF PLANE TO THE LEFT HALF PLANE BY MEANS OF THE\n//      UNIFORM ASYMPTOTIC EXPANSION.\n//      MR INDICATES THE DIRECTION OF ROTATION FOR ANALYTIC CONTINUATION.\n//      NZ=-1 MEANS AN OVERFLOW WILL OCCUR\n//\n// ***ROUTINES CALLED  ZKSCL,ZS1S2,ZUCHK,ZUNIK,D1MACH,AZABS\n// ***END PROLOGUE  ZUNK1\n\n\nexports.zunk1 = zunk1;\n\nvar _zs1s5 = require('./zs1s2.js');\n\nvar _zuchk = require('./zuchk.js');\n\nvar _zunik7 = require('./zunik.js');\n\nvar _zabs = require('./zabs.js');\n\nvar _d1mach = require('../../utils/fortran-utils/d1mach.js');\n\nvar _fortranHelpers = require('../../utils/fortranHelpers.js');\n\nvar ft = _interopRequireWildcard(_fortranHelpers);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction zunk1(zr, zi, fnu, kode, mr, n, yr, yi, tol, elim, alim) {\n  var ang = void 0,\n      aphi = void 0,\n      asc = void 0,\n      ascle = void 0,\n      bry = void 0,\n      cki = void 0,\n      ckr = void 0,\n      coner = void 0,\n      crsc = void 0,\n      cscl = void 0,\n      csgni = void 0,\n      cspni = void 0,\n      cspnr = void 0,\n      csr = void 0,\n      csrr = void 0,\n      cssr = void 0,\n      cyi = void 0,\n      cyr = void 0,\n      c1i = void 0,\n      c1r = void 0,\n      c2i = void 0,\n      c2m = void 0,\n      c2r = void 0,\n      fmr = void 0,\n      fn = void 0,\n      fnf = void 0,\n      phidi = void 0,\n      phidr = void 0,\n      phii = void 0,\n      phir = void 0,\n      pi = void 0,\n      rast = void 0,\n      razr = void 0,\n      rs1 = void 0,\n      rzi = void 0,\n      rzr = void 0,\n      sgn = void 0,\n      sti = void 0,\n      str = void 0,\n      sumdi = void 0,\n      sumdr = void 0,\n      sumi = void 0,\n      sumr = void 0,\n      s1i = void 0,\n      s1r = void 0,\n      s2i = void 0,\n      s2r = void 0,\n      zeroi = void 0,\n      zeror = void 0,\n      zeta1i = void 0,\n      zeta1r = void 0,\n      zeta2i = void 0,\n      zeta2r = void 0,\n      zet1di = void 0,\n      zet1dr = void 0,\n      zet2di = void 0,\n      zet2dr = void 0,\n      zri = void 0,\n      zrr = void 0,\n      i = void 0,\n      ib = void 0,\n      iflag = void 0,\n      ifn = void 0,\n      il = void 0,\n      init = void 0,\n      inu = void 0,\n      iuf = void 0,\n      k = void 0,\n      kdflg = void 0,\n      kflag = void 0,\n      kk = void 0,\n      nw = void 0,\n      nz = void 0,\n      initd = void 0,\n      ic = void 0,\n      ipard = void 0,\n      j = void 0,\n      f = void 0,\n      m = void 0,\n      zbr = void 0,\n      zbi = void 0,\n      yy = void 0;\n\n  bry = new Array(3);\n  init = new Array(2);\n  sumr = new Array(2);\n  sumi = new Array(2);\n  zeta1r = new Array(2);\n  zeta1i = new Array(2);\n  zeta2r = new Array(2);\n  zeta2i = new Array(2);\n  cyr = new Array(2);\n  cyi = new Array(2);\n  cssr = new Array(3);\n  csrr = new Array(3);\n  phir = new Array(2);\n  phii = new Array(2);\n\n  // Init 2D arrs for cwrk\n  var cwrkr = [];\n  var cwrki = [];\n  var iMax = 16;\n  var jMax = 3;\n  for (i = 0; i < iMax; i++) {\n    cwrkr[i] = [];\n    cwrki[i] = [];\n    for (j = 0; j < jMax; j++) {\n      f[i][j] = null;\n    }\n  }\n\n  zeror = 0.0;\n  zeroi = 0.0;\n  coner = 1.0;\n\n  pi = 3.14159265358979324;\n\n  var goToLabel = 0;\n  mainExecutionLoop: while (true) {\n    switch (goToLabel) {\n      case 0:\n        kdflg = 1;\n        nz = 0;\n        // c-----------------------------------------------------------------------\n        // c     exp(-alim)=exp(-elim)/tol=approx. one precision greater than\n        // c     the underflow limit\n        // c-----------------------------------------------------------------------\n        cscl = 1.0 / tol;\n        crsc = tol;\n        cssr[0] = cscl;\n        cssr[1] = coner;\n        cssr[2] = crsc;\n        csrr[0] = crsc;\n        csrr[1] = coner;\n        csrr[2] = cscl;\n        bry[0] = 1.0e+3 * (0, _d1mach.d1mach)(1) / tol;\n        bry[1] = 1.0 / bry[0];\n        bry[2] = (0, _d1mach.d1mach)(2);\n        zrr = zr;\n        zri = zi;\n        if (zr >= 0.0) {\n          goToLabel = 10;break;\n        }\n        zrr = -zr;\n        zri = -zi;\n      case 10:\n        j = 2;\n        // do 70 i=1,n\n        for (i = 1; i <= n; i++) {\n          // c-----------------------------------------------------------------------\n          // c     j flip flops between 1 and 2 in j = 3 - j\n          // c-----------------------------------------------------------------------\n          j = 3 - j;\n          fn = fnu + i - 1;\n          init[j - 1] = 0;\n\n          var _zunik = (0, _zunik7.zunik)(zrr, zri, fn, 2, 0, tol, init[j - 1]);\n\n          var _zunik2 = _slicedToArray(_zunik, 10);\n\n          phir[j - 1] = _zunik2[0];\n          phii[j - 1] = _zunik2[1];\n          zeta1r[j - 1] = _zunik2[2];\n          zeta1i[j - 1] = _zunik2[3];\n          zeta2r[j - 1] = _zunik2[4];\n          zeta2i[j - 1] = _zunik2[5];\n          sumr[j - 1] = _zunik2[6];\n          sumi[j - 1] = _zunik2[7];\n          cwrkr[0][j - 1] = _zunik2[8];\n          cwrki[0][j - 1] = _zunik2[9];\n\n          if (kode === 1) {\n            s1r = zeta1r[j - 1] - zeta2r[j - 1];\n            s1i = zeta1i[j - 1] - zeta2i[j - 1];\n          } else {\n            str = zrr + zeta2r[j - 1];\n            sti = zri + zeta2i[j - 1];\n            rast = fn / (0, _zabs.azabs)(str, sti);\n            str = str * rast * rast;\n            sti = -sti * rast * rast;\n            s1r = zeta1r[j - 1] - str;\n            s1i = zeta1i[j - 1] - sti;\n          }\n          rs1 = s1r;\n          // c-----------------------------------------------------------------------\n          // c     test for underflow and overflow\n          // c-----------------------------------------------------------------------\n          if (Math.abs(rs1) > elim) goToLabel = 60;\n          if (goToLabel !== 60) {\n            if (kdflg === 1) kflag = 2;\n            if (Math.abs(rs1) < alim) goToLabel = 40;\n            if (goToLabel !== 40) {\n              // c-----------------------------------------------------------------------\n              // c     refine  test and scale\n              // c-----------------------------------------------------------------------\n              aphi = (0, _zabs.azabs)(phir[j - 1], phii[j - 1]);\n              rs1 = rs1 + Math.log(aphi);\n              if (Math.abs(rs1) > elim) goToLabel = 60;\n              if (goToLabel !== 60) {\n                if (kdflg === 1) kflag = 1;\n                if (rs1 < 0.0) {\n                  // go to 50\n                } else {\n                  if (kdflg === 1) kflag = 3;\n                }\n              }\n            }\n            // 40   continue\n            if (goToLabel < 60) {\n              // c-----------------------------------------------------------------------\n              // c     scale s1 to keep intermediate arithmetic on scale near\n              // c     exponent extremes\n              // c-----------------------------------------------------------------------\n              s2r = phir[j - 1] * sumr[j - 1] - phii[j - 1] * sumi[j - 1];\n              s2i = phir[j - 1] * sumi[j - 1] + phii[j - 1] * sumr[j - 1];\n              str = Math.exp(s1r) * cssr[kflag - 1];\n              s1r = str * Math.cos(s1i);\n              s1i = str * Math.sin(s1i);\n              str = s2r * s1r - s2i * s1i;\n              s2i = s1r * s2i + s2r * s1i;\n              s2r = str;\n              if (kflag !== 1) {\n                // go to 50\n              } else {\n                nw = (0, _zuchk.zuchk)(s2r, s2i, bry[0], tol);\n                if (nw !== 0) goToLabel = 60;\n              }\n              // 50   continue\n              if (goToLabel < 60) {\n                cyr[kdflg - 1] = s2r;\n                cyi[kdflg - 1] = s2i;\n                yr[i - 1] = s2r * csrr[kflag - 1];\n                yi[i - 1] = s2i * csrr[kflag - 1];\n                if (kdflg === 2) {\n                  goToLabel = 75;break;\n                }\n                kdflg = 2;\n                break;\n              }\n            }\n          }\n          // 60   continue\n          if (rs1 > 0.0) {\n            goToLabel = 300;break;\n          }\n          // c-----------------------------------------------------------------------\n          // c     for zr < 0.0, the i function to be added will overflow\n          // c-----------------------------------------------------------------------\n          if (zr < 0.0) {\n            goToLabel = 300;break;\n          }\n          kdflg = 1;\n          yr[i - 1] = zeror;\n          yi[i - 1] = zeroi;\n          nz = nz + 1;\n          if (i === 1) break;\n          if (yr[i - 2] === zeror && yi[i - 2] === zeroi) break;\n          yr[i - 2] = zeror;\n          yi[i - 2] = zeroi;\n          nz = nz + 1;\n        }\n        // 70 continue\n        if (goToLabel < 70) {\n          i = n;\n        } else {\n          break;\n        }\n      case 75:\n        razr = 1.0 / (0, _zabs.azabs)(zrr, zri);\n        str = zrr * razr;\n        sti = -zri * razr;\n        rzr = (str + str) * razr;\n        rzi = (sti + sti) * razr;\n        ckr = fn * rzr;\n        cki = fn * rzi;\n        ib = i + 1;\n        if (n < ib) {\n          goToLabel = 160;break;\n        }\n        // c-----------------------------------------------------------------------\n        // c     test last member for underflow and overflow. set sequence to zero\n        // c     on underflow.\n        // c-----------------------------------------------------------------------\n        fn = fnu + (n - 1);\n        ipard = 1;\n        if (mr !== 0) ipard = 0;\n        initd = 0;\n\n        var _zunik3 = (0, _zunik7.zunik)(zrr, zri, fn, 2, ipard, tol, initd);\n\n        var _zunik4 = _slicedToArray(_zunik3, 10);\n\n        phidr = _zunik4[0];\n        phidi = _zunik4[1];\n        zet1dr = _zunik4[2];\n        zet1di = _zunik4[3];\n        zet2dr = _zunik4[4];\n        zet2di = _zunik4[5];\n        sumdr = _zunik4[6];\n        sumdi = _zunik4[7];\n        cwrkr[0][2] = _zunik4[8];\n        cwrki[0][2] = _zunik4[9];\n\n        if (kode === 1) {\n          goToLabel = 80;break;\n        }\n        str = zrr + zet2dr;\n        sti = zri + zet2di;\n        rast = fn / (0, _zabs.azabs)(str, sti);\n        str = str * rast * rast;\n        sti = -sti * rast * rast;\n        s1r = zet1dr - str;\n        s1i = zet1di - sti;\n        goToLabel = 90;break;\n      case 80:\n        s1r = zet1dr - zet2dr;\n        s1i = zet1di - zet2di;\n      case 90:\n        rs1 = s1r;\n        if (Math.abs(rs1) > elim) {\n          goToLabel = 95;break;\n        }\n        if (Math.abs(rs1) < alim) {\n          goToLabel = 100;break;\n        }\n        // c----------------------------------------------------------------------------\n        // c     refine estimate and test\n        // c-------------------------------------------------------------------------\n        aphi = (0, _zabs.azabs)(phidr, phidi);\n        rs1 = rs1 + Math.log(aphi);\n        if (Math.abs(rs1) < elim) {\n          goToLabel = 100;break;\n        }\n      case 95:\n        if (Math.abs(rs1) > 0.0) {\n          goToLabel = 300;break;\n        }\n        // c-----------------------------------------------------------------------\n        // c     for zr < 0.0, the i function to be added will overflow\n        // c-----------------------------------------------------------------------\n        if (zr < 0.0) {\n          goToLabel = 300;break;\n        }\n        nz = n;\n        // do 96 i=1,n\n        for (i = 1; i <= n; i++) {\n          yr[i - 1] = zeror;\n          yi[i - 1] = zeroi;\n        }\n        // 96 continue\n        break mainExecutionLoop;\n      // c---------------------------------------------------------------------------\n      // c     forward recur for remainder of the sequence\n      // c----------------------------------------------------------------------------\n      case 100:\n        s1r = cyr[0];\n        s1i = cyi[0];\n        s2r = cyr[1];\n        s2i = cyi[1];\n        c1r = csrr[kflag - 1];\n        ascle = bry[kflag - 1];\n        // do 120 i=ib,n\n        for (i = ib; i <= n; i++) {\n          c2r = s2r;\n          c2i = s2i;\n          s2r = ckr * c2r - cki * c2i + s1r;\n          s2i = ckr * c2i + cki * c2r + s1i;\n          s1r = c2r;\n          s1i = c2i;\n          ckr = ckr + rzr;\n          cki = cki + rzi;\n          c2r = s2r * c1r;\n          c2i = s2i * c1r;\n          yr[i - 1] = c2r;\n          yi[i - 1] = c2i;\n          if (kflag >= 3) break;\n          str = Math.abs(c2r);\n          sti = Math.abs(c2i);\n          c2m = Math.max(str, sti);\n          if (c2m <= ascle) break;\n          kflag = kflag + 1;\n          ascle = bry[kflag - 1];\n          s1r = s1r * c1r;\n          s1i = s1i * c1r;\n          s2r = c2r;\n          s2i = c2i;\n          s1r = s1r * cssr[kflag - 1];\n          s1i = s1i * cssr[kflag - 1];\n          s2r = s2r * cssr[kflag - 1];\n          s2i = s2i * cssr[kflag - 1];\n          c1r = csrr[kflag - 1];\n        }\n      // 120 continue\n      case 160:\n        if (mr === 0) break mainExecutionLoop;\n        // c-----------------------------------------------------------------------\n        // c     analytic continuation for re(z) < 0.0\n        // c-----------------------------------------------------------------------\n        nz = 0;\n        fmr = mr;\n        sgn = -ft.sign(pi, fmr);\n        // c-----------------------------------------------------------------------\n        // c     cspn and csgn are coeff of k and i functions resp.\n        // c-----------------------------------------------------------------------\n        csgni = sgn;\n        inu = Math.trunc(fnu);\n        fnf = fnu - inu;\n        ifn = inu + n - 1;\n        ang = fnf * sgn;\n        cspnr = Math.cos(ang);\n        cspni = Math.sin(ang);\n        if (ifn % 2 === 0) {\n          goToLabel = 170;break;\n        }\n        cspnr = -cspnr;\n        cspni = -cspni;\n      case 170:\n        asc = bry[0];\n        iuf = 0;\n        kk = n;\n        kdflg = 1;\n        ib = ib - 1;\n        ic = ib - 1;\n        // This loop 270 is such a hairy mess, I apologize if anyone has to come\n        // back in here again. yeesh.\n        // do 270 k=1,n\n        loop270: for (k = 1; k <= n; k++) {\n          fn = fnu + (kk - 1);\n          // c-----------------------------------------------------------------------\n          // c     logic to sort out cases whose parameters were set for the k\n          // c     function above\n          // c     technically the below is correct but it's gross - KC\n          // c-----------------------------------------------------------------------\n          m = 3;\n          if (n > 2 && kk === n && ib < n) {\n            // do nothing\n          } else if (n > 2 && (kk === ib || kk === ic) || n <= 2) {\n            // 172   continue\n            initd = init[j - 1];\n            phidr = phir[j - 1];\n            phidi = phii[j - 1];\n            zet1dr = zeta1r[j - 1];\n            zet1di = zeta1i[j - 1];\n            zet2dr = zeta2r[j - 1];\n            zet2di = zeta2i[j - 1];\n            sumdr = sumr[j - 1];\n            sumdi = sumi[j - 1];\n            m = j;\n            j = 3 - j;\n          } else if (n > 2) {\n            initd = 0;\n          }\n          // 180 continue\n\n          var _zunik5 = (0, _zunik7.zunik)(zrr, zri, fn, 1, 0, tol, initd);\n\n          var _zunik6 = _slicedToArray(_zunik5, 10);\n\n          phidr = _zunik6[0];\n          phidi = _zunik6[1];\n          zet1dr = _zunik6[2];\n          zet1di = _zunik6[3];\n          zet2dr = _zunik6[4];\n          zet2di = _zunik6[5];\n          sumdr = _zunik6[6];\n          sumdi = _zunik6[7];\n          cwrkr[0][m - 1] = _zunik6[8];\n          cwrki[0][m - 1] = _zunik6[9];\n\n          if (kode === 1) {\n            s1r = -zet1dr + zet2dr;\n            s1i = -zet1di + zet2di;\n          } else {\n            str = zbr + zet2dr;\n            sti = zbi + zet2di;\n            rast = fn / (0, _zabs.azabs)(str, sti);\n            str = str * rast * rast;\n            sti = -sti * rast * rast;\n            s1r = -zet1dr + str;\n            s1i = -zet1di + sti;\n          }\n          // c-----------------------------------------------------------------------\n          // c     test for underflow and overflow\n          // c-----------------------------------------------------------------------\n          rs1 = s1r;\n          if (Math.abs(rs1) > elim) {\n            // go to 260\n            if (rs1 > 0.0) {\n              goToLabel = 300;break;\n            }\n            s2r = zeror;\n            s2i = zeroi;\n            // go to 230\n          } else {\n            if (kdflg === 1) iflag = 2;\n            if (Math.abs(rs1) < alim) {\n              // go to 220\n            } else {\n              // c-----------------------------------------------------------------------\n              // c     refine  test and scale\n              // c-----------------------------------------------------------------------\n              aphi = (0, _zabs.azabs)(phidr, phidi);\n              rs1 = rs1 + Math.log(aphi);\n              if (Math.abs(rs1) > elim) {\n                // go to 260\n                if (rs1 > 0.0) {\n                  goToLabel = 300;break;\n                }\n                s2r = zeror;\n                s2i = zeroi;\n                goToLabel = 230;\n              } else {\n                if (kdflg === 1) iflag = 1;\n                if (rs1 < 0.0) {\n                  // go to 220\n                } else {\n                  if (kdflg === 1) iflag = 3;\n                }\n              }\n            }\n            // 220   continue\n            if (goToLabel < 230) {\n              str = phidr * sumdr - phidi * sumdi;\n              sti = phidr * sumdi + phidi * sumdr;\n              s2r = -csgni * sti;\n              s2i = csgni * str;\n              str = Math.exp(s1r) * cssr[iflag - 1];\n              s1r = str * Math.cos(s1i);\n              s1i = str * Math.sin(s1i);\n              str = s2r * s1r - s2i * s1i;\n              s2i = s2r * s1i + s2i * s1r;\n              s2r = str;\n              if (iflag !== 1) {\n                // go to 230\n              } else {\n                nw = (0, _zuchk.zuchk)(s2r, s2i, bry[0], tol);\n                if (nw === 0) {\n                  // go to 230\n                } else {\n                  s2r = zeror;\n                  s2i = zeroi;\n                }\n              } // iflag !== 1\n            } // if should run 220?\n          } // if should skip straight to 230\n          // 230   continue\n          if (yy <= 0.0) s2i = -s2i;\n          cyr[kdflg - 1] = s2r;\n          cyi[kdflg - 1] = s2i;\n          c2r = s2r;\n          c2i = s2i;\n          s2r = s2r * csrr[iflag - 1];\n          s2i = s2i * csrr[iflag - 1];\n          // c-----------------------------------------------------------------------\n          // c     add i and k functions, k sequence in y(i), i=1,n\n          // c-----------------------------------------------------------------------\n          s1r = yr[kk - 1];\n          s1i = yi[kk - 1];\n          if (kode === 1) {\n            // go to 250\n          } else {\n            var _zs1s = (0, _zs1s5.zs1s2)(zrr, zri, s1r, s1i, s2r, s2i, asc, alim, iuf);\n\n            var _zs1s2 = _slicedToArray(_zs1s, 5);\n\n            s1r = _zs1s2[0];\n            s1i = _zs1s2[1];\n            s2r = _zs1s2[2];\n            s2i = _zs1s2[3];\n            nw = _zs1s2[4];\n\n            nz = nz + nw;\n          }\n          // 250   continue\n          yr[kk - 1] = s1r * cspnr - s1i * cspni + s2r;\n          yi[kk - 1] = s1r * cspni + s1i * cspnr + s2i;\n          kk = kk - 1;\n          cspnr = -cspnr;\n          cspni = -cspni;\n          if (c2r !== 0.0 || c2i !== 0.0) {\n            // go to 255\n          } else {\n            kdflg = 1;\n            break;\n          }\n          // 255   continue\n          if (kdflg === 2) {\n            goToLabel = 295;break;\n          }\n          kdflg = 2;\n          break;\n        }\n        // 270 continue\n        k = n;\n      case 275:\n        il = n - k;\n        if (il === 0) break mainExecutionLoop;\n        // c-----------------------------------------------------------------------\n        // c     recur backward for remainder of i sequence and add in the\n        // c     k functions, scaling the i sequence during recurrence to keep\n        // c     intermediate arithmetic on scale near exponent extremes.\n        // c-----------------------------------------------------------------------\n        s1r = cyr[0];\n        s1i = cyi[0];\n        s2r = cyr[1];\n        s2i = cyi[1];\n        csr = csrr[iflag - 1];\n        ascle = bry[iflag - 1];\n        fn = inu + il;\n        // do 290 i=1,il\n        for (i = 1; i <= il; i++) {\n          c2r = s2r;\n          c2i = s2i;\n          s2r = s1r + (fn + fnf) * (rzr * c2r - rzi * c2i);\n          s2i = s1i + (fn + fnf) * (rzr * c2i + rzi * c2r);\n          s1r = c2r;\n          s1i = c2i;\n          fn = fn - 1.0;\n          c2r = s2r * csr;\n          c2i = s2i * csr;\n          ckr = c2r;\n          cki = c2i;\n          c1r = yr[kk - 1];\n          c1i = yi[kk - 1];\n          if (kode === 1) {\n            // go to 280\n          } else {\n            var _zs1s3 = (0, _zs1s5.zs1s2)(zrr, zri, c1r, c1i, c2r, c2i, asc, alim, iuf);\n\n            var _zs1s4 = _slicedToArray(_zs1s3, 5);\n\n            c1r = _zs1s4[0];\n            c1i = _zs1s4[1];\n            c2r = _zs1s4[2];\n            c2i = _zs1s4[3];\n            nw = _zs1s4[4];\n\n            nz = nz + nw;\n          }\n          // 280   continue\n          yr[kk - 1] = c1r * cspnr - c1i * cspni + c2r;\n          yi[kk - 1] = c1r * cspni + c1i * cspnr + c2i;\n          kk = kk - 1;\n          cspnr = -cspnr;\n          cspni = -cspni;\n          if (iflag >= 3) break;\n          c2r = Math.abs(ckr);\n          c2i = Math.abs(cki);\n          c2m = Math.max(c2r, c2i);\n          if (c2m <= ascle) break;\n          iflag = iflag + 1;\n          ascle = bry[iflag - 1];\n          s1r = s1r * csr;\n          s1i = s1i * csr;\n          s2r = ckr;\n          s2i = cki;\n          s1r = s1r * cssr[iflag - 1];\n          s1i = s1i * cssr[iflag - 1];\n          s2r = s2r * cssr[iflag - 1];\n          s2i = s2i * cssr[iflag - 1];\n          csr = csrr[iflag - 1];\n        }\n        // 290 continue\n        break mainExecutionLoop;\n      case 300:\n        nz = -1;\n      default:\n        break mainExecutionLoop;\n    }\n  }\n\n  return nz;\n}\n},{\"../../utils/fortran-utils/d1mach.js\":91,\"../../utils/fortranHelpers.js\":93,\"./zabs.js\":11,\"./zs1s2.js\":33,\"./zuchk.js\":37,\"./zunik.js\":41}],43:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); /* eslint-disable no-labels */\n/* eslint-disable no-fallthrough */\n// SUBROUTINE ZUNK2(ZR, ZI, FNU, KODE, MR, N, YR, YI, NZ, TOL, ELIM,\n// * ALIM)\n// ***BEGIN PROLOGUE  ZUNK2\n// ***REFER TO  ZBESK\n//\n//      ZUNK2 COMPUTES K(FNU,Z) AND ITS ANALYTIC CONTINUATION FROM THE\n//      RIGHT HALF PLANE TO THE LEFT HALF PLANE BY MEANS OF THE\n//      UNIFORM ASYMPTOTIC EXPANSIONS FOR H(KIND,FNU,ZN) AND J(FNU,ZN)\n//      WHERE ZN IS IN THE RIGHT HALF PLANE, KIND=(3-MR)/2, MR=+1 OR\n//      -1. HERE ZN=ZR*I OR -ZR*I WHERE ZR=Z IF Z IS IN THE RIGHT\n//      HALF PLANE OR ZR=-Z IF Z IS IN THE LEFT HALF PLANE. MR INDIC-\n//      ATES THE DIRECTION OF ROTATION FOR ANALYTIC CONTINUATION.\n//      NZ=-1 MEANS AN OVERFLOW WILL OCCUR\n//\n// ***ROUTINES CALLED  ZAIRY,ZKSCL,ZS1S2,ZUCHK,ZUNHJ,D1MACH,AZABS\n// ***END PROLOGUE  ZUNK2\n\n\nexports.zunk2 = zunk2;\n\nvar _zairy9 = require('./zairy.js');\n\nvar _zs1s5 = require('./zs1s2.js');\n\nvar _zuchk = require('./zuchk.js');\n\nvar _zunhj7 = require('./zunhj.js');\n\nvar _d1mach = require('../../utils/fortran-utils/d1mach.js');\n\nvar _zabs = require('./zabs.js');\n\nvar _fortranHelpers = require('../../utils/fortranHelpers.js');\n\nvar ft = _interopRequireWildcard(_fortranHelpers);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction zunk2(zr, zi, fnu, kode, mr, n, yr, yi, tol, elim, alim) {\n  var aarg = void 0,\n      aic = void 0,\n      aii = void 0,\n      air = void 0,\n      ang = void 0,\n      aphi = void 0,\n      argdi = void 0,\n      argdr = void 0,\n      argi = void 0,\n      argr = void 0,\n      asc = void 0,\n      ascle = void 0,\n      asumdi = void 0,\n      asumdr = void 0,\n      asumi = void 0,\n      asumr = void 0,\n      bry = void 0,\n      bsumdi = void 0,\n      bsumdr = void 0,\n      bsumi = void 0,\n      bsumr = void 0,\n      car = void 0,\n      cipi = void 0,\n      cipr = void 0,\n      cki = void 0,\n      ckr = void 0,\n      coner = void 0,\n      crsc = void 0,\n      cr1i = void 0,\n      cr1r = void 0,\n      cr2i = void 0,\n      cr2r = void 0,\n      cscl = void 0,\n      csgni = void 0,\n      csi = void 0,\n      cspni = void 0,\n      cspnr = void 0,\n      csr = void 0,\n      csrr = void 0,\n      cssr = void 0,\n      cyi = void 0,\n      cyr = void 0,\n      c1i = void 0,\n      c1r = void 0,\n      c2i = void 0,\n      c2m = void 0,\n      c2r = void 0,\n      daii = void 0,\n      dair = void 0,\n      fmr = void 0,\n      fn = void 0,\n      fnf = void 0,\n      hpi = void 0,\n      phidi = void 0,\n      phidr = void 0,\n      phii = void 0,\n      phir = void 0,\n      pi = void 0,\n      pti = void 0,\n      ptr = void 0,\n      rast = void 0,\n      razr = void 0,\n      rs1 = void 0,\n      rzi = void 0,\n      rzr = void 0,\n      sar = void 0,\n      sgn = void 0,\n      sti = void 0,\n      str = void 0,\n      s1i = void 0,\n      s1r = void 0,\n      s2i = void 0,\n      s2r = void 0,\n      yy = void 0,\n      zbi = void 0,\n      zbr = void 0,\n      zeroi = void 0,\n      zeror = void 0,\n      zeta1i = void 0,\n      zeta1r = void 0,\n      zeta2i = void 0,\n      zeta2r = void 0,\n      zet1di = void 0,\n      zet1dr = void 0,\n      zet2di = void 0,\n      zet2dr = void 0,\n      zni = void 0,\n      znr = void 0,\n      zri = void 0,\n      zrr = void 0,\n      i = void 0,\n      ib = void 0,\n      iflag = void 0,\n      ifn = void 0,\n      il = void 0,\n      index = void 0,\n      inu = void 0,\n      iuf = void 0,\n      k = void 0,\n      kdflg = void 0,\n      kflag = void 0,\n      kk = void 0,\n      nw = void 0,\n      nz = void 0,\n      j = void 0,\n      ipard = void 0,\n      ic = void 0;\n  bry = new Array(3);\n  asumr = new Array(2);\n  asumi = new Array(2);\n  bsumr = new Array(2);\n  bsumi = new Array(2);\n  phir = new Array(2);\n  phii = new Array(2);\n  argr = new Array(2);\n  argi = new Array(2);\n  zeta1r = new Array(2);\n  zeta1i = new Array(2);\n  zeta2r = new Array(2);\n  zeta2i = new Array(2);\n  cyr = new Array(2);\n  cyi = new Array(2);\n  cssr = new Array(3);\n  csrr = new Array(3);\n\n  zeror = 0.0;\n  zeroi = 0.0;\n  coner = 1.0;\n  cr1r = 1.0;\n  cr1i = 1.73205080756887729;\n  cr2r = -0.5;\n  cr2i = -8.66025403784438647e-01;\n  hpi = 1.57079632679489662;\n  pi = 3.14159265358979324;\n  aic = 1.26551212348464539;\n\n  cipr = [1, 0, -1, 0];\n  cipi = [0, -1, 0, 1];\n\n  var goToLabel = 0;\n  mainExecutionLoop: while (true) {\n    switch (goToLabel) {\n      case 0:\n        kdflg = 1;\n        nz = 0;\n        // c-----------------------------------------------------------------------\n        // c     exp(-alim)=exp(-elim)/tol=approx. one precision greater than\n        // c     the underflow limit\n        // c-----------------------------------------------------------------------\n        cscl = 1.0 / tol;\n        crsc = tol;\n        cssr[0] = cscl;\n        cssr[1] = coner;\n        cssr[2] = crsc;\n        csrr[0] = crsc;\n        csrr[1] = coner;\n        csrr[2] = cscl;\n        bry[0] = 1.0e+3 * (0, _d1mach.d1mach)(1) / tol;\n        bry[1] = 1.0 / bry[0];\n        bry[2] = (0, _d1mach.d1mach)(2);\n        zrr = zr;\n        zri = zi;\n        if (zr >= 0.0) {\n          goToLabel = 10;break;\n        }\n        zrr = -zr;\n        zri = -zi;\n      case 10:\n        yy = zri;\n        znr = zri;\n        zni = -zrr;\n        zbr = zrr;\n        zbi = zri;\n        inu = Math.trunc(fnu);\n        fnf = fnu - inu;\n        ang = -hpi * fnf;\n        car = Math.cos(ang);\n        sar = Math.sin(ang);\n        c2r = hpi * sar;\n        c2i = -hpi * car;\n        kk = inu % 4 + 1;\n        str = c2r * cipr[kk - 1] - c2i * cipi[kk - 1];\n        sti = c2r * cipi[kk - 1] + c2i * cipr[kk - 1];\n        csr = cr1r * str - cr1i * sti;\n        csi = cr1r * sti + cr1i * str;\n        if (yy > 0.0) {\n          goToLabel = 20;break;\n        }\n        znr = -znr;\n        zbi = -zbi;\n      case 20:\n        // c-----------------------------------------------------------------------\n        // c     k(fnu,z) is computed from h(2,fnu,-i*z) where z is in the first\n        // c     quadrant. fourth quadrant values (yy <= 0.0) are computed by\n        // c     conjugation since the k function is real on the positive real axis\n        // c-----------------------------------------------------------------------\n        j = 2;\n        // do 80 i=1,n\n        for (i = 1; i <= n; i++) {\n          // c-----------------------------------------------------------------------\n          // c     j flip flops between 1 and 2 in j = 3 - j\n          // c-----------------------------------------------------------------------\n          j = 3 - j;\n          fn = fnu + i - 1;\n\n          var _zunhj = (0, _zunhj7.zunhj)(znr, zni, fn, 0, tol);\n\n          var _zunhj2 = _slicedToArray(_zunhj, 12);\n\n          phir[j - 1] = _zunhj2[0];\n          phii[j - 1] = _zunhj2[1];\n          argr[j - 1] = _zunhj2[2];\n          argi[j - 1] = _zunhj2[3];\n          zeta1r[j - 1] = _zunhj2[4];\n          zeta1i[j - 1] = _zunhj2[5];\n          zeta2r[j - 1] = _zunhj2[6];\n          zeta2i[j - 1] = _zunhj2[7];\n          asumr[j - 1] = _zunhj2[8];\n          asumi[j - 1] = _zunhj2[9];\n          bsumr[j - 1] = _zunhj2[10];\n          bsumi[j - 1] = _zunhj2[11];\n\n          if (kode === 1) {\n            s1r = zeta1r[j - 1] - zeta2r[j - 1];\n            s1i = zeta1i[j - 1] - zeta2i[j - 1];\n          } else {\n            str = zbr + zeta2r[j - 1];\n            sti = zbi + zeta2i[j - 1];\n            rast = fn / (0, _zabs.azabs)(str, sti);\n            str = str * rast * rast;\n            sti = -sti * rast * rast;\n            s1r = zeta1r[j - 1] - str;\n            s1i = zeta1i[j - 1] - sti;\n          }\n          // c-----------------------------------------------------------------------\n          // c     test for underflow and overflow\n          // c-----------------------------------------------------------------------\n          rs1 = s1r;\n          if (Math.abs(rs1) > elim) goToLabel = 70;\n          if (goToLabel !== 70) {\n            if (kdflg === 1) kflag = 2;\n            if (Math.abs(rs1) < alim) goToLabel = 50;\n            if (goToLabel !== 50) {\n              // c-----------------------------------------------------------------------\n              // c     refine  test and scale\n              // c-----------------------------------------------------------------------\n              aphi = (0, _zabs.azabs)(phir[j - 1], phii[j - 1]);\n              aarg = (0, _zabs.azabs)(argr[j - 1], argi[j - 1]);\n              rs1 = rs1 + Math.log(aphi) - 0.25 * Math.log(aarg) - aic;\n              if (Math.abs(rs1) > elim) goToLabel = 70;\n              if (goToLabel !== 70) {\n                if (kdflg === 1) kflag = 1;\n                if (rs1 < 0.0) {\n                  // go to 50\n                } else {\n                  if (kdflg === 1) kflag = 3;\n                }\n              }\n            }\n            // 50   continue\n            if (goToLabel < 70) {\n              // c-----------------------------------------------------------------------\n              // c     scale s1 to keep intermediate arithmetic on scale near\n              // c     exponent extremes\n              // c-----------------------------------------------------------------------\n              c2r = argr[j - 1] * cr2r - argi[j - 1] * cr2i;\n              c2i = argr[j - 1] * cr2i + argi[j - 1] * cr2r;\n\n              var _zairy = (0, _zairy9.zairy)(c2r, c2i, 0, 2);\n\n              var _zairy2 = _slicedToArray(_zairy, 2);\n\n              air = _zairy2[0];\n              aii = _zairy2[1];\n\n              var _zairy3 = (0, _zairy9.zairy)(c2r, c2i, 1, 2);\n\n              var _zairy4 = _slicedToArray(_zairy3, 2);\n\n              dair = _zairy4[0];\n              daii = _zairy4[1];\n\n              str = dair * bsumr[j - 1] - daii * bsumi[j - 1];\n              sti = dair * bsumi[j - 1] + daii * bsumr[j - 1];\n              ptr = str * cr2r - sti * cr2i;\n              pti = str * cr2i + sti * cr2r;\n              str = ptr + (air * asumr[j - 1] - aii * asumi[j - 1]);\n              sti = pti + (air * asumi[j - 1] + aii * asumr[j - 1]);\n              ptr = str * phir[j - 1] - sti * phii[j - 1];\n              pti = str * phii[j - 1] + sti * phir[j - 1];\n              s2r = ptr * csr - pti * csi;\n              s2i = ptr * csi + pti * csr;\n              str = Math.exp(s1r) * cssr[kflag - 1];\n              s1r = str * Math.cos(s1i);\n              s1i = str * Math.sin(s1i);\n              str = s2r * s1r - s2i * s1i;\n              s2i = s1r * s2i + s2r * s1i;\n              s2r = str;\n              if (kflag !== 1) {\n                // go to 60\n              } else {\n                nw = (0, _zuchk.zuchk)(s2r, s2i, bry[0], tol);\n                if (nw !== 0) goToLabel = 70;\n              }\n              // 60   continue\n              if (goToLabel < 70) {\n                if (yy <= 0.0) s2i = -s2i;\n                cyr[kdflg - 1] = s2r;\n                cyi[kdflg - 1] = s2i;\n                yr[i - 1] = s2r * csrr[kflag - 1];\n                yi[i - 1] = s2i * csrr[kflag - 1];\n                str = csi;\n                csi = -csr;\n                csr = str;\n                if (kdflg === 2) {\n                  goToLabel = 85;break;\n                }\n                kdflg = 2;\n                break;\n              }\n            }\n          }\n          // 70   continue\n          if (rs1 > 0.0) {\n            goToLabel = 320;break;\n          }\n          // c-----------------------------------------------------------------------\n          // c     for zr < 0.0, the i function to be added will overflow\n          // c-----------------------------------------------------------------------\n          if (zr < 0.0) {\n            goToLabel = 320;break;\n          }\n          kdflg = 1;\n          yr[i - 1] = zeror;\n          yi[i - 1] = zeroi;\n          nz = nz + 1;\n          str = csi;\n          csi = -csr;\n          csr = str;\n          if (i === 1) break;\n          if (yr[i - 2] === zeror && yi[i - 2] === zeroi) break;\n          yr[i - 2] = zeror;\n          yi[i - 2] = zeroi;\n          nz = nz + 1;\n        }\n        // 80 continue\n        if (goToLabel < 80) {\n          i = n;\n        } else {\n          break;\n        }\n      case 85:\n        razr = 1.0 / (0, _zabs.azabs)(zrr, zri);\n        str = zrr * razr;\n        sti = -zri * razr;\n        rzr = (str + str) * razr;\n        rzi = (sti + sti) * razr;\n        ckr = fn * rzr;\n        cki = fn * rzi;\n        ib = i + 1;\n        if (n < ib) {\n          goToLabel = 180;break;\n        }\n        // c-----------------------------------------------------------------------\n        // c     test last member for underflow and overflow. set sequence to zero\n        // c     on underflow.\n        // c-----------------------------------------------------------------------\n        fn = fnu + (n - 1);\n        ipard = 1;\n        if (mr !== 0) {\n          ipard = 0;\n\n          var _zunhj3 = (0, _zunhj7.zunhj)(znr, zni, fn, ipard, tol);\n\n          var _zunhj4 = _slicedToArray(_zunhj3, 12);\n\n          phidr = _zunhj4[0];\n          phidi = _zunhj4[1];\n          argdr = _zunhj4[2];\n          argdi = _zunhj4[3];\n          zet1dr = _zunhj4[4];\n          zet1di = _zunhj4[5];\n          zet2dr = _zunhj4[6];\n          zet2di = _zunhj4[7];\n          asumdr = _zunhj4[8];\n          asumdi = _zunhj4[9];\n          bsumdr = _zunhj4[10];\n          bsumdi = _zunhj4[11];\n        }\n        if (kode === 1) {\n          goToLabel = 90;break;\n        }\n        str = zbr + zet2dr;\n        sti = zbi + zet2di;\n        rast = fn / (0, _zabs.azabs)(str, sti);\n        str = str * rast * rast;\n        sti = -sti * rast * rast;\n        s1r = zet1dr - str;\n        s1i = zet1di - sti;\n        goToLabel = 100;break;\n      case 90:\n        s1r = zet1dr - zet2dr;\n        s1i = zet1di - zet2di;\n      case 100:\n        rs1 = s1r;\n        if (Math.abs(rs1) > elim) {\n          goToLabel = 105;break;\n        }\n        if (Math.abs(rs1) < alim) {\n          goToLabel = 120;break;\n        }\n        // c----------------------------------------------------------------------------\n        // c     refine estimate and test\n        // c-------------------------------------------------------------------------\n        aphi = (0, _zabs.azabs)(phidr, phidi);\n        rs1 = rs1 + Math.log(aphi);\n        if (Math.abs(rs1) < elim) {\n          goToLabel = 120;break;\n        }\n      case 105:\n        if (rs1 > 0.0) {\n          goToLabel = 320;break;\n        }\n        // c-----------------------------------------------------------------------\n        // c     for zr < 0.0, the i function to be added will overflow\n        // c-----------------------------------------------------------------------\n        if (zr < 0.0) {\n          goToLabel = 320;break;\n        }\n        nz = n;\n        // do 106 i=1,n\n        for (i = 1; i <= n; i++) {\n          yr[i - 1] = zeror;\n          yi[i - 1] = zeroi;\n        }\n        // 106 continue\n        break mainExecutionLoop;\n      case 120:\n        s1r = cyr[0];\n        s1i = cyi[0];\n        s2r = cyr[1];\n        s2i = cyi[1];\n        c1r = csrr[kflag - 1];\n        ascle = bry[kflag - 1];\n        // do 130 i=ib,n\n        for (i = ib; i <= n; i++) {\n          c2r = s2r;\n          c2i = s2i;\n          s2r = ckr * c2r - cki * c2i + s1r;\n          s2i = ckr * c2i + cki * c2r + s1i;\n          s1r = c2r;\n          s1i = c2i;\n          ckr = ckr + rzr;\n          cki = cki + rzi;\n          c2r = s2r * c1r;\n          c2i = s2i * c1r;\n          yr[i - 1] = c2r;\n          yi[i - 1] = c2i;\n          if (kflag >= 3) break;\n          str = Math.abs(c2r);\n          sti = Math.abs(c2i);\n          c2m = Math.max(str, sti);\n          if (c2m <= ascle) break;\n          kflag = kflag + 1;\n          ascle = bry[kflag - 1];\n          s1r = s1r * c1r;\n          s1i = s1i * c1r;\n          s2r = c2r;\n          s2i = c2i;\n          s1r = s1r * cssr[kflag - 1];\n          s1i = s1i * cssr[kflag - 1];\n          s2r = s2r * cssr[kflag - 1];\n          s2i = s2i * cssr[kflag - 1];\n          c1r = csrr[kflag - 1];\n        }\n      // 130 continue\n      case 180:\n        if (mr === 0) break mainExecutionLoop;\n        // c-----------------------------------------------------------------------\n        // c     analytic continuation for re(z) < 0.0\n        // c-----------------------------------------------------------------------\n        nz = 0;\n        fmr = mr;\n        sgn = -ft.sign(pi, fmr);\n        // c-----------------------------------------------------------------------\n        // c     cspn and csgn are coeff of k and i functions resp.\n        // c-----------------------------------------------------------------------\n        csgni = sgn;\n        if (yy <= 0.0) csgni = -csgni;\n        ifn = inu + n - 1;\n        ang = fnf * sgn;\n        cspnr = Math.cos(ang);\n        cspni = Math.sin(ang);\n        if (ifn % 2 === 0) {\n          goToLabel = 190;break;\n        }\n        cspnr = -cspnr;\n        cspni = -cspni;\n      case 190:\n        // c-----------------------------------------------------------------------\n        // c     cs=coeff of the j function to get the i function. i(fnu,z) is\n        // c     computed from exp(i*fnu*hpi)*j(fnu,-i*z) where z is in the first\n        // c     quadrant. fourth quadrant values (yy <= 0.0e0) are computed by\n        // c     conjugation since the i function is real on the positive real axis\n        // c-----------------------------------------------------------------------\n        csr = sar * csgni;\n        csi = car * csgni;\n        index = ifn % 4 + 1;\n        c2r = cipr[index - 1];\n        c2i = cipi[index - 1];\n        str = csr * c2r + csi * c2i;\n        csi = -csr * c2i + csi * c2r;\n        csr = str;\n        asc = bry[0];\n        iuf = 0;\n        kk = n;\n        kdflg = 1;\n        ib = ib - 1;\n        ic = ib - 1;\n        // This loop 290 is such a hairy mess, I apologize if anyone has to come\n        // back in here again. yeesh.\n        // do 290 k=1,n\n        for (k = 1; k <= n; k++) {\n          fn = fnu + (kk - 1);\n          // c-----------------------------------------------------------------------\n          // c     logic to sort out cases whose parameters were set for the k\n          // c     function above\n          // c     technically the below is correct but it's gross - KC\n          // c-----------------------------------------------------------------------\n          if (n > 2 && kk === n && ib < n) {\n            // do nothing\n          } else if (n > 2 && (kk === ib || kk === ic) || n <= 2) {\n            // 172   continue\n            phidr = phir[j - 1];\n            phidi = phii[j - 1];\n            argdr = argr[j - 1];\n            argdi = argi[j - 1];\n            zet1dr = zeta1r[j - 1];\n            zet1di = zeta1i[j - 1];\n            zet2dr = zeta2r[j - 1];\n            zet2di = zeta2i[j - 1];\n            asumdr = asumr[j - 1];\n            asumdi = asumi[j - 1];\n            bsumdr = bsumr[j - 1];\n            bsumdi = bsumi[j - 1];\n            j = 3 - j;\n          } else if (n > 2) {\n            var _zunhj5 = (0, _zunhj7.zunhj)(znr, zni, fn, 0, tol);\n\n            var _zunhj6 = _slicedToArray(_zunhj5, 12);\n\n            phidr = _zunhj6[0];\n            phidi = _zunhj6[1];\n            argdr = _zunhj6[2];\n            argdi = _zunhj6[3];\n            zet1dr = _zunhj6[4];\n            zet1di = _zunhj6[5];\n            zet2dr = _zunhj6[6];\n            zet2di = _zunhj6[7];\n            asumdr = _zunhj6[8];\n            asumdi = _zunhj6[9];\n            bsumdr = _zunhj6[10];\n            bsumdi = _zunhj6[11];\n          }\n          // 210 continue\n          if (kode === 1) {\n            s1r = -zet1dr + zet2dr;\n            s1i = -zet1di + zet2di;\n          } else {\n            str = zbr + zet2dr;\n            sti = zbi + zet2di;\n            rast = fn / (0, _zabs.azabs)(str, sti);\n            str = str * rast * rast;\n            sti = -sti * rast * rast;\n            s1r = -zet1dr + str;\n            s1i = -zet1di + sti;\n          }\n          // c-----------------------------------------------------------------------\n          // c     test for underflow and overflow\n          // c-----------------------------------------------------------------------\n          rs1 = s1r;\n          if (Math.abs(rs1) > elim) {\n            // go to 280\n            if (rs1 > 0.0) {\n              goToLabel = 320;break;\n            }\n            s2r = zeror;\n            s2i = zeroi;\n            // go to 250\n          } else {\n            if (kdflg === 1) iflag = 2;\n            if (Math.abs(rs1) < alim) {\n              // go to 240\n            } else {\n              // c-----------------------------------------------------------------------\n              // c     refine  test and scale\n              // c-----------------------------------------------------------------------\n              aphi = (0, _zabs.azabs)(phidr, phidi);\n              aarg = (0, _zabs.azabs)(argdr, argdi);\n              rs1 = rs1 + Math.log(aphi) - 0.25 * Math.log(aarg) - aic;\n              if (Math.abs(rs1) > elim) {\n                // go to 280\n                if (rs1 > 0.0) {\n                  goToLabel = 320;break;\n                }\n                s2r = zeror;\n                s2i = zeroi;\n                goToLabel = 250;\n              } else {\n                if (kdflg === 1) iflag = 1;\n                if (rs1 < 0.0) {\n                  // go to 240\n                } else {\n                  if (kdflg === 1) iflag = 3;\n                }\n              }\n            }\n            // 240   continue\n            if (goToLabel < 250) {\n              var _zairy5 = (0, _zairy9.zairy)(argdr, argdi, 0, 2);\n\n              var _zairy6 = _slicedToArray(_zairy5, 2);\n\n              air = _zairy6[0];\n              aii = _zairy6[1];\n\n              var _zairy7 = (0, _zairy9.zairy)(argdr, argdi, 1, 2);\n\n              var _zairy8 = _slicedToArray(_zairy7, 2);\n\n              dair = _zairy8[0];\n              daii = _zairy8[1];\n\n              str = dair * bsumdr - daii * bsumdi;\n              sti = dair * bsumdi + daii * bsumdr;\n              str = str + (air * asumdr - aii * asumdi);\n              sti = sti + (air * asumdi + aii * asumdr);\n              ptr = str * phidr - sti * phidi;\n              pti = str * phidi + sti * phidr;\n              s2r = ptr * csr - pti * csi;\n              s2i = ptr * csi + pti * csr;\n              str = Math.exp(s1r) * cssr[iflag - 1];\n              s1r = str * Math.cos(s1i);\n              s1i = str * Math.sin(s1i);\n              str = s2r * s1r - s2i * s1i;\n              s2i = s2r * s1i + s2i * s1r;\n              s2r = str;\n              if (iflag !== 1) {\n                // go to 250\n              } else {\n                nw = (0, _zuchk.zuchk)(s2r, s2i, bry[0], tol);\n                if (nw === 0) {\n                  // go to 250\n                } else {\n                  s2r = zeror;\n                  s2i = zeroi;\n                }\n              } // iflag !== 1\n            } // if should run 240?\n          } // if should skip straight to 250\n          // 250   continue\n          if (yy <= 0.0) s2i = -s2i;\n          cyr[kdflg - 1] = s2r;\n          cyi[kdflg - 1] = s2i;\n          c2r = s2r;\n          c2i = s2i;\n          s2r = s2r * csrr[iflag - 1];\n          s2i = s2i * csrr[iflag - 1];\n          // c-----------------------------------------------------------------------\n          // c     add i and k functions, k sequence in y(i), i=1,n\n          // c-----------------------------------------------------------------------\n          s1r = yr[kk - 1];\n          s1i = yi[kk - 1];\n          if (kode === 1) {\n            // go to 270\n          } else {\n            var _zs1s = (0, _zs1s5.zs1s2)(zrr, zri, s1r, s1i, s2r, s2i, asc, alim, iuf);\n\n            var _zs1s2 = _slicedToArray(_zs1s, 5);\n\n            s1r = _zs1s2[0];\n            s1i = _zs1s2[1];\n            s2r = _zs1s2[2];\n            s2i = _zs1s2[3];\n            nw = _zs1s2[4];\n\n            nz = nz + nw;\n          }\n          // 270   continue\n          yr[kk - 1] = s1r * cspnr - s1i * cspni + s2r;\n          yi[kk - 1] = s1r * cspni + s1i * cspnr + s2i;\n          kk = kk - 1;\n          cspnr = -cspnr;\n          cspni = -cspni;\n          str = csi;\n          csi = -csr;\n          csr = str;\n          if (c2r !== 0.0 || c2i !== 0.0) {\n            // go to 275\n          } else {\n            kdflg = 1;\n            break;\n          }\n          // 275   continue\n          if (kdflg === 2) {\n            goToLabel = 295;break;\n          }\n          kdflg = 2;\n          break;\n        }\n        // 290 continue\n        k = n;\n      case 295:\n        il = n - k;\n        if (il === 0) break mainExecutionLoop;\n        // c-----------------------------------------------------------------------\n        // c     recur backward for remainder of i sequence and add in the\n        // c     k functions, scaling the i sequence during recurrence to keep\n        // c     intermediate arithmetic on scale near exponent extremes.\n        // c-----------------------------------------------------------------------\n        s1r = cyr[0];\n        s1i = cyi[0];\n        s2r = cyr[1];\n        s2i = cyi[1];\n        csr = csrr[iflag - 1];\n        ascle = bry[iflag - 1];\n        fn = inu + il;\n        // do 310 i=1,il\n        for (i = 1; i <= il; i++) {\n          c2r = s2r;\n          c2i = s2i;\n          s2r = s1r + (fn + fnf) * (rzr * c2r - rzi * c2i);\n          s2i = s1i + (fn + fnf) * (rzr * c2i + rzi * c2r);\n          s1r = c2r;\n          s1i = c2i;\n          fn = fn - 1.0;\n          c2r = s2r * csr;\n          c2i = s2i * csr;\n          ckr = c2r;\n          cki = c2i;\n          c1r = yr[kk - 1];\n          c1i = yi[kk - 1];\n          if (kode === 1) {\n            // go to 300\n          } else {\n            var _zs1s3 = (0, _zs1s5.zs1s2)(zrr, zri, c1r, c1i, c2r, c2i, asc, alim, iuf);\n\n            var _zs1s4 = _slicedToArray(_zs1s3, 5);\n\n            c1r = _zs1s4[0];\n            c1i = _zs1s4[1];\n            c2r = _zs1s4[2];\n            c2i = _zs1s4[3];\n            nw = _zs1s4[4];\n\n            nz = nz + nw;\n          }\n          // 300   continue\n          yr[kk - 1] = c1r * cspnr - c1i * cspni + c2r;\n          yi[kk - 1] = c1r * cspni + c1i * cspnr + c2i;\n          kk = kk - 1;\n          cspnr = -cspnr;\n          cspni = -cspni;\n          if (iflag >= 3) break;\n          c2r = Math.abs(ckr);\n          c2i = Math.abs(cki);\n          c2m = Math.max(c2r, c2i);\n          if (c2m <= ascle) break;\n          iflag = iflag + 1;\n          ascle = bry[iflag - 1];\n          s1r = s1r * csr;\n          s1i = s1i * csr;\n          s2r = ckr;\n          s2i = cki;\n          s1r = s1r * cssr[iflag - 1];\n          s1i = s1i * cssr[iflag - 1];\n          s2r = s2r * cssr[iflag - 1];\n          s2i = s2i * cssr[iflag - 1];\n          csr = csrr[iflag - 1];\n        }\n        // 310 continue\n        break mainExecutionLoop;\n      case 320:\n        nz = -1;\n      default:\n        break mainExecutionLoop;\n    }\n  }\n\n  return nz;\n}\n},{\"../../utils/fortran-utils/d1mach.js\":91,\"../../utils/fortranHelpers.js\":93,\"./zabs.js\":11,\"./zairy.js\":14,\"./zs1s2.js\":33,\"./zuchk.js\":37,\"./zunhj.js\":38}],44:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); /* eslint-disable no-labels */\n/* eslint-disable no-fallthrough */\n// SUBROUTINE ZUOIK(ZR, ZI, FNU, KODE, IKFLG, N, YR, YI, NUF, TOL,\n// * ELIM, ALIM)\n// ***BEGIN PROLOGUE  ZUOIK\n// ***REFER TO  ZBESI,ZBESK,ZBESH\n//\n//      ZUOIK COMPUTES THE LEADING TERMS OF THE UNIFORM ASYMPTOTIC\n//      EXPANSIONS FOR THE I AND K FUNCTIONS AND COMPARES THEM\n//      (IN LOGARITHMIC FORM) TO ALIM AND ELIM FOR OVER AND UNDERFLOW\n//      WHERE ALIM.LT.ELIM. IF THE MAGNITUDE, BASED ON THE LEADING\n//      EXPONENTIAL, IS LESS THAN ALIM OR GREATER THAN -ALIM, THEN\n//      THE RESULT IS ON SCALE. IF NOT, THEN A REFINED TEST USING OTHER\n//      MULTIPLIERS (IN LOGARITHMIC FORM) IS MADE BASED ON ELIM. HERE\n//      EXP(-ELIM)=SMALLEST MACHINE NUMBER*1.0E+3 AND EXP(-ALIM)=\n//      EXP(-ELIM)/TOL\n//\n//      IKFLG=1 MEANS THE I SEQUENCE IS TESTED\n//           =2 MEANS THE K SEQUENCE IS TESTED\n//      NUF = 0 MEANS THE LAST MEMBER OF THE SEQUENCE IS ON SCALE\n//          =-1 MEANS AN OVERFLOW WOULD OCCUR\n//      IKFLG=1 AND NUF.GT.0 MEANS THE LAST NUF Y VALUES WERE SET TO ZERO\n//              THE FIRST N-NUF VALUES MUST BE SET BY ANOTHER ROUTINE\n//      IKFLG=2 AND NUF.EQ.N MEANS ALL Y VALUES WERE SET TO ZERO\n//      IKFLG=2 AND 0.LT.NUF.LT.N NOT CONSIDERED. Y MUST BE SET BY\n//              ANOTHER ROUTINE\n//\n// ***ROUTINES CALLED  ZUCHK,ZUNHJ,ZUNIK,D1MACH,AZABS,AZLOG\n// ***END PROLOGUE  ZUOIK\n//      COMPLEX ARG,ASUM,BSUM,CWRK,CZ,CZERO,PHI,SUM,Y,Z,ZB,ZETA1,ZETA2,ZN,\n//     *ZR\n\n\nexports.zuoik = zuoik;\n\nvar _d1mach = require('../../utils/fortran-utils/d1mach.js');\n\nvar _zabs = require('./zabs.js');\n\nvar _zlog = require('./zlog.js');\n\nvar _zuchk = require('./zuchk.js');\n\nvar _zunhj5 = require('./zunhj.js');\n\nvar _zunik5 = require('./zunik.js');\n\nfunction zuoik(zr, zi, fnu, kode, ikflg, n, yr, yi, tol, elim, alim) {\n  var aarg = void 0,\n      aic = void 0,\n      aphi = void 0,\n      argi = void 0,\n      argr = void 0,\n      ascle = void 0,\n      ax = void 0,\n      ay = void 0,\n      czi = void 0,\n      czr = void 0,\n      fnn = void 0,\n      gnn = void 0,\n      gnu = void 0,\n      phii = void 0,\n      phir = void 0,\n      rcz = void 0,\n      str = void 0,\n      sti = void 0,\n      zbi = void 0,\n      zbr = void 0,\n      zeroi = void 0,\n      zeror = void 0,\n      zeta1i = void 0,\n      zeta1r = void 0,\n      zeta2i = void 0,\n      zeta2r = void 0,\n      zni = void 0,\n      znr = void 0,\n      zri = void 0,\n      zrr = void 0,\n      i = void 0,\n      iform = void 0,\n      init = void 0,\n      nn = void 0,\n      nuf = void 0,\n      nw = void 0;\n\n  zeror = 0;\n  zeroi = 0;\n\n  aic = 1.265512123484645396;\n\n  var goToLabel = 0;\n  mainExecutionLoop: while (true) {\n    switch (goToLabel) {\n      case 0:\n        nuf = 0;\n        nn = n;\n        zrr = zr;\n        zri = zi;\n        if (zr >= 0.0) {\n          goToLabel = 10;break;\n        }\n        zrr = -zr;\n        zri = -zi;\n      case 10:\n        zbr = zrr;\n        zbi = zri;\n        ax = Math.abs(zr) * 1.7321;\n        ay = Math.abs(zi);\n        iform = 1;\n        if (ay > ax) iform = 2;\n        gnu = Math.max(fnu, 1.0);\n        if (ikflg === 1) {\n          goToLabel = 20;break;\n        }\n        fnn = nn;\n        gnn = fnu + fnn - 1.0;\n        gnu = Math.max(gnn, fnn);\n      case 20:\n        // c-----------------------------------------------------------------------\n        // c     only the magnitude of arg and phi are needed along with the\n        // c     real parts of zeta1, zeta2 and zb. no attempt is made to get\n        // c     the sign of the imaginary part correct.\n        // c-----------------------------------------------------------------------\n        if (iform === 2) {\n          goToLabel = 30;break;\n        }\n        init = 0;\n\n        var _zunik = (0, _zunik5.zunik)(zrr, zri, gnu, ikflg, 1, tol, init);\n\n        var _zunik2 = _slicedToArray(_zunik, 6);\n\n        phir = _zunik2[0];\n        phii = _zunik2[1];\n        zeta1r = _zunik2[2];\n        zeta1i = _zunik2[3];\n        zeta2r = _zunik2[4];\n        zeta2i = _zunik2[5];\n\n        czr = -zeta1r + zeta2r;\n        czi = -zeta1i + zeta2i;\n        goToLabel = 50;break;\n      case 30:\n        znr = zri;\n        zni = -zrr;\n        if (zi > 0.0) {\n          goToLabel = 40;break;\n        }\n        znr = -znr;\n      case 40:\n        var _zunhj = (0, _zunhj5.zunhj)(znr, zni, gnu, 1, tol);\n\n        var _zunhj2 = _slicedToArray(_zunhj, 8);\n\n        phir = _zunhj2[0];\n        phii = _zunhj2[1];\n        argr = _zunhj2[2];\n        argi = _zunhj2[3];\n        zeta1r = _zunhj2[4];\n        zeta1i = _zunhj2[5];\n        zeta2r = _zunhj2[6];\n        zeta2i = _zunhj2[7];\n\n        czr = -zeta1r + zeta2r;\n        czi = -zeta1i + zeta2i;\n        aarg = (0, _zabs.azabs)(argr, argi);\n      case 50:\n        if (kode === 1) {\n          goToLabel = 60;break;\n        }\n        czr = czr - zbr;\n        czi = czi - zbi;\n      case 60:\n        if (ikflg === 1) {\n          goToLabel = 70;break;\n        }\n        czr = -czr;\n        czi = -czi;\n      case 70:\n        aphi = (0, _zabs.azabs)(phir, phii);\n        rcz = czr;\n        // c-----------------------------------------------------------------------\n        // c     overflow test\n        // c-----------------------------------------------------------------------\n        if (rcz > elim) {\n          goToLabel = 210;break;\n        }\n        if (rcz < alim) {\n          goToLabel = 80;break;\n        }\n        rcz = rcz + Math.log(aphi);\n        if (iform === 2) rcz = rcz - 0.25 * Math.log(aarg) - aic;\n        if (rcz > elim) {\n          goToLabel = 210;break;\n        }\n        goToLabel = 130;break;\n      case 80:\n        // c-----------------------------------------------------------------------\n        // c     underflow test\n        // c-----------------------------------------------------------------------\n        if (rcz < -elim) {\n          goToLabel = 90;break;\n        }\n        if (rcz > -alim) {\n          goToLabel = 130;break;\n        }\n        rcz = rcz + Math.log(aphi);\n        if (iform === 2) rcz = rcz - 0.25 * Math.log(aarg) - aic;\n        if (rcz > -elim) {\n          goToLabel = 110;break;\n        }\n      case 90:\n        // do 100 i=1,nn\n        for (i = 1; i <= nn; i++) {\n          yr[i - 1] = zeror;\n          yi[i - 1] = zeroi;\n        }\n        // 100 dcontinue\n        nuf = nn;\n        break mainExecutionLoop;\n      case 110:\n        ascle = 1.0e+3 * (0, _d1mach.d1mach)(1) / tol;\n\n        var _azlog = (0, _zlog.azlog)(phir, phii);\n\n        var _azlog2 = _slicedToArray(_azlog, 2);\n\n        str = _azlog2[0];\n        sti = _azlog2[1];\n\n        czr = czr + str;\n        czi = czi + sti;\n        if (iform === 1) {\n          goToLabel = 120;break;\n        }\n\n        var _azlog3 = (0, _zlog.azlog)(argr, argi);\n\n        var _azlog4 = _slicedToArray(_azlog3, 2);\n\n        str = _azlog4[0];\n        sti = _azlog4[1];\n\n        czr = czr - 0.25 * str - aic;\n        czi = czi - 0.25 * sti;\n      case 120:\n        ax = Math.exp(rcz) / tol;\n        ay = czi;\n        czr = ax * Math.cos(ay);\n        czi = ax * Math.sin(ay);\n        nw = (0, _zuchk.zuchk)(czr, czi, ascle, tol);\n        if (nw !== 0) {\n          goToLabel = 90;break;\n        }\n      case 130:\n        if (ikflg === 2) break mainExecutionLoop;\n        if (n === 1) break mainExecutionLoop;\n      // c-----------------------------------------------------------------------\n      // c     set underflows on i sequence\n      // c-----------------------------------------------------------------------\n      case 140:\n        gnu = fnu + (nn - 1);\n        if (iform === 2) {\n          goToLabel = 150;break;\n        }\n        init = 0;\n\n        var _zunik3 = (0, _zunik5.zunik)(zrr, zri, gnu, ikflg, 1, tol, init);\n\n        var _zunik4 = _slicedToArray(_zunik3, 6);\n\n        phir = _zunik4[0];\n        phii = _zunik4[1];\n        zeta1r = _zunik4[2];\n        zeta1i = _zunik4[3];\n        zeta2r = _zunik4[4];\n        zeta2i = _zunik4[5];\n\n        czr = -zeta1r + zeta2r;\n        czi = -zeta1i + zeta2i;\n        goToLabel = 160;break;\n      case 150:\n        var _zunhj3 = (0, _zunhj5.zunhj)(znr, zni, gnu, 1, tol);\n\n        var _zunhj4 = _slicedToArray(_zunhj3, 8);\n\n        phir = _zunhj4[0];\n        phii = _zunhj4[1];\n        argr = _zunhj4[2];\n        argi = _zunhj4[3];\n        zeta1r = _zunhj4[4];\n        zeta1i = _zunhj4[5];\n        zeta2r = _zunhj4[6];\n        zeta2i = _zunhj4[7];\n\n        czr = -zeta1r + zeta2r;\n        czi = -zeta1i + zeta2i;\n        aarg = (0, _zabs.azabs)(argr, argi);\n      case 160:\n        if (kode === 1) {\n          goToLabel = 170;break;\n        }\n        czr = czr - zbr;\n        czi = czi - zbi;\n      case 170:\n        aphi = (0, _zabs.azabs)(phir, phii);\n        rcz = czr;\n        if (rcz < -elim) {\n          goToLabel = 180;break;\n        }\n        if (rcz > -alim) break mainExecutionLoop;\n        rcz = rcz + Math.log(aphi);\n        if (iform === 2) rcz = rcz - 0.25 * Math.log(aarg) - aic;\n        if (rcz > -elim) {\n          goToLabel = 190;break;\n        }\n      case 180:\n        yr[nn - 1] = zeror;\n        yi[nn - 1] = zeroi;\n        nn = nn - 1;\n        nuf = nuf + 1;\n        if (nn === 0) break mainExecutionLoop;\n        goToLabel = 140;break;\n      case 190:\n        ascle = 1.0e+3 * (0, _d1mach.d1mach)(1) / tol;\n\n        var _azlog5 = (0, _zlog.azlog)(phir, phii);\n\n        var _azlog6 = _slicedToArray(_azlog5, 2);\n\n        str = _azlog6[0];\n        sti = _azlog6[1];\n\n        czr = czr + str;\n        czi = czi + sti;\n        if (iform === 1) {\n          goToLabel = 200;break;\n        }\n\n        var _azlog7 = (0, _zlog.azlog)(argr, argi);\n\n        var _azlog8 = _slicedToArray(_azlog7, 2);\n\n        str = _azlog8[0];\n        sti = _azlog8[1];\n\n        czr = czr - 0.25 * str - aic;\n        czi = czi - 0.25 * sti;\n      case 200:\n        ax = Math.exp(rcz) / tol;\n        ay = czi;\n        czr = ax * Math.cos(ay);\n        czi = ax * Math.sin(ay);\n        nw = (0, _zuchk.zuchk)(czr, czi, ascle, tol);\n        if (nw !== 0) {\n          goToLabel = 180;break;\n        }\n        break mainExecutionLoop;\n      case 210:\n        nuf = -1;\n      default:\n        break mainExecutionLoop;\n    }\n  }\n\n  return nuf;\n}\n},{\"../../utils/fortran-utils/d1mach.js\":91,\"./zabs.js\":11,\"./zlog.js\":29,\"./zuchk.js\":37,\"./zunhj.js\":38,\"./zunik.js\":41}],45:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.zwrsk = zwrsk;\n\nvar _d1mach = require('../../utils/fortran-utils/d1mach.js');\n\nvar _zbknu = require('./zbknu.js');\n\nvar _zrati = require('./zrati.js');\n\nvar _zabs = require('./zabs.js');\n\n/* eslint-disable no-labels */\n/* eslint-disable no-fallthrough */\n// SUBROUTINE ZWRSK(ZRR, ZRI, FNU, KODE, N, YR, YI, NZ, CWR, CWI,\n// * TOL, ELIM, ALIM)\n// ***BEGIN PROLOGUE  ZWRSK\n// ***REFER TO  ZBESI,ZBESK\n//\n//      ZWRSK COMPUTES THE I BESSEL FUNCTION FOR RE(Z).GE.0.0 BY\n//      NORMALIZING THE I FUNCTION RATIOS FROM ZRATI BY THE WRONSKIAN\n//\n// ***ROUTINES CALLED  D1MACH,ZBKNU,ZRATI,AZABS\n// ***END PROLOGUE  ZWRSK\nfunction zwrsk(zrr, zri, fnu, kode, n, yr, yi, cwr, cwi, tol, elim, alim) {\n  var act = void 0,\n      acw = void 0,\n      ascle = void 0,\n      cinui = void 0,\n      cinur = void 0,\n      csclr = void 0,\n      cti = void 0,\n      ctr = void 0,\n      c1i = void 0,\n      c1r = void 0,\n      c2i = void 0,\n      c2r = void 0,\n      pti = void 0,\n      ptr = void 0,\n      ract = void 0,\n      sti = void 0,\n      str = void 0,\n      i = void 0,\n      nw = void 0,\n      nz = void 0;\n  cwr = new Array(2);\n  cwi = new Array(2);\n  var goToLabel = 0;\n  mainExecutionLoop: while (true) {\n    switch (goToLabel) {\n      case 0:\n        // c-----------------------------------------------------------------------\n        // c     i(fnu+i-1,z) by backward recurrence for ratios\n        // c     y(i)=i(fnu+i,z)/i(fnu+i-1,z) from crati normalized by the\n        // c     wronskian with k(fnu,z) and k(fnu+1,z) from cbknu.\n        // c-----------------------------------------------------------------------\n        nz = 0;\n        nw = (0, _zbknu.zbknu)(zrr, zri, fnu, kode, 2, cwr, cwi, tol, elim, alim);\n        if (nw !== 0) {\n          goToLabel = 50;break;\n        }\n        (0, _zrati.zrati)(zrr, zri, fnu, n, yr, yi, tol);\n        // c-----------------------------------------------------------------------\n        // c     recur forward on i(fnu+1,z) = r(fnu,z)*i(fnu,z),\n        // c     r(fnu+j-1,z)=y(j),  j=1,...,n\n        // c-----------------------------------------------------------------------\n        cinur = 1.0;\n        cinui = 0.0;\n        if (kode === 1) {\n          goToLabel = 10;break;\n        }\n        cinur = Math.cos(zri);\n        cinui = Math.sin(zri);\n      case 10:\n        // c-----------------------------------------------------------------------\n        // c     on low exponent machines the k functions can be close to both\n        // c     the under and overflow limits and the normalization must be\n        // c     scaled to prevent over or underflow. cuoik has determined that\n        // c     the result is on scale.\n        // c-----------------------------------------------------------------------\n        acw = (0, _zabs.azabs)(cwr[1], cwi[1]);\n        ascle = 1.0e+3 * (0, _d1mach.d1mach)(1) / tol;\n        csclr = 1.0;\n        if (acw > ascle) {\n          goToLabel = 20;break;\n        }\n        csclr = 1.0 / tol;\n        goToLabel = 30;break;\n      case 20:\n        ascle = 1.0 / ascle;\n        if (acw < ascle) {\n          goToLabel = 30;break;\n        }\n        csclr = tol;\n      case 30:\n        c1r = cwr[0] * csclr;\n        c1i = cwi[0] * csclr;\n        c2r = cwr[1] * csclr;\n        c2i = cwi[1] * csclr;\n        str = yr[0];\n        sti = yi[0];\n        // c-----------------------------------------------------------------------\n        // c     cinu=cinu*(conjg(ct)/cabs(ct))*(1.0/cabs(ct) prevents\n        // c     under- or overflow prematurely by squaring cabs(ct)\n        // c-----------------------------------------------------------------------\n        ptr = str * c1r - sti * c1i;\n        pti = str * c1i + sti * c1r;\n        ptr = ptr + c2r;\n        pti = pti + c2i;\n        ctr = zrr * ptr - zri * pti;\n        cti = zrr * pti + zri * ptr;\n        act = (0, _zabs.azabs)(ctr, cti);\n        ract = 1.0 / act;\n        ctr = ctr * ract;\n        cti = -cti * ract;\n        ptr = cinur * ract;\n        pti = cinui * ract;\n        cinur = ptr * ctr - pti * cti;\n        cinui = ptr * cti + pti * ctr;\n        yr[0] = cinur * csclr;\n        yi[0] = cinui * csclr;\n        if (n === 1) break mainExecutionLoop;\n        // do 40 i=2,n\n        for (i = 2; i <= n; i++) {\n          ptr = str * cinur - sti * cinui;\n          cinui = str * cinui + sti * cinur;\n          cinur = ptr;\n          str = yr[i - 1];\n          sti = yi[i - 1];\n          yr[i - 1] = cinur * csclr;\n          yi[i - 1] = cinui * csclr;\n        }\n        // 40 continue\n        break mainExecutionLoop;\n      case 50:\n        nz = -1;\n        if (nw === -2) nz = -2;\n      default:\n        break mainExecutionLoop;\n    }\n  }\n\n  return nz;\n}\n},{\"../../utils/fortran-utils/d1mach.js\":91,\"./zabs.js\":11,\"./zbknu.js\":23,\"./zrati.js\":32}],46:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nfunction gammasgn(x) {\n  var fx = void 0;\n\n  if (isNaN(x)) {\n    return x;\n  }\n  if (x > 0) {\n    return 1.0;\n  } else {\n    fx = Math.floor(x);\n    if (x - fx === 0.0) {\n      return 0.0;\n    } else if (fx % 2) {\n      return -1.0;\n    } else {\n      return 1.0;\n    }\n  }\n}\n\nexports.gammasgn = gammasgn;\n},{}],47:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.struveL = exports.struveH = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Compute the Struve function.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Notes\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * -----\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * We use three expansions for the Struve function discussed in [1]:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * - power series\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * - expansion in Bessel functions\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * - asymptotic large-z expansion\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Rounding errors are estimated based on the largest terms in the sums.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * ``struve_convergence.js`` *will* plot the convergence regions of the different\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * expansions (someday).\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * (i)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Looking at the error in the asymptotic expansion, one finds that\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * it's not worth trying if z ~> 0.7 * v + 12 for v > 0.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * (ii)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * The Bessel function expansion tends to fail for |z| >~ |v| and is not tried\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * there.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * For Struve H it covers the quadrant v > z where the power series may fail to\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * produce reasonable results.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * (iii)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * The three expansions together cover for Struve H the region z > 0, v real.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * They also cover Struve L, except that some loss of precision may occur around\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * the transition region z ~ 0.7 |v|, v < 0, |v| >> 1 where the function changes\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * rapidly.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * (iv)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * The power series is evaluated in double-double precision. This fixes accuracy\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * issues in Struve H for |v| << |z| before the asymptotic expansion kicks in.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Moreover, it improves the Struve L behavior for negative v.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * References\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * ----------\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * [1] NIST Digital Library of Mathematical Functions\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *     https://dlmf.nist.gov/11\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */\n\n/*\n * Copyright (C) 2013  Pauli Virtanen\n * Ported to ECMAScript 2018 by KC Erb\n * Copyright (C) 2018, Kings Distributed Systems\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * a. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * b. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * c. Neither the name of Enthought nor the names of the SciPy Developers\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n\nvar _gammasgn = require('./gammasgn.js');\n\nvar _gamma = require('../cephes/gamma.js');\n\nvar _lgam = require('../cephes/gamma/lgam.js');\n\nvar _cephes = require('../cephes.js');\n\nvar _cephes2 = _interopRequireDefault(_cephes);\n\nvar _dd = require('../cephes/dd.js');\n\nvar _dd2 = _interopRequireDefault(_dd);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar MAXITER = 10000;\nvar SUM_EPS = 1e-16; /* be sure we are in the tail of the sum */\nvar SUM_TINY = 1e-100;\nvar GOOD_EPS = 1e-12;\nvar ACCEPTABLE_EPS = 1e-7;\nvar ACCEPTABLE_ATOL = 1e-300;\n\nfunction struveH(v, z) {\n  return struveHL(v, z, 1);\n}\n\nfunction struveL(v, z) {\n  return struveHL(v, z, 0);\n}\n\nfunction struveHL(v, z, isH) {\n  var value = void 0,\n      err = void 0,\n      tmp = void 0,\n      n = void 0;\n  value = new Float64Array(4);\n  err = new Float64Array(4);\n\n  if (z < 0) {\n    n = Math.trunc(v);\n    if (v === n) {\n      tmp = n % 2 === 0 ? -1 : 1;\n      return tmp * struveHL(v, -z, isH);\n    } else {\n      return NaN;\n    }\n  } else if (z === 0) {\n    if (v < -1) {\n      return (0, _gammasgn.gammasgn)(v + 1.5) * Infinity;\n    } else if (v === -1) {\n      return 2 / Math.sqrt(Math.PI) / (0, _gamma.gamma)(0.5);\n    } else {\n      return 0;\n    }\n  }\n\n  n = -v - 0.5;\n  if (n === -v - 0.5 && n > 0) {\n    if (isH) {\n      return (n % 2 === 0 ? 1 : -1) * _cephes2.default.jv(n + 0.5, z);\n    } else {\n      return _cephes2.default.iv(n + 0.5, z);\n    }\n  }\n\n  /* Try the asymptotic expansion */\n  if (z >= 0.7 * v + 12) {\n    var _struveAsympLargeZ = struveAsympLargeZ(v, z, isH);\n\n    var _struveAsympLargeZ2 = _slicedToArray(_struveAsympLargeZ, 2);\n\n    value[0] = _struveAsympLargeZ2[0];\n    err[0] = _struveAsympLargeZ2[1];\n\n    if (err[0] < GOOD_EPS * Math.abs(value[0])) {\n      return value[0];\n    }\n  } else {\n    err[0] = Infinity;\n  }\n\n  /* Try power series */\n\n  var _struvePowerSeries = struvePowerSeries(v, z, isH);\n\n  var _struvePowerSeries2 = _slicedToArray(_struvePowerSeries, 2);\n\n  value[1] = _struvePowerSeries2[0];\n  err[1] = _struvePowerSeries2[1];\n\n  if (err[1] < GOOD_EPS * Math.abs(value[1])) {\n    return value[1];\n  }\n\n  /* Try bessel series */\n  if (Math.abs(z) < Math.abs(v) + 20) {\n    var _struveBesselSeries = struveBesselSeries(v, z, isH);\n\n    var _struveBesselSeries2 = _slicedToArray(_struveBesselSeries, 2);\n\n    value[2] = _struveBesselSeries2[0];\n    err[2] = _struveBesselSeries2[1];\n\n    if (err[2] < GOOD_EPS * Math.abs(value[2])) {\n      return value[2];\n    }\n  } else {\n    err[2] = Infinity;\n  }\n\n  /* Return the best of the three, if it is acceptable */\n  n = 0;\n  if (err[1] < err[n]) n = 1;\n  if (err[2] < err[n]) n = 2;\n  if (err[n] < ACCEPTABLE_EPS * Math.abs(value[n]) || err[n] < ACCEPTABLE_ATOL) {\n    return value[n];\n  }\n\n  /* Maybe it really is an overflow? */\n  tmp = -(0, _lgam.lgam)(v + 1.5) + (v + 1) * Math.log(z / 2);\n  if (!isH) {\n    tmp = Math.abs(tmp);\n  }\n  if (tmp > 700) {\n    // sf_error(\"struve\", SF_ERROR_OVERFLOW, \"overflow in series\");\n    return Infinity * (0, _gammasgn.gammasgn)(v + 1.5);\n  }\n\n  /* Failure */\n  // sf_error(\"struve\", SF_ERROR_NO_RESULT, \"total loss of precision\");\n  return NaN;\n}\n\n/*\n* Power series for Struve H and L\n* http://dlmf.nist.gov/11.2.1\n*\n* Starts to converge roughly at |n| > |z|\n*/\nfunction struvePowerSeries(v, z, isH) {\n  var n = void 0,\n      sgn = void 0,\n      term = void 0,\n      sum = void 0,\n      maxterm = void 0,\n      scaleexp = void 0,\n      tmp = void 0,\n      cterm = void 0,\n      csum = void 0,\n      cdiv = void 0,\n      z2 = void 0,\n      c2v = void 0,\n      ctmp = void 0,\n      err = void 0;\n\n  if (isH) {\n    sgn = -1;\n  } else {\n    sgn = 1;\n  }\n\n  tmp = -(0, _lgam.lgam)(v + 1.5) + (v + 1) * Math.log(z / 2);\n  if (tmp < -600 || tmp > 600) {\n    /* Scale exponent to postpone underflow/overflow */\n    scaleexp = tmp / 2;\n    tmp -= scaleexp;\n  } else {\n    scaleexp = 0;\n  }\n\n  term = 2 / Math.sqrt(Math.PI) * Math.exp(tmp) * (0, _gammasgn.gammasgn)(v + 1.5);\n  sum = term;\n  maxterm = 0;\n\n  cterm = _dd2.default.create(term);\n  csum = _dd2.default.create(sum);\n  z2 = _dd2.default.create(sgn * z * z);\n  c2v = _dd2.default.create(2 * v);\n\n  for (n = 0; n < MAXITER; ++n) {\n    /* cdiv = (3 + 2*n) * (3 + 2*n + 2*v)) */\n    cdiv = _dd2.default.create(3 + 2 * n);\n    ctmp = _dd2.default.create(3 + 2 * n);\n    ctmp = _dd2.default.add(ctmp, c2v);\n    cdiv = _dd2.default.mul(cdiv, ctmp);\n\n    /* cterm *= z2 / cdiv */\n    cterm = _dd2.default.mul(cterm, z2);\n    cterm = _dd2.default.div(cterm, cdiv);\n\n    csum = _dd2.default.add(csum, cterm);\n\n    term = _dd2.default.toDouble(cterm);\n    sum = _dd2.default.toDouble(csum);\n\n    if (Math.abs(term) > maxterm) {\n      maxterm = Math.abs(term);\n    }\n    if (Math.abs(term) < SUM_TINY * Math.abs(sum) || term === 0 || !isFinite(sum)) {\n      break;\n    }\n  }\n\n  err = Math.abs(term) + Math.abs(maxterm) * 1e-22;\n\n  if (scaleexp !== 0) {\n    sum *= Math.exp(scaleexp);\n    err *= Math.exp(scaleexp);\n  }\n\n  if (sum === 0 && term === 0 && v < 0 && !isH) {\n    /* Spurious underflow */\n    err = Infinity;\n    return [NaN, err];\n  }\n\n  return [sum, err];\n}\n\n/*\n* Bessel series\n* http://dlmf.nist.gov/11.4.19\n*/\nfunction struveBesselSeries(v, z, isH) {\n  var n = void 0,\n      term = void 0,\n      cterm = void 0,\n      sum = void 0,\n      maxterm = void 0,\n      err = void 0;\n\n  if (isH && v < 0) {\n    /* Works less reliably in this region */\n    err = Infinity;\n    return [NaN, err];\n  }\n\n  sum = 0;\n  maxterm = 0;\n\n  cterm = Math.sqrt(z / (2 * Math.PI));\n\n  for (n = 0; n < MAXITER; ++n) {\n    if (isH) {\n      term = cterm * _cephes2.default.jv(n + v + 0.5, z) / (n + 0.5);\n      cterm *= z / 2 / (n + 1);\n    } else {\n      term = cterm * _cephes2.default.iv(n + v + 0.5, z) / (n + 0.5);\n      cterm *= -z / 2 / (n + 1);\n    }\n    sum += term;\n    if (Math.abs(term) > maxterm) {\n      maxterm = Math.abs(term);\n    }\n    if (Math.abs(term) < SUM_EPS * Math.abs(sum) || term === 0 || !isFinite(sum)) {\n      break;\n    }\n  }\n\n  err = Math.abs(term) + Math.abs(maxterm) * 1e-16;\n\n  /* Account for potential underflow of the Bessel functions */\n  err += 1e-300 * Math.abs(cterm);\n\n  return [sum, err];\n}\n\n/*\n* Large-z expansion for Struve H and L\n* http://dlmf.nist.gov/11.6.1\n*/\nfunction struveAsympLargeZ(v, z, isH) {\n  var n = void 0,\n      sgn = void 0,\n      maxiter = void 0,\n      term = void 0,\n      sum = void 0,\n      maxterm = void 0,\n      m = void 0,\n      err = void 0;\n\n  if (isH) {\n    sgn = -1;\n  } else {\n    sgn = 1;\n  }\n\n  /* Asymptotic expansion divergenge point */\n  m = z / 2;\n  if (m <= 0) {\n    maxiter = 0;\n  } else if (m > MAXITER) {\n    maxiter = MAXITER;\n  } else {\n    maxiter = Math.trunc(m);\n  }\n  if (maxiter === 0) {\n    err = Infinity;\n    return [NaN, err];\n  }\n\n  if (z < v) {\n    /* Exclude regions where our error estimation fails */\n    err = Infinity;\n    return [NaN, err];\n  }\n\n  /* Evaluate sum */\n  term = -sgn / Math.sqrt(Math.PI) * Math.exp(-(0, _lgam.lgam)(v + 0.5) + (v - 1) * Math.log(z / 2)) * (0, _gammasgn.gammasgn)(v + 0.5);\n  sum = term;\n  maxterm = 0;\n\n  for (n = 0; n < maxiter; ++n) {\n    term *= sgn * (1 + 2 * n) * (1 + 2 * n - 2 * v) / (z * z);\n    sum += term;\n    if (Math.abs(term) > maxterm) {\n      maxterm = Math.abs(term);\n    }\n    if (Math.abs(term) < SUM_EPS * Math.abs(sum) || term === 0 || !isFinite(sum)) {\n      break;\n    }\n  }\n\n  if (isH) {\n    sum += _cephes2.default.yv(v, z);\n  } else {\n    sum += _cephes2.default.iv(v, z);\n  }\n\n  /*\n  * This error estimate is strictly speaking valid only for\n  * n > v - 0.5, but numerical results indicate that it works\n  * reasonably.\n  */\n  err = Math.abs(term) + Math.abs(maxterm) * 1e-16;\n\n  return [sum, err];\n}\n\nexports.struveH = struveH;\nexports.struveL = struveL;\n},{\"../cephes.js\":48,\"../cephes/dd.js\":52,\"../cephes/gamma.js\":55,\"../cephes/gamma/lgam.js\":56,\"./gammasgn.js\":46}],48:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _hyp2f = require('./cephes/hyp2f1.js');\n\nvar hyp2f1Cephes = _interopRequireWildcard(_hyp2f);\n\nvar _gamma = require('./cephes/gamma.js');\n\nvar gammaCephes = _interopRequireWildcard(_gamma);\n\nvar _j = require('./cephes/j0.js');\n\nvar j0Cephes = _interopRequireWildcard(_j);\n\nvar _j2 = require('./cephes/j1.js');\n\nvar j1Cephes = _interopRequireWildcard(_j2);\n\nvar _jv = require('./cephes/jv.js');\n\nvar jvCephes = _interopRequireWildcard(_jv);\n\nvar _yn = require('./cephes/yn.js');\n\nvar ynCephes = _interopRequireWildcard(_yn);\n\nvar _yv = require('./cephes/yv.js');\n\nvar yvCephes = _interopRequireWildcard(_yv);\n\nvar _i = require('./cephes/i0.js');\n\nvar i0Cephes = _interopRequireWildcard(_i);\n\nvar _i2 = require('./cephes/i1.js');\n\nvar i1Cephes = _interopRequireWildcard(_i2);\n\nvar _iv = require('./cephes/iv.js');\n\nvar ivCephes = _interopRequireWildcard(_iv);\n\nvar _k = require('./cephes/k0.js');\n\nvar k0Cephes = _interopRequireWildcard(_k);\n\nvar _k2 = require('./cephes/k1.js');\n\nvar k1Cephes = _interopRequireWildcard(_k2);\n\nvar _kn = require('./cephes/kn.js');\n\nvar knCephes = _interopRequireWildcard(_kn);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// TODO discuss this pattern, we just want a little namespacing in the long run\n// this is just a quick and dirty way to get some before we design the API\nvar Cephes = function () {\n  function Cephes() {\n    _classCallCheck(this, Cephes);\n  }\n\n  _createClass(Cephes, null, [{\n    key: 'hyp2f1',\n    value: function hyp2f1(a, b, c, x) {\n      return hyp2f1Cephes.hyp2f1(a, b, c, x);\n    }\n  }, {\n    key: 'gamma',\n    value: function gamma(x) {\n      return gammaCephes.gamma(x);\n    }\n  }, {\n    key: 'j0',\n    value: function j0(x) {\n      return j0Cephes.j0(x);\n    }\n  }, {\n    key: 'j1',\n    value: function j1(x) {\n      return j1Cephes.j1(x);\n    }\n  }, {\n    key: 'jv',\n    value: function jv(n, x) {\n      return jvCephes.jv(n, x);\n    }\n  }, {\n    key: 'y0',\n    value: function y0(x) {\n      return j0Cephes.y0(x);\n    }\n  }, {\n    key: 'y1',\n    value: function y1(x) {\n      return j1Cephes.y1(x);\n    }\n  }, {\n    key: 'yn',\n    value: function yn(n, x) {\n      return ynCephes.yn(n, x);\n    }\n  }, {\n    key: 'yv',\n    value: function yv(n, x) {\n      return yvCephes.yv(n, x);\n    }\n  }, {\n    key: 'i0',\n    value: function i0(x) {\n      return i0Cephes.i0(x);\n    }\n  }, {\n    key: 'ie',\n    value: function ie(x) {\n      return i0Cephes.i0e(x);\n    }\n  }, {\n    key: 'i1',\n    value: function i1(x) {\n      return i1Cephes.i1(x);\n    }\n  }, {\n    key: 'i1e',\n    value: function i1e(x) {\n      return i1Cephes.i1e(x);\n    }\n  }, {\n    key: 'iv',\n    value: function iv(v, x) {\n      return ivCephes.iv(v, x);\n    }\n  }, {\n    key: 'k0',\n    value: function k0(x) {\n      return k0Cephes.k0(x);\n    }\n  }, {\n    key: 'k0e',\n    value: function k0e(x) {\n      return k0Cephes.k0e(x);\n    }\n  }, {\n    key: 'k1',\n    value: function k1(x) {\n      return k1Cephes.k1(x);\n    }\n  }, {\n    key: 'k1e',\n    value: function k1e(x) {\n      return k1Cephes.k1e(x);\n    }\n  }, {\n    key: 'kn',\n    value: function kn(n, x) {\n      return knCephes.kn(n, x);\n    }\n  }]);\n\n  return Cephes;\n}();\n\nexports.default = Cephes;\n},{\"./cephes/gamma.js\":55,\"./cephes/hyp2f1.js\":57,\"./cephes/i0.js\":62,\"./cephes/i1.js\":63,\"./cephes/iv.js\":64,\"./cephes/j0.js\":67,\"./cephes/j1.js\":68,\"./cephes/jv.js\":69,\"./cephes/k0.js\":75,\"./cephes/k1.js\":76,\"./cephes/kn.js\":77,\"./cephes/yn.js\":80,\"./cephes/yv.js\":81}],49:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.airy = airy;\n\nvar _polevl = require('./polevl.js');\n\nvar _constants = require('./constants.js');\n\nvar constants = _interopRequireWildcard(_constants);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n// translator's note:\n// return ai-bip as array + return flag to match original (-1 = error, 0 = normal)\n/**\n * @file        airy.js        Airy function\n *\n *\n *\n * SYNOPSIS:\n *\n * double x, ai, aip, bi, bip;\n * int airy();\n *\n * airy( x, _&ai, _&aip, _&bi, _&bip );\n *\n *\n *\n * DESCRIPTION:\n *\n * Solution of the differential equation\n *\n *     y\"(x) = xy.\n *\n * The function returns the two independent solutions Ai, Bi\n * and their first derivatives Ai'(x), Bi'(x).\n *\n * Evaluation is by power series summation for small x,\n * by rational minimax approximations for large x.\n *\n *\n *\n * ACCURACY:\n * Error criterion is absolute when function <= 1, relative\n * when function > 1, except * denotes relative error criterion.\n * For large negative x, the absolute error increases as x^1.5.\n * For large positive x, the relative error increases as x^1.5.\n *\n * Arithmetic  domain   function  # trials      peak         rms\n * IEEE        -10, 0     Ai        10000       1.6e-15     2.7e-16\n * IEEE          0, 10    Ai        10000       2.3e-14*    1.8e-15*\n * IEEE        -10, 0     Ai'       10000       4.6e-15     7.6e-16\n * IEEE          0, 10    Ai'       10000       1.8e-14*    1.5e-15*\n * IEEE        -10, 10    Bi        30000       4.2e-15     5.3e-16\n * IEEE        -10, 10    Bi'       30000       4.9e-15     7.3e-16\n *\n *\n * Cephes Math Library Release 2.8:  June, 2000\n * Copyright 1984, 1987, 1989, 2000 by Stephen L. Moshier\n * Ported to ECMAScript 2018\n * Copyright (c) 2018, Kings Distributed Systems\n *\n * @author      KC Erb, kc@kcerb.com\n * @date        April 2018\n */\nfunction airy(x, ai, aip, bi, bip) {\n  var c1 = 0.35502805388781723926;\n  var c2 = 0.258819403792806798405;\n  var sqrt3 = 1.732050807568877293527;\n  var sqpii = 5.64189583547756286948E-1;\n  var MAXAIRY = 103.892;\n\n  var AN = [3.46538101525629032477E-1, 1.20075952739645805542E1, 7.62796053615234516538E1, 1.68089224934630576269E2, 1.59756391350164413639E2, 7.05360906840444183113E1, 1.40264691163389668864E1, 9.99999999999999995305E-1];\n\n  var AD = [5.67594532638770212846E-1, 1.47562562584847203173E1, 8.45138970141474626562E1, 1.77318088145400459522E2, 1.64234692871529701831E2, 7.14778400825575695274E1, 1.40959135607834029598E1, 1.00000000000000000470E0];\n\n  var APN = [6.13759184814035759225E-1, 1.47454670787755323881E1, 8.20584123476060982430E1, 1.71184781360976385540E2, 1.59317847137141783523E2, 6.99778599330103016170E1, 1.39470856980481566958E1, 1.00000000000000000550E0];\n\n  var APD = [3.34203677749736953049E-1, 1.11810297306158156705E1, 7.11727352147859965283E1, 1.58778084372838313640E2, 1.53206427475809220834E2, 6.86752304592780337944E1, 1.38498634758259442477E1, 9.99999999999999994502E-1];\n\n  var BN16 = [-2.53240795869364152689E-1, 5.75285167332467384228E-1, -3.29907036873225371650E-1, 6.44404068948199951727E-2, -3.82519546641336734394E-3];\n\n  var BD16 = [\n  /* 1.00000000000000000000E0, */\n  -7.15685095054035237902E0, 1.06039580715664694291E1, -5.23246636471251500874E0, 9.57395864378383833152E-1, -5.50828147163549611107E-2];\n\n  var BPPN = [4.65461162774651610328E-1, -1.08992173800493920734E0, 6.38800117371827987759E-1, -1.26844349553102907034E-1, 7.62487844342109852105E-3];\n\n  var BPPD = [\n  /* 1.00000000000000000000E0, */\n  -8.70622787633159124240E0, 1.38993162704553213172E1, -7.14116144616431159572E0, 1.34008595960680518666E0, -7.84273211323341930448E-2];\n\n  var AFN = [-1.31696323418331795333E-1, -6.26456544431912369773E-1, -6.93158036036933542233E-1, -2.79779981545119124951E-1, -4.91900132609500318020E-2, -4.06265923594885404393E-3, -1.59276496239262096340E-4, -2.77649108155232920844E-6, -1.67787698489114633780E-8];\n\n  var AFD = [\n  /* 1.00000000000000000000E0, */\n  1.33560420706553243746E1, 3.26825032795224613948E1, 2.67367040941499554804E1, 9.18707402907259625840E0, 1.47529146771666414581E0, 1.15687173795188044134E-1, 4.40291641615211203805E-3, 7.54720348287414296618E-5, 4.51850092970580378464E-7];\n\n  var AGN = [1.97339932091685679179E-2, 3.91103029615688277255E-1, 1.06579897599595591108E0, 9.39169229816650230044E-1, 3.51465656105547619242E-1, 6.33888919628925490927E-2, 5.85804113048388458567E-3, 2.82851600836737019778E-4, 6.98793669997260967291E-6, 8.11789239554389293311E-8, 3.41551784765923618484E-10];\n\n  var AGD = [\n  /*  1.00000000000000000000E0, */\n  9.30892908077441974853E0, 1.98352928718312140417E1, 1.55646628932864612953E1, 5.47686069422975497931E0, 9.54293611618961883998E-1, 8.64580826352392193095E-2, 4.12656523824222607191E-3, 1.01259085116509135510E-4, 1.17166733214413521882E-6, 4.91834570062930015649E-9];\n\n  var APFN = [1.85365624022535566142E-1, 8.86712188052584095637E-1, 9.87391981747398547272E-1, 4.01241082318003734092E-1, 7.10304926289631174579E-2, 5.90618657995661810071E-3, 2.33051409401776799569E-4, 4.08718778289035454598E-6, 2.48379932900442457853E-8];\n\n  var APFD = [\n  /*  1.00000000000000000000E0, */\n  1.47345854687502542552E1, 3.75423933435489594466E1, 3.14657751203046424330E1, 1.09969125207298778536E1, 1.78885054766999417817E0, 1.41733275753662636873E-1, 5.44066067017226003627E-3, 9.39421290654511171663E-5, 5.65978713036027009243E-7];\n\n  var APGN = [-3.55615429033082288335E-2, -6.37311518129435504426E-1, -1.70856738884312371053E0, -1.50221872117316635393E0, -5.63606665822102676611E-1, -1.02101031120216891789E-1, -9.48396695961445269093E-3, -4.60325307486780994357E-4, -1.14300836484517375919E-5, -1.33415518685547420648E-7, -5.63803833958893494476E-10];\n\n  var APGD = [\n  /*  1.00000000000000000000E0, */\n  9.85865801696130355144E0, 2.16401867356585941885E1, 1.73130776389749389525E1, 6.17872175280828766327E0, 1.08848694396321495475E0, 9.95005543440888479402E-2, 4.78468199683886610842E-3, 1.18159633322838625562E-4, 1.37480673554219441465E-6, 5.79912514929147598821E-9];\n\n  var z = void 0,\n      zz = void 0,\n      t = void 0,\n      f = void 0,\n      g = void 0,\n      uf = void 0,\n      ug = void 0,\n      k = void 0,\n      zeta = void 0,\n      theta = void 0,\n      domflg = void 0;\n\n  domflg = 0;\n  if (x > MAXAIRY) {\n    return [ai, aip, bi, bip, -1];\n  }\n\n  if (x < -2.09) {\n    domflg = 15;\n    t = Math.sqrt(-x);\n    zeta = -2.0 * x * t / 3.0;\n    t = Math.sqrt(t);\n    k = sqpii / t;\n    z = 1.0 / zeta;\n    zz = z * z;\n    uf = 1.0 + zz * (0, _polevl.polevl)(zz, AFN, 8) / (0, _polevl.p1evl)(zz, AFD, 9);\n    ug = z * (0, _polevl.polevl)(zz, AGN, 10) / (0, _polevl.p1evl)(zz, AGD, 10);\n    theta = zeta + 0.25 * Math.PI;\n    f = Math.sin(theta);\n    g = Math.cos(theta);\n    ai = k * (f * uf - g * ug);\n    bi = k * (g * uf + f * ug);\n    uf = 1.0 + zz * (0, _polevl.polevl)(zz, APFN, 8) / (0, _polevl.p1evl)(zz, APFD, 9);\n    ug = z * (0, _polevl.polevl)(zz, APGN, 10) / (0, _polevl.p1evl)(zz, APGD, 10);\n    k = sqpii * t;\n    aip = -k * (g * uf + f * ug);\n    bip = k * (f * uf - g * ug);\n    return [ai, aip, bi, bip, 0];\n  }\n\n  if (x >= 2.09) {\n    /* cbrt(9) */\n    domflg = 5;\n    t = Math.sqrt(x);\n    zeta = 2.0 * x * t / 3.0;\n    g = Math.exp(zeta);\n    t = Math.sqrt(t);\n    k = 2.0 * t * g;\n    z = 1.0 / zeta;\n    f = (0, _polevl.polevl)(z, AN, 7) / (0, _polevl.polevl)(z, AD, 7);\n    ai = sqpii * f / k;\n    k = -0.5 * sqpii * t / g;\n    f = (0, _polevl.polevl)(z, APN, 7) / (0, _polevl.polevl)(z, APD, 7);\n    aip = f * k;\n\n    if (x > 8.3203353) {\n      /* zeta > 16 */\n      f = z * (0, _polevl.polevl)(z, BN16, 4) / (0, _polevl.p1evl)(z, BD16, 5);\n      k = sqpii * g;\n      bi = k * (1.0 + f) / t;\n      f = z * (0, _polevl.polevl)(z, BPPN, 4) / (0, _polevl.p1evl)(z, BPPD, 5);\n      bip = k * t * (1.0 + f);\n      return [ai, aip, bi, bip, 0];\n    }\n  }\n\n  f = 1.0;\n  g = x;\n  t = 1.0;\n  uf = 1.0;\n  ug = x;\n  k = 1.0;\n  z = x * x * x;\n  while (t > constants.MACHEP) {\n    uf *= z;\n    k += 1.0;\n    uf /= k;\n    ug *= z;\n    k += 1.0;\n    ug /= k;\n    uf /= k;\n    f += uf;\n    k += 1.0;\n    ug /= k;\n    g += ug;\n    t = Math.abs(uf / f);\n  }\n  uf = c1 * f;\n  ug = c2 * g;\n\n  if ((domflg & 1) === 0) ai = uf - ug;\n  if ((domflg & 2) === 0) bi = sqrt3 * (uf + ug);\n\n  /* the deriviative of ai */\n  k = 4.0;\n  uf = x * x / 2.0;\n  ug = z / 3.0;\n  f = uf;\n  g = 1.0 + ug;\n  uf /= 3.0;\n  t = 1.0;\n\n  while (t > constants.MACHEP) {\n    uf *= z;\n    ug /= k;\n    k += 1.0;\n    ug *= z;\n    uf /= k;\n    f += uf;\n    k += 1.0;\n    ug /= k;\n    uf /= k;\n    g += ug;\n    k += 1.0;\n    t = Math.abs(ug / g);\n  }\n\n  uf = c1 * f;\n  ug = c2 * g;\n  if ((domflg & 4) === 0) aip = uf - ug;\n  if ((domflg & 8) === 0) bip = sqrt3 * (uf + ug);\n  return [ai, aip, bi, bip, 0];\n}\n},{\"./constants.js\":51,\"./polevl.js\":78}],50:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @file        chbevl.js        Evaluate Chebyshev series\n *\n *\n *\n *\n * SYNOPSIS:\n *\n * int N;\n * double x, y, coef[N], chebevl();\n *\n * y = chbevl( x, coef, N );\n *\n *\n *\n * DESCRIPTION:\n *\n * Evaluates the series\n *\n *        N-1\n *         - '\n *  y  =   >   coef[i] T (x/2)\n *         -            i\n *        i=0\n *\n * of Chebyshev polynomials Ti at argument x/2.\n *\n * Coefficients are stored in reverse order, i.e. the zero\n * order term is last in the array.  Note N is the number of\n * coefficients, not the order.\n *\n * If coefficients are for the interval a to b, x must\n * have been transformed to x -> 2(2x - b - a)/(b-a) before\n * entering the routine.  This maps x from (a, b) to (-1, 1),\n * over which the Chebyshev polynomials are defined.\n *\n * If the coefficients are for the inverted interval, in\n * which (a, b) is mapped to (1/b, 1/a), the transformation\n * required is x -> 2(2ab/x - b - a)/(b-a).  If b is infinity,\n * this becomes x -> 4a/x - 1.\n *\n *\n *\n * SPEED:\n *\n * Taking advantage of the recurrence properties of the\n * Chebyshev polynomials, the routine requires one more\n * addition per loop than evaluating a nested polynomial of\n * the same degree.\n *\n *\n * Cephes Math Library Release 2.0:  April, 1987\n * Copyright 1985, 1987 by Stephen L. Moshier\n * Ported to ECMAScript 2018\n * Copyright (c) 2018, Kings Distributed Systems\n *\n * @author      KC Erb, kc@kcerb.com\n * @date        April 2018\n */\nfunction chbevl(x, array, n) {\n  var b0 = void 0,\n      b1 = void 0,\n      b2 = void 0,\n      i = void 0;\n\n  b0 = array[0];\n  b1 = 0.0;\n\n  for (i = 1; i < n; i++) {\n    b2 = b1;\n    b1 = b0;\n    b0 = x * b1 - b2 + array[i];\n  }\n\n  return 0.5 * (b0 - b2);\n}\n\nexports.chbevl = chbevl;\n},{}],51:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar MACHEP = exports.MACHEP = Number.EPSILON / 2;\nvar DBL_MAX = exports.DBL_MAX = Number.MAX_VALUE;\nvar MAXLOG = exports.MAXLOG = 7.09782712893383996843E2;\nvar MINLOG = exports.MINLOG = -7.08396418532264106224E2;\nvar SQ2OPI = exports.SQ2OPI = 7.9788456080286535587989E-1; // sqrt( 2/pi )\nvar LOGSQ2 = exports.LOGSQ2 = 3.46573590279972654709E-1; // log(2)/2\nvar THPIO4 = exports.THPIO4 = 2.35619449019234492885; // 3*pi/4\nvar NPY_PI_4 = exports.NPY_PI_4 = 0.78539816339744830962; // pi / 4\nvar NPY_2_PI = exports.NPY_2_PI = 0.63661977236758134308; // 2 / pi\nvar MAXGAM = exports.MAXGAM = 171.624376956302725;\nvar SQTPI = exports.SQTPI = 2.50662827463100050242E0;\nvar LS2PI = exports.LS2PI = 0.918938533204672; /* log( sqrt( 2*pi ) ) */\nvar EULER = exports.EULER = 0.57721566490153286061;\nvar MAXITER = exports.MAXITER = 500;\n},{}],52:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // This is a (currently) brief translation of the Double-double precision\n// arithmetic package in cephes. For now we'll add the methods we need and let\n// it grow naturally.\n\n\nvar _ddRealIdefs = require('./dd/ddRealIdefs.js');\n\nvar ddRealIdefs = _interopRequireWildcard(_ddRealIdefs);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar DD = function () {\n  function DD() {\n    _classCallCheck(this, DD);\n  }\n\n  _createClass(DD, null, [{\n    key: 'create',\n    value: function create(hi) {\n      var low = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return [hi, low];\n    }\n  }, {\n    key: 'toDouble',\n    value: function toDouble(a) {\n      return a[0];\n    }\n    // TODO - let these accept non double-double args or at least do error checking\n    // that they are both double doubles (i.e. arrays)\n\n  }, {\n    key: 'add',\n    value: function add(a, b) {\n      return ddRealIdefs.ddAdd(a, b);\n    }\n  }, {\n    key: 'sub',\n    value: function sub(a, b) {\n      return ddRealIdefs.ddSub(a, b);\n    }\n  }, {\n    key: 'mul',\n    value: function mul(a, b) {\n      return ddRealIdefs.ddMul(a, b);\n    }\n  }, {\n    key: 'div',\n    value: function div(a, b) {\n      return ddRealIdefs.ddDiv(a, b);\n    }\n  }]);\n\n  return DD;\n}();\n\nexports.default = DD;\n},{\"./dd/ddRealIdefs.js\":54}],53:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\n/*\n * Ported to ECMAScript 2018 by KC Erb of Kings Distributed Systems from\n * original C code which contained the following:\n *\n * This work was supported by the Director, Office of Science, Division\n * of Mathematical, Information, and Computational Sciences of the\n * U.S. Department of Energy under contract numbers DE-AC03-76SF00098 and\n * DE-AC02-05CH11231.\n *\n * Copyright (c) 2003-2009, The Regents of the University of California,\n * through Lawrence Berkeley National Laboratory (subject to receipt of\n * any required approvals from U.S. Dept. of Energy) All rights reserved.\n *\n * By downloading or using this software you are agreeing to the modified\n * BSD license \"BSD-LBNL-License.doc\" (see LICENSE.txt).\n */\n/*\n * Contains small functions (suitable for inlining) in the double-double\n * arithmetic package.\n */\nvar _DD_SPLIT_THRESH = 6.69692879491417e+299; // = 2^996\nvar _DD_SPLITTER = 134217729.0; // = 2^27 + 1\n\nfunction twoSum(a, b) {\n  var s = a + b;\n  var c = s - a;\n  var d = b - c;\n  var e = s - c;\n  var err = a - e + d;\n  return [s, err];\n}\n\nfunction quickTwoSum(a, b) {\n  var s = a + b;\n  var c = s - a;\n  var err = b - c;\n  return [s, err];\n}\n\n/* Computes fl(a*b) and err(a*b). */\nfunction twoProd(a, b) {\n  var aHi = void 0,\n      aLo = void 0,\n      bHi = void 0,\n      bLo = void 0,\n      c = void 0,\n      d = void 0,\n      err = void 0;\n  var p = a * b;\n\n  var _twoSplit = twoSplit(a);\n\n  var _twoSplit2 = _slicedToArray(_twoSplit, 2);\n\n  aHi = _twoSplit2[0];\n  aLo = _twoSplit2[1];\n\n  var _twoSplit3 = twoSplit(b);\n\n  var _twoSplit4 = _slicedToArray(_twoSplit3, 2);\n\n  bHi = _twoSplit4[0];\n  bLo = _twoSplit4[1];\n\n  c = aHi * bHi - p;\n  d = c + aHi * bLo + aLo * bHi;\n  err = d + aLo * bLo;\n  return [p, err];\n}\n\n/* Computes high word and lo word of a */\nfunction twoSplit(a) {\n  var temp = void 0,\n      tempma = void 0,\n      hi = void 0,\n      lo = void 0;\n  if (a > _DD_SPLIT_THRESH || a < -_DD_SPLIT_THRESH) {\n    a *= 3.7252902984619140625e-09; // 2^-28\n    temp = _DD_SPLITTER * a;\n    tempma = temp - a;\n    hi = temp - tempma;\n    lo = a - hi;\n    hi *= 268435456.0; // 2^28\n    lo *= 268435456.0; // 2^28\n  } else {\n    temp = _DD_SPLITTER * a;\n    tempma = temp - a;\n    hi = temp - tempma;\n    lo = a - hi;\n  }\n  return [hi, lo];\n}\n\nexports.twoSum = twoSum;\nexports.quickTwoSum = quickTwoSum;\nexports.twoProd = twoProd;\n},{}],54:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ddDiv = exports.ddMul = exports.ddSub = exports.ddAdd = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Ported to ECMAScript 2018 by KC Erb of Kings Distributed Systems from\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * original C code which contained the following:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * This work was supported by the Director, Office of Science, Division\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * of Mathematical, Information, and Computational Sciences of the\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * U.S. Department of Energy under contract numbers DE-AC03-76SF00098 and\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * DE-AC02-05CH11231.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright (c) 2003-2009, The Regents of the University of California,\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * through Lawrence Berkeley National Laboratory (subject to receipt of\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * any required approvals from U.S. Dept. of Energy) All rights reserved.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * By downloading or using this software you are agreeing to the modified\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * BSD license \"BSD-LBNL-License.doc\" (see LICENSE.txt).\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */\n/*\n * Contains small functions (suitable for inlining) in the double-double\n * arithmetic package.\n */\n\n\nvar _ddIdefs = require('./ddIdefs.js');\n\nvar ddIdefs = _interopRequireWildcard(_ddIdefs);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction ddNeg(a) {\n  return [-a[0], -a[1]];\n}\n\n// dd_ieee_add in orig\nfunction ddAdd(a, b) {\n  var s1 = void 0,\n      s2 = void 0,\n      t1 = void 0,\n      t2 = void 0;\n\n  var _ddIdefs$twoSum = ddIdefs.twoSum(a[0], b[0]);\n\n  var _ddIdefs$twoSum2 = _slicedToArray(_ddIdefs$twoSum, 2);\n\n  s1 = _ddIdefs$twoSum2[0];\n  s2 = _ddIdefs$twoSum2[1];\n\n  var _ddIdefs$twoSum3 = ddIdefs.twoSum(a[1], b[1]);\n\n  var _ddIdefs$twoSum4 = _slicedToArray(_ddIdefs$twoSum3, 2);\n\n  t1 = _ddIdefs$twoSum4[0];\n  t2 = _ddIdefs$twoSum4[1];\n\n  s2 += t1;\n\n  var _ddIdefs$quickTwoSum = ddIdefs.quickTwoSum(s1, s2);\n\n  var _ddIdefs$quickTwoSum2 = _slicedToArray(_ddIdefs$quickTwoSum, 2);\n\n  s1 = _ddIdefs$quickTwoSum2[0];\n  s2 = _ddIdefs$quickTwoSum2[1];\n\n  s2 += t2;\n\n  var _ddIdefs$quickTwoSum3 = ddIdefs.quickTwoSum(s1, s2);\n\n  var _ddIdefs$quickTwoSum4 = _slicedToArray(_ddIdefs$quickTwoSum3, 2);\n\n  s1 = _ddIdefs$quickTwoSum4[0];\n  s2 = _ddIdefs$quickTwoSum4[1];\n\n  return [s1, s2];\n}\n\n// first arg double2[], second arg double\nfunction ddAddDdD(a, b) {\n  var s1 = void 0,\n      s2 = void 0;\n\n  var _ddIdefs$twoSum5 = ddIdefs.twoSum(a[0], b);\n\n  var _ddIdefs$twoSum6 = _slicedToArray(_ddIdefs$twoSum5, 2);\n\n  s1 = _ddIdefs$twoSum6[0];\n  s2 = _ddIdefs$twoSum6[1];\n\n  s2 += a[1];\n\n  var _ddIdefs$quickTwoSum5 = ddIdefs.quickTwoSum(s1, s2);\n\n  var _ddIdefs$quickTwoSum6 = _slicedToArray(_ddIdefs$quickTwoSum5, 2);\n\n  s1 = _ddIdefs$quickTwoSum6[0];\n  s2 = _ddIdefs$quickTwoSum6[1];\n\n  return [s1, s2];\n}\n\nfunction ddSub(a, b) {\n  return ddAdd(a, ddNeg(b));\n}\n\nfunction ddMul(a, b) {\n  var p1 = void 0,\n      p2 = void 0;\n\n  var _ddIdefs$twoProd = ddIdefs.twoProd(a[0], b[0]);\n\n  var _ddIdefs$twoProd2 = _slicedToArray(_ddIdefs$twoProd, 2);\n\n  p1 = _ddIdefs$twoProd2[0];\n  p2 = _ddIdefs$twoProd2[1];\n\n  p2 += a[0] * b[1] + a[1] * b[0];\n\n  var _ddIdefs$quickTwoSum7 = ddIdefs.quickTwoSum(p1, p2);\n\n  var _ddIdefs$quickTwoSum8 = _slicedToArray(_ddIdefs$quickTwoSum7, 2);\n\n  p1 = _ddIdefs$quickTwoSum8[0];\n  p2 = _ddIdefs$quickTwoSum8[1];\n\n  return [p1, p2];\n}\n\n// first arg double2[], second arg double\nfunction ddMulDdD(a, b) {\n  var p1 = void 0,\n      p2 = void 0,\n      e1 = void 0,\n      e2 = void 0;\n\n  var _ddIdefs$twoProd3 = ddIdefs.twoProd(a[0], b);\n\n  var _ddIdefs$twoProd4 = _slicedToArray(_ddIdefs$twoProd3, 2);\n\n  p1 = _ddIdefs$twoProd4[0];\n  e1 = _ddIdefs$twoProd4[1];\n\n  var _ddIdefs$twoProd5 = ddIdefs.twoProd(a[1], b);\n\n  var _ddIdefs$twoProd6 = _slicedToArray(_ddIdefs$twoProd5, 2);\n\n  p2 = _ddIdefs$twoProd6[0];\n  e2 = _ddIdefs$twoProd6[1];\n\n  var _ddIdefs$quickTwoSum9 = ddIdefs.quickTwoSum(p1, e2 + p2 + e1);\n\n  var _ddIdefs$quickTwoSum10 = _slicedToArray(_ddIdefs$quickTwoSum9, 2);\n\n  p1 = _ddIdefs$quickTwoSum10[0];\n  e1 = _ddIdefs$quickTwoSum10[1];\n\n  return [p1, e1];\n}\n// dd_accurate_div in original\nfunction ddDiv(a, b) {\n  var q1 = void 0,\n      q2 = void 0,\n      q3 = void 0,\n      r = void 0;\n  q1 = a[0] / b[0]; /* approximate quotient */\n\n  r = ddSub(a, ddMulDdD(b, q1));\n\n  q2 = r[0] / b[0];\n  r = ddSub(r, ddMulDdD(b, q2));\n\n  q3 = r[0] / b[0];\n\n  var _ddIdefs$quickTwoSum11 = ddIdefs.quickTwoSum(q1, q2);\n\n  var _ddIdefs$quickTwoSum12 = _slicedToArray(_ddIdefs$quickTwoSum11, 2);\n\n  q1 = _ddIdefs$quickTwoSum12[0];\n  q2 = _ddIdefs$quickTwoSum12[1];\n\n  r = ddAddDdD([q1, q2], q3);\n  return r;\n}\n\nexports.ddAdd = ddAdd;\nexports.ddSub = ddSub;\nexports.ddMul = ddMul;\nexports.ddDiv = ddDiv;\n},{\"./ddIdefs.js\":53}],55:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.gamma = undefined;\n\nvar _polevl = require('./polevl.js');\n\nvar _constants = require('./constants.js');\n\nvar constants = _interopRequireWildcard(_constants);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @file        gamma.js        Gamma function\n *\n *\n *\n * SYNOPSIS:\n *\n * double x, y, Gamma();\n *\n * y = Gamma( x );\n *\n *\n *\n * DESCRIPTION:\n *\n * Returns Gamma function of the argument.  The result is\n * correctly signed.\n *\n * Arguments |x| <= 34 are reduced by recurrence and the function\n * approximated by a rational function of degree 6/7 in the\n * interval (2,3).  Large arguments are handled by Stirling's\n * formula. Large negative arguments are made positive using\n * a reflection formula.\n *\n *\n * ACCURACY:\n *\n *                      Relative error:\n * arithmetic   domain     # trials      peak         rms\n *    IEEE    -170,-33      20000       2.3e-15     3.3e-16\n *    IEEE     -33,  33     20000       9.4e-16     2.2e-16\n *    IEEE      33, 171.6   20000       2.3e-15     3.2e-16\n *\n * Error for arguments outside the test range will be larger\n * owing to error amplification by the exponential function.\n *\n * Cephes Math Library Release 2.2:  July, 1992\n * Copyright 1984, 1987, 1989, 1992 by Stephen L. Moshier\n * Ported to ECMAScript 2018\n * Copyright (c) 2018, Kings Distributed Systems\n *\n * @author      KC Erb, kc@kcerb.com\n * @date        April 2018\n */\nvar P = new Float64Array([1.60119522476751861407E-4, 1.19135147006586384913E-3, 1.04213797561761569935E-2, 4.76367800457137231464E-2, 2.07448227648435975150E-1, 4.94214826801497100753E-1, 9.99999999999999996796E-1]);\n\nvar Q = new Float64Array([-2.31581873324120129819E-5, 5.39605580493303397842E-4, -4.45641913851797240494E-3, 1.18139785222060435552E-2, 3.58236398605498653373E-2, -2.34591795718243348568E-1, 7.14304917030273074085E-2, 1.00000000000000000320E0]);\n\nfunction gamma(x) {\n  var p = void 0,\n      q = void 0,\n      z = void 0,\n      i = void 0;\n  var sgngam = 1;\n\n  if (!isFinite(x)) {\n    return x;\n  }\n  q = Math.abs(x);\n  if (q > 33.0) {\n    if (x < 0.0) {\n      p = Math.floor(q);\n      if (p === q) {\n        // mtherr(\"Gamma\", OVERFLOW);\n        return Infinity;\n      }\n      i = p;\n      if ((i & 1) === 0) {\n        sgngam = -1;\n      }\n\n      z = q - p;\n      if (z > 0.5) {\n        p += 1.0;\n        z = q - p;\n      }\n      z = q * Math.sin(Math.PI * z);\n      if (z === 0.0) {\n        return sgngam * Infinity;\n      }\n      z = Math.abs(z);\n      z = Math.PI / (z * stirf(q));\n    } else {\n      z = stirf(x);\n    }\n    return sgngam * z;\n  }\n\n  z = 1.0;\n  while (x >= 3.0) {\n    x -= 1.0;\n    z *= x;\n  }\n\n  while (x < 0.0) {\n    if (x > -1.E-9) return small(x, z);\n    z /= x;\n    x += 1.0;\n  }\n\n  while (x < 2.0) {\n    if (x < 1.e-9) {\n      return small(x, z);\n    }\n    z /= x;\n    x += 1.0;\n  }\n\n  if (x === 2.0) return z;\n\n  x -= 2.0;\n  p = (0, _polevl.polevl)(x, P, 6);\n  q = (0, _polevl.polevl)(x, Q, 7);\n  return z * p / q;\n};\n\nfunction small(x, z) {\n  if (x === 0.0) {\n    // mtherr(\"Gamma\", OVERFLOW);\n    return Infinity;\n  } else {\n    return z / ((1.0 + 0.5772156649015329 * x) * x);\n  }\n}\n\n// Stirling's formula for the Gamma function\nvar STIR = [8.33333333333482257126E-2, 3.47222221605458667310E-3, -2.68132617805781232825E-3, -2.29549961613378126380E-4, 7.87311395793093628397E-4];\n\nfunction stirf(x) {\n  var y = void 0,\n      w = void 0,\n      v = void 0;\n\n  var MAXSTIR = 143.01608;\n\n  if (x >= constants.MAXGAM) {\n    return Infinity;\n  }\n  w = 1.0 / x;\n  w = 1.0 + w * (0, _polevl.polevl)(w, STIR, 4);\n  y = Math.exp(x);\n\n  //  Avoid overflow in pow()\n  if (x > MAXSTIR) {\n    v = Math.pow(x, 0.5 * x - 0.25);\n    y = v * (v / y);\n  } else {\n    y = Math.pow(x, x - 0.5) / y;\n  }\n  y = constants.SQTPI * y * w;\n  return y;\n}\n\nexports.gamma = gamma;\n},{\"./constants.js\":51,\"./polevl.js\":78}],56:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.lgamSgn = exports.lgam = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * @file        lgam.js        Natural logarithm of Gamma function\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * SYNOPSIS:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * double x, y, lgam();\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * y = lgam( x );\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * DESCRIPTION:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Returns the base e (2.718...) logarithm of the absolute\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * value of the Gamma function of the argument.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * For arguments greater than 13, the logarithm of the Gamma\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * function is approximated by the logarithmic version of\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Stirling's formula using a polynomial approximation of\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * degree 4. Arguments between -33 and +33 are reduced by\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * recurrence to the interval [2,3] of a rational approximation.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * The cosecant reflection formula is employed for arguments\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * less than -33.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Arguments greater than MAXLGM return NPY_INFINITY and an error\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * message.  MAXLGM = 2.556348e305 for IEEE arithmetic.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * ACCURACY:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * arithmetic      domain        # trials     peak         rms\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *    IEEE    0, 3                 28000     5.4e-16     1.1e-16\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *    IEEE    2.718, 2.556e305     40000     3.5e-16     8.3e-17\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * The error criterion was relative when the function magnitude\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * was greater than one but absolute when it was less than one.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * The following test used the relative error criterion, though\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * at certain points the relative error could be much higher than\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * indicated.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *    IEEE    -200, -4             10000     4.8e-16     1.3e-16\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Cephes Math Library Release 2.2:  July, 1992\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright 1984, 1987, 1989, 1992 by Stephen L. Moshier\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Ported to ECMAScript 2018\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright (c) 2018, Kings Distributed Systems\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * @author      KC Erb, kc@kcerb.com\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * @date        April 2018\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */\n\n\nvar _polevl = require('../polevl.js');\n\nvar _constants = require('../constants.js');\n\nvar constants = _interopRequireWildcard(_constants);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/* A[]: Stirling's formula expansion of log Gamma\n* B[], C[]: log Gamma function between 2 and 3\n*/\nvar A = [8.11614167470508450300E-4, -5.95061904284301438324E-4, 7.93650340457716943945E-4, -2.77777777730099687205E-3, 8.33333333333331927722E-2];\n\nvar B = [-1.37825152569120859100E3, -3.88016315134637840924E4, -3.31612992738871184744E5, -1.16237097492762307383E6, -1.72173700820839662146E6, -8.53555664245765465627E5];\n\nvar C = [\n/* 1.00000000000000000000E0, */\n-3.51815701436523470549E2, -1.70642106651881159223E4, -2.20528590553854454839E5, -1.13933444367982507207E6, -2.53252307177582951285E6, -2.01889141433532773231E6];\n\nvar MAXLGM = 2.556348e305;\nvar LOGPI = 1.14472988584940017414;\n\nfunction lgam(x) {\n  var _lgamSgn = lgamSgn(x),\n      _lgamSgn2 = _slicedToArray(_lgamSgn, 1),\n      res = _lgamSgn2[0];\n\n  return res;\n}\n\n// Translator's note:\n// returns array of [val, sign] to replace pointer functionality from original\nfunction lgamSgn(x) {\n  var p = void 0,\n      q = void 0,\n      u = void 0,\n      w = void 0,\n      z = void 0,\n      i = void 0,\n      sign = void 0;\n  sign = 1;\n\n  if (!isFinite(x)) return [x, sign];\n\n  if (x < -34.0) {\n    q = -x;\n\n    var _lgamSgn3 = lgamSgn(q, sign);\n\n    var _lgamSgn4 = _slicedToArray(_lgamSgn3, 2);\n\n    w = _lgamSgn4[0];\n    sign = _lgamSgn4[1];\n\n    p = Math.floor(q);\n    if (p === q) {\n      // mtherr(\"lgam\", SING);\n      return [Infinity, sign];\n    }\n    i = p;\n    if ((i & 1) === 0) sign = -1;else sign = 1;\n    z = q - p;\n    if (z > 0.5) {\n      p += 1.0;\n      z = p - q;\n    }\n    z = q * Math.sin(Math.PI * z);\n    if (z === 0.0) {\n      // mtherr(\"lgam\", SING);\n      return [Infinity, sign];\n    }\n    /*     z = log(NPY_PI) - log( z ) - w; */\n    z = LOGPI - Math.log(z) - w;\n    return [z, sign];\n  }\n\n  if (x < 13.0) {\n    z = 1.0;\n    p = 0.0;\n    u = x;\n    while (u >= 3.0) {\n      p -= 1.0;\n      u = x + p;\n      z *= u;\n    }\n    while (u < 2.0) {\n      if (u === 0.0) {\n        // mtherr(\"lgam\", SING);\n        return [Infinity, sign];\n      }\n      z /= u;\n      p += 1.0;\n      u = x + p;\n    }\n    if (z < 0.0) {\n      sign = -1;\n      z = -z;\n    } else {\n      sign = 1;\n    }\n    if (u === 2.0) return [Math.log(z), sign];\n    p -= 2.0;\n    x = x + p;\n    p = x * (0, _polevl.polevl)(x, B, 5) / (0, _polevl.p1evl)(x, C, 6);\n    return [Math.log(z) + p, sign];\n  }\n\n  if (x > MAXLGM) {\n    return [sign * Infinity, sign];\n  }\n\n  q = (x - 0.5) * Math.log(x) - x + constants.LS2PI;\n  if (x > 1.0e8) return [q, sign];\n\n  p = 1.0 / (x * x);\n  if (x >= 1000.0) {\n    q += ((7.9365079365079365079365e-4 * p - 2.7777777777777777777778e-3) * p + 0.0833333333333333333333) / x;\n  } else {\n    q += (0, _polevl.polevl)(p, A, 4) / x;\n  }\n  return [q, sign];\n}\n\nexports.lgam = lgam;\nexports.lgamSgn = lgamSgn;\n},{\"../constants.js\":51,\"../polevl.js\":78}],57:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hyp2f1 = undefined;\n\nvar _constants = require('./hyp2f1/constants.js');\n\nvar constants = _interopRequireWildcard(_constants);\n\nvar _gamma = require('./gamma.js');\n\nvar _hyt2f = require('./hyp2f1/hyt2f1.js');\n\nvar _hys2f = require('./hyp2f1/hys2f1.js');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n//\n/**\n * @file        hyp2f1.js        Gauss hypergeometric function   F\n *                                                              2 1\n *\n *\n * SYNOPSIS:\n *\n * double a, b, c, x, y, hyp2f1();\n *\n * y = hyp2f1( a, b, c, x );\n *\n *\n * DESCRIPTION:\n *\n *\n *  hyp2f1( a, b, c, x )  =   F ( a, b; c; x )\n *                           2 1\n *\n *           inf.\n *            -   a(a+1)...(a+k) b(b+1)...(b+k)   k+1\n *   =  1 +   >   -----------------------------  x   .\n *            -         c(c+1)...(c+k) (k+1)!\n *          k = 0\n *\n *  Cases addressed are\n *      Tests and escapes for negative integer a, b, or c\n *      Linear transformation if c - a or c - b negative integer\n *      Special case c = a or c = b\n *      Linear transformation for  x near +1\n *      Transformation for x < -0.5\n *      Psi function expansion if x > 0.5 and c - a - b integer\n *      Conditionally, a recurrence on c to make c-a-b > 0\n *\n *      x < -1  AMS 15.3.7 transformation applied (Travis Oliphant)\n *         valid for b,a,c,(b-a) !== integer and (c-a),(c-b) !== negative integer\n *\n * x >= 1 is rejected (unless special cases are present)\n *\n * The parameters a, b, c are considered to be integer\n * valued if they are within 1.0e-14 of the nearest integer\n * (1.0e-13 for IEEE arithmetic).\n *\n * ACCURACY:\n *\n *\n *               Relative error (-1 < x < 1):\n * arithmetic   domain     # trials      peak         rms\n *    IEEE      -1,7        230000      1.2e-11     5.2e-14\n *\n * Several special cases also tested with a, b, c in\n * the range -7 to 7.\n *\n * ERROR MESSAGES:\n *\n * A \"partial loss of precision\" message is printed if\n * the internally estimated relative error exceeds 1^-12.\n * A \"singularity\" message is printed on overflow or\n * in cases not addressed (such as x < -1).\n * Cephes Math Library Release 2.8:  June, 2000\n * Copyright 1984, 1987, 1992, 2000 by Stephen L. Moshier\n * Ported to ECMAScript 2018\n * Copyright (c) 2018, Kings Distributed Systems\n *\n * @author      KC Erb, kc@kcerb.com\n * @date        April 2018\n */\nfunction hyp2f1(a, b, c, x) {\n  var cInt = void 0;\n  if (x === 0.0) {\n    return 1.0;\n  }\n\n  if ((a === 0 || b === 0) && c !== 0) {\n    return 1.0;\n  }\n\n  var negIntA = 0;\n  var negIntB = 0;\n  var negIntCaOrCb = 0;\n\n  var errObj = { val: 0.0 };\n  var xAbs = Math.abs(x);\n  var s = 1.0 - x;\n  var aInt = Math.round(a); /* nearest integer to a */\n  var bInt = Math.round(b);\n\n  var d = c - a - b;\n  var dInt = Math.round(d);\n  var p = void 0,\n      q = void 0,\n      y = void 0;\n\n  // a is a negative integer\n  if (a <= 0 && Math.abs(a - aInt) < constants.EPS) {\n    negIntA = 1;\n  }\n\n  // b is a negative integer\n  if (b <= 0 && Math.abs(b - bInt) < constants.EPS) {\n    negIntB = 1;\n  }\n\n  if (d <= -1 && !(Math.abs(d - dInt) > constants.EPS && s < 0) && !(negIntA || negIntB)) {\n    return Math.pow(s, d) * hyp2f1(c - a, c - b, c, x);\n  }\n  if (d <= 0 && x === 1 && !(negIntA || negIntB)) {\n    return hypdiv();\n  }\n\n  /* 2F1(a,b;b;x) = (1-x)**(-a) */\n  if (xAbs < 1.0 || x === -1.0) {\n    // b = c\n    if (Math.abs(b - c) < constants.EPS) {\n      y = s ** -a;\n      return hypdon(y, errObj);\n    }\n\n    // a = c\n    if (Math.abs(a - c) < constants.EPS) {\n      y = s ** -b;\n      return hypdon(y, errObj);\n    }\n  }\n\n  if (c <= 0.0) {\n    cInt = Math.round(c);\n    // c is a negative integer\n    if (Math.abs(c - cInt) < constants.EPS) {\n      // check if termination before explosion\n      if (negIntA && aInt > cInt) {\n        return hypok(a, b, c, x, errObj);\n      }\n      if (negIntB && bInt > cInt) {\n        return hypok(a, b, c, x, errObj);\n      }\n      return hypdiv();\n    }\n  }\n\n  // function is a polynomial\n  if (negIntA || negIntB) {\n    return hypok(a, b, c, x, errObj);\n  }\n\n  var t1 = Math.abs(b - a);\n\n  if (x < -2.0 && Math.abs(t1 - Math.round(t1)) > constants.EPS) {\n    // This transform has a pole for b-a integer, and\n    // may produce large cancellation errors for |1/x| close to 1\n    var _p = hyp2f1(a, 1 - c + a, 1 - b + a, 1.0 / x);\n    var _q = hyp2f1(b, 1 - c + b, 1 - a + b, 1.0 / x);\n    _p *= Math.pow(-x, -a);\n    _q *= Math.pow(-x, -b);\n    t1 = (0, _gamma.gamma)(c);\n    s = t1 * (0, _gamma.gamma)(b - a) / ((0, _gamma.gamma)(b) * (0, _gamma.gamma)(c - a));\n    y = t1 * (0, _gamma.gamma)(a - b) / ((0, _gamma.gamma)(a) * (0, _gamma.gamma)(c - b));\n    return s * _p + y * _q;\n  } else if (x < -1.0) {\n    if (Math.abs(a) < Math.abs(b)) {\n      return Math.pow(s, -a) * hyp2f1(a, c - b, c, x / (x - 1));\n    } else {\n      return Math.pow(s, -b) * hyp2f1(b, c - a, c, x / (x - 1));\n    }\n  }\n\n  // series diverges\n  if (xAbs > 1.0) {\n    return hypdiv();\n  }\n\n  p = c - a;\n  // nearest integer to c-a\n  aInt = Math.round(p);\n\n  // negative int c - a\n  if (aInt <= 0.0 && Math.abs(p - aInt) < constants.EPS) {\n    negIntCaOrCb = 1;\n  }\n\n  var r = c - b;\n  // nearest integer to c-b\n  bInt = Math.round(r);\n\n  if (bInt <= 0.0 && Math.abs(r - bInt) < constants.EPS) {\n    negIntCaOrCb = 1;\n  }\n\n  // nearest integer to d\n  dInt = Math.round(d);\n  q = Math.abs(d - dInt);\n\n  // |x|===1.0\n  if (Math.abs(xAbs - 1.0) < constants.EPS) {\n    if (x > 0.0) {\n      if (negIntCaOrCb) {\n        return d >= 0.0 ? hypf(a, b, c, d, s, x, errObj) : hypdiv();\n      }\n      if (d <= 0.0) {\n        hypdiv();\n      }\n      y = (0, _gamma.gamma)(c) * (0, _gamma.gamma)(d) / ((0, _gamma.gamma)(p) * (0, _gamma.gamma)(r));\n      return hypdon(y, errObj);\n    }\n\n    if (d <= -1.0) {\n      return hypdiv();\n    }\n  }\n\n  // Conditionally make d > 0 by recurrence on c\n  if (d < 0.0) {\n    // Try the power series first\n    y = (0, _hyt2f.hyt2f1)(a, b, c, x, errObj);\n\n    if (errObj.val < constants.ETHRESH) {\n      return hypdon(y, errObj);\n    }\n\n    /* Apply the recurrence if power series fails */\n    errObj.val = 0.0;\n    var aid = 2 - dInt;\n    var e = c + aid;\n    var d2 = hyp2f1(a, b, e, x);\n    var d1 = hyp2f1(a, b, e + 1.0, x);\n    q = a + b + 1.0;\n    for (var i = 0; i < aid; i++) {\n      r = e - 1.0;\n      y = (e * (r - (2.0 * e - q) * x) * d2 + (e - a) * (e - b) * x * d1) / (e * r * s);\n      e = r;\n      d1 = d2;\n      d2 = y;\n    }\n\n    return hypdon(y, errObj);\n  }\n\n  // negative integer c-a or c-b\n  if (negIntCaOrCb) {\n    return hypf(a, b, c, d, s, x, errObj);\n  }\n\n  return hypok(a, b, c, x, errObj);\n};\n\nfunction hypok(a, b, c, x, errObj) {\n  var y = (0, _hyt2f.hyt2f1)(a, b, c, x, errObj);\n  return hypdon(y, errObj);\n};\n\nfunction hypdon(y, errObj) {\n  if (errObj.val > constants.ETHRESH) {\n    // printf( \"Estimated err = %.2e\\n\", err );\n    // mtherr(\"hyp2f1\", PLOSS);\n  }\n  return y;\n};\n\n// The transformation for c-a or c-b negative integer\nfunction hypf(a, b, c, d, s, x, errObj) {\n  var y = Math.pow(s, d) * (0, _hys2f.hys2f1)(c - a, c - b, c, x, errObj);\n  return hypdon(y, errObj);\n};\n\n// The alarm exit\nfunction hypdiv() {\n  // mtherr(\"hyp2f1\", OVERFLOW);\n  return Infinity;\n};\n\nexports.hyp2f1 = hyp2f1;\n},{\"./gamma.js\":55,\"./hyp2f1/constants.js\":58,\"./hyp2f1/hys2f1.js\":60,\"./hyp2f1/hyt2f1.js\":61}],58:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar EPS = exports.EPS = 1.0e-13;\nvar ETHRESH = exports.ETHRESH = 1.0e-12;\nvar MAX_ITERATIONS = exports.MAX_ITERATIONS = 10000;\nvar MACHEP = exports.MACHEP = Number.EPSILON / 2;\n},{}],59:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hyp2f1ra = undefined;\n\nvar _constants = require('./constants.js');\n\nvar constants = _interopRequireWildcard(_constants);\n\nvar _hys2f = require('./hys2f1.js');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction hyp2f1ra(a, b, c, x, lossObj) {\n  var da = void 0,\n      f2 = void 0,\n      f1 = void 0,\n      f0 = void 0,\n      err = void 0,\n      n = void 0;\n\n  // Don't cross c or zero\n  if (c < 0 && a <= c || c >= 0 && a >= c) {\n    da = Math.round(a - c);\n  } else {\n    da = Math.round(a);\n  }\n  var t = a - da;\n\n  lossObj.val = 0;\n\n  // assert(da !== 0);\n\n  if (Math.abs(da) > constants.MAX_ITERATIONS) {\n    /* Too expensive to compute this value, so give up */\n    // mtherr(\"hyp2f1\", TLOSS);\n    lossObj.val = 1.0;\n    return NaN;\n  }\n\n  if (da < 0) {\n    // Recurse down\n    f2 = 0;\n    f1 = (0, _hys2f.hys2f1)(t, b, c, x, err);\n    lossObj.val += err;\n    f0 = (0, _hys2f.hys2f1)(t - 1, b, c, x, err);\n    lossObj.val += err;\n    t -= 1;\n    for (n = 1; n < -da; ++n) {\n      f2 = f1;\n      f1 = f0;\n      f0 = -(2 * t - c - t * x + b * x) / (c - t) * f1 - t * (x - 1) / (c - t) * f2;\n      t -= 1;\n    }\n  } else {\n    // Recurse up\n    f2 = 0;\n    f1 = (0, _hys2f.hys2f1)(t, b, c, x, err);\n    lossObj.val += err;\n    f0 = (0, _hys2f.hys2f1)(t + 1, b, c, x, err);\n    lossObj.val += err;\n    t += 1;\n    for (n = 1; n < da; ++n) {\n      f2 = f1;\n      f1 = f0;\n      f0 = -((2 * t - c - t * x + b * x) * f1 + (c - t) * f2) / (t * (x - 1));\n      t += 1;\n    }\n  }\n\n  return f0;\n};\n\nexports.hyp2f1ra = hyp2f1ra;\n},{\"./constants.js\":58,\"./hys2f1.js\":60}],60:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hys2f1 = undefined;\n\nvar _constants = require('./constants.js');\n\nvar constants = _interopRequireWildcard(_constants);\n\nvar _hyp2f1ra = require('./hyp2f1ra.js');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction hys2f1(a, b, c, x, lossObj) {\n  var intflag = 0;\n  var f = void 0;\n  // Ensure that |a| > |b| ...\n  if (Math.abs(b) > Math.abs(a)) {\n    f = b;\n    b = a;\n    a = f;\n  }\n\n  var intB = Math.round(b);\n\n  if (Math.abs(b - intB) < constants.EPS && intB <= 0 && Math.abs(b) < Math.abs(a)) {\n    // except when `b` is a smaller negative integer\n    f = b;\n    b = a;\n    a = f;\n    intflag = 1;\n  }\n\n  if ((Math.abs(a) > Math.abs(c) + 1 || intflag) && Math.abs(c - a) > 2 && Math.abs(a) > 2) {\n    // |a| >> |c| implies that large cancellation error is to be expected.\n    // We try to reduce it with the recurrence relations\n    return (0, _hyp2f1ra.hyp2f1ra)(a, b, c, x, lossObj);\n  }\n\n  var i = 0;\n  var umax = 0.0;\n  f = a;\n  var g = b;\n  var h = c;\n  var s = 1.0;\n  var u = 1.0;\n  var k = 0.0;\n  do {\n    if (Math.abs(h) < constants.EPS) {\n      lossObj.val = 1.0;\n      return Infinity;\n    }\n    var m = k + 1.0;\n    u = u * ((f + k) * (g + k) * x / ((h + k) * m));\n    s += u;\n    k = Math.abs(u); // remember largest term summed\n    if (k > umax) {\n      umax = k;\n    }\n    k = m;\n    // should never happen\n    if (++i > constants.MAX_ITERATIONS) {\n      lossObj.val = 1.0;\n      return s;\n    }\n  } while (s === 0 || Math.abs(u / s) > constants.MACHEP);\n\n  /* return estimated relative error */\n  lossObj.val = constants.MACHEP * umax / Math.abs(s) + constants.MACHEP * i;\n\n  return s;\n};\n\nexports.hys2f1 = hys2f1;\n},{\"./constants.js\":58,\"./hyp2f1ra.js\":59}],61:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hyt2f1 = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _constants = require('./constants.js');\n\nvar constants = _interopRequireWildcard(_constants);\n\nvar _gamma = require('../gamma.js');\n\nvar _lgam = require('../gamma/lgam.js');\n\nvar _psi = require('../psi.js');\n\nvar _hys2f = require('./hys2f1.js');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction hyt2f1(a, b, c, x, lossObj) {\n  var negIntA = 0;\n  var negIntB = 0;\n  var e = void 0,\n      d1 = void 0,\n      d2 = void 0,\n      aid = void 0,\n      y = void 0,\n      t = void 0,\n      r = void 0,\n      q = void 0,\n      sgngam = void 0,\n      res = void 0,\n      y1 = void 0;\n\n  var aInt = Math.round(a);\n  var bInt = Math.round(b);\n\n  if (a <= 0 && Math.abs(a - aInt) < constants.EPS) {\n    // a is a negative integer\n    negIntA = 1;\n  }\n\n  if (b <= 0 && Math.abs(b - bInt) < constants.EPS) {\n    // b is a negative integer\n    negIntB = 1;\n  }\n\n  var errObj = { val: 0.0 };\n  var err1Obj = { val: null // note: in original cephes lib err1 is initialized with no value.\n  };var s = 1.0 - x;\n  if (x < -0.5 && !(negIntA || negIntB)) {\n    if (b > a) {\n      y = Math.pow(s, -a) * (0, _hys2f.hys2f1)(a, c - b, c, -x / s, errObj);\n    } else {\n      y = Math.pow(s, -b) * (0, _hys2f.hys2f1)(c - a, b, c, -x / s, errObj);\n    }\n    return y;\n  }\n\n  var d = c - a - b;\n  var dInt = Math.round(d);\n\n  if (x > 0.9 && !(negIntA || negIntB)) {\n    if (Math.abs(d - dInt) > constants.EPS) {\n      // test for integer c-a-b\n      // Try the power series first\n      y = (0, _hys2f.hys2f1)(a, b, c, x, errObj);\n      if (errObj.val < constants.ETHRESH) {\n        return y;\n      }\n\n      // If power series fails, then apply AMS55 #15.3.6\n      q = (0, _hys2f.hys2f1)(a, b, 1.0 - d, s, errObj);\n      var sign = 1;\n      var w = void 0;\n      // lgamSgn(d, &sgngam);\n\n      var _lgamSgn = (0, _lgam.lgamSgn)(d);\n\n      var _lgamSgn2 = _slicedToArray(_lgamSgn, 2);\n\n      w = _lgamSgn2[0];\n      sgngam = _lgamSgn2[1];\n\n      sign *= sgngam;\n\n      var _lgamSgn3 = (0, _lgam.lgamSgn)(c - a);\n\n      var _lgamSgn4 = _slicedToArray(_lgamSgn3, 2);\n\n      res = _lgamSgn4[0];\n      sgngam = _lgamSgn4[1];\n\n      w -= res;\n      sign *= sgngam;\n\n      var _lgamSgn5 = (0, _lgam.lgamSgn)(c - b);\n\n      var _lgamSgn6 = _slicedToArray(_lgamSgn5, 2);\n\n      res = _lgamSgn6[0];\n      sgngam = _lgamSgn6[1];\n\n      w -= res;\n      sign *= sgngam;\n      q *= sign * Math.exp(w);\n      r = Math.pow(s, d) * (0, _hys2f.hys2f1)(c - a, c - b, d + 1.0, s, err1Obj);\n      sign = 1;\n\n      var _lgamSgn7 = (0, _lgam.lgamSgn)(-d);\n\n      var _lgamSgn8 = _slicedToArray(_lgamSgn7, 2);\n\n      w = _lgamSgn8[0];\n      sgngam = _lgamSgn8[1];\n\n      sign *= sgngam;\n\n      var _lgamSgn9 = (0, _lgam.lgamSgn)(a);\n\n      var _lgamSgn10 = _slicedToArray(_lgamSgn9, 2);\n\n      res = _lgamSgn10[0];\n      sgngam = _lgamSgn10[1];\n\n      w -= res;\n      sign *= sgngam;\n\n      var _lgamSgn11 = (0, _lgam.lgamSgn)(b);\n\n      var _lgamSgn12 = _slicedToArray(_lgamSgn11, 2);\n\n      res = _lgamSgn12[0];\n      sgngam = _lgamSgn12[1];\n\n      w -= res;\n      sign *= sgngam;\n      r *= sign * Math.exp(w);\n      y = q + r;\n\n      // estimate cancellation error\n      q = Math.abs(q);\n      r = Math.abs(r);\n      if (q > r) {\n        r = q;\n      }\n      errObj.val += err1Obj.val + constants.MACHEP * r / y;\n\n      y *= (0, _gamma.gamma)(c);\n      return y;\n    } else {\n      /* Psi function expansion, AMS55 #15.3.10, #15.3.11, #15.3.12\n      *\n      * Although AMS55 does not explicitly state it, this expansion fails\n      * for negative integer a or b, since the psi and Gamma functions\n      * involved have poles.\n      */\n\n      if (dInt >= 0.0) {\n        e = d;\n        d1 = d;\n        d2 = 0.0;\n        aid = dInt;\n      } else {\n        e = -d;\n        d1 = 0.0;\n        d2 = d;\n        aid = -dInt;\n      }\n\n      var ax = Math.log(s);\n\n      // sum for t = 0\n      y = (0, _psi.psi)(1.0) + (0, _psi.psi)(1.0 + e) - (0, _psi.psi)(a + d1) - (0, _psi.psi)(b + d1) - ax;\n      y /= (0, _gamma.gamma)(e + 1.0);\n\n      // Poch for t=1\n      var p = (a + d1) * (b + d1) * s / (0, _gamma.gamma)(e + 2.0);\n      t = 1.0;\n      do {\n        r = (0, _psi.psi)(1.0 + t) + (0, _psi.psi)(1.0 + t + e) - (0, _psi.psi)(a + t + d1) - (0, _psi.psi)(b + t + d1) - ax;\n        q = p * r;\n        y += q;\n        p *= s * (a + t + d1) / (t + 1.0);\n        p *= (b + t + d1) / (t + 1.0 + e);\n        t += 1.0;\n        // should never happen\n        if (t > constants.MAX_ITERATIONS) {\n          // mtherr(\"hyp2f1\", TOOMANY);\n          lossObj.val = 1.0;\n          return NaN;\n        }\n      } while (y === 0 || Math.abs(q / y) > constants.EPS);\n\n      if (dInt === 0.0) {\n        y *= (0, _gamma.gamma)(c) / ((0, _gamma.gamma)(a) * (0, _gamma.gamma)(b));\n        return y;\n      }\n\n      y1 = 1.0;\n\n      if (aid === 1) {\n        return nosum(a, aid, b, c, d1, d2, dInt, e, q, s, y, y1);\n      }\n\n      t = 0.0;\n      p = 1.0;\n      for (var i = 1; i < aid; i++) {\n        r = 1.0 - e + t;\n        p *= s * (a + t + d2) * (b + t + d2) / r;\n        t += 1.0;\n        p /= t;\n        y1 += p;\n      }\n      return nosum(a, aid, b, c, d1, d2, dInt, e, q, s, y, y1);\n    }\n  }\n\n  // Use defining power series if no special cases\n  y = (0, _hys2f.hys2f1)(a, b, c, x, errObj);\n  return y;\n};\n\nfunction nosum(a, aid, b, c, d1, d2, dInt, e, q, s, y, y1) {\n  var p = (0, _gamma.gamma)(c);\n  y1 *= (0, _gamma.gamma)(e) * p / ((0, _gamma.gamma)(a + d1) * (0, _gamma.gamma)(b + d1));\n\n  y *= p / ((0, _gamma.gamma)(a + d2) * (0, _gamma.gamma)(b + d2));\n  if ((aid & 1) !== 0) {\n    y = -y;\n  }\n  q = Math.pow(s, dInt);\n  if (dInt > 0.0) {\n    y *= q;\n  } else {\n    y1 *= q;\n  }\n\n  y += y1;\n  return y;\n};\n\nexports.hyt2f1 = hyt2f1;\n},{\"../gamma.js\":55,\"../gamma/lgam.js\":56,\"../psi.js\":79,\"./constants.js\":58,\"./hys2f1.js\":60}],62:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.i0e = exports.i0 = undefined;\n\nvar _chbevl = require('./chbevl.js');\n\n/* Chebyshev coefficients for exp(-x) I0(x)\n * in the interval [0,8].\n *\n * lim(x->0){ exp(-x) I0(x) } = 1.\n */\nvar A = [-4.41534164647933937950E-18, 3.33079451882223809783E-17, -2.43127984654795469359E-16, 1.71539128555513303061E-15, -1.16853328779934516808E-14, 7.67618549860493561688E-14, -4.85644678311192946090E-13, 2.95505266312963983461E-12, -1.72682629144155570723E-11, 9.67580903537323691224E-11, -5.18979560163526290666E-10, 2.65982372468238665035E-9, -1.30002500998624804212E-8, 6.04699502254191894932E-8, -2.67079385394061173391E-7, 1.11738753912010371815E-6, -4.41673835845875056359E-6, 1.64484480707288970893E-5, -5.75419501008210370398E-5, 1.88502885095841655729E-4, -5.76375574538582365885E-4, 1.63947561694133579842E-3, -4.32430999505057594430E-3, 1.05464603945949983183E-2, -2.37374148058994688156E-2, 4.93052842396707084878E-2, -9.49010970480476444210E-2, 1.71620901522208775349E-1, -3.04682672343198398683E-1, 6.76795274409476084995E-1];\n\n/* Chebyshev coefficients for exp(-x) sqrt(x) I0(x)\n * in the inverted interval [8,infinity].\n *\n * lim(x->inf){ exp(-x) sqrt(x) I0(x) } = 1/sqrt(2pi).\n */\n/**\n * @file        i0.js       Modified Bessel function of order zero\n *\n *\n *\n * SYNOPSIS:\n *\n * double x, y, i0();\n *\n * y = i0( x );\n *\n *\n *\n * DESCRIPTION:\n *\n * Returns modified Bessel function of order zero of the\n * argument.\n *\n * The function is defined as i0(x) = j0( ix ).\n *\n * The range is partitioned into the two intervals [0,8] and\n * (8, infinity).  Chebyshev polynomial expansions are employed\n * in each interval.\n *\n *\n *\n * ACCURACY:\n *\n *                      Relative error:\n * arithmetic   domain     # trials      peak         rms\n *    IEEE      0,30        30000       5.8e-16     1.4e-16\n *\n *\n *  Modified Bessel function of order zero,\n *  exponentially scaled\n *\n *\n *\n * SYNOPSIS:\n *\n * double x, y, i0e();\n *\n * y = i0e( x );\n *\n *\n *\n * DESCRIPTION:\n *\n * Returns exponentially scaled modified Bessel function\n * of order zero of the argument.\n *\n * The function is defined as i0e(x) = exp(-|x|) j0( ix ).\n *\n *\n *\n * ACCURACY:\n *\n *                      Relative error:\n * arithmetic   domain     # trials      peak         rms\n *    IEEE      0,30        30000       5.4e-16     1.2e-16\n * See i0().\n *\n * Cephes Math Library Release 2.8:  June, 2000\n * Copyright 1984, 1987, 2000 by Stephen L. Moshier\n * Ported to ECMAScript 2018\n * Copyright (c) 2018, Kings Distributed Systems\n *\n * @author      KC Erb, kc@kcerb.com\n * @date        April 2018\n */\nvar B = [-7.23318048787475395456E-18, -4.83050448594418207126E-18, 4.46562142029675999901E-17, 3.46122286769746109310E-17, -2.82762398051658348494E-16, -3.42548561967721913462E-16, 1.77256013305652638360E-15, 3.81168066935262242075E-15, -9.55484669882830764870E-15, -4.15056934728722208663E-14, 1.54008621752140982691E-14, 3.85277838274214270114E-13, 7.18012445138366623367E-13, -1.79417853150680611778E-12, -1.32158118404477131188E-11, -3.14991652796324136454E-11, 1.18891471078464383424E-11, 4.94060238822496958910E-10, 3.39623202570838634515E-9, 2.26666899049817806459E-8, 2.04891858946906374183E-7, 2.89137052083475648297E-6, 6.88975834691682398426E-5, 3.36911647825569408990E-3, 8.04490411014108831608E-1];\n\nfunction i0(x) {\n  var y = void 0;\n  if (x < 0) x = -x;\n  if (x <= 8.0) {\n    y = x / 2.0 - 2.0;\n    return Math.exp(x) * (0, _chbevl.chbevl)(y, A, 30);\n  }\n  return Math.exp(x) * (0, _chbevl.chbevl)(32.0 / x - 2.0, B, 25) / Math.sqrt(x);\n}\n\nfunction i0e(x) {\n  if (x < 0) x = -x;\n  if (x <= 8.0) {\n    var y = x / 2.0 - 2.0;\n    return (0, _chbevl.chbevl)(y, A, 30);\n  }\n\n  return (0, _chbevl.chbevl)(32.0 / x - 2.0, B, 25) / Math.sqrt(x);\n}\n\nexports.i0 = i0;\nexports.i0e = i0e;\n},{\"./chbevl.js\":50}],63:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.i1e = exports.i1 = undefined;\n\nvar _chbevl = require('./chbevl.js');\n\n/* Chebyshev coefficients for exp(-x) I1(x) / x\n * in the interval [0,8].\n *\n * lim(x->0){ exp(-x) I1(x) / x } = 1/2.\n */\nvar A = [2.77791411276104639959E-18, -2.11142121435816608115E-17, 1.55363195773620046921E-16, -1.10559694773538630805E-15, 7.60068429473540693410E-15, -5.04218550472791168711E-14, 3.22379336594557470981E-13, -1.98397439776494371520E-12, 1.17361862988909016308E-11, -6.66348972350202774223E-11, 3.62559028155211703701E-10, -1.88724975172282928790E-9, 9.38153738649577178388E-9, -4.44505912879632808065E-8, 2.00329475355213526229E-7, -8.56872026469545474066E-7, 3.47025130813767847674E-6, -1.32731636560394358279E-5, 4.78156510755005422638E-5, -1.61760815825896745588E-4, 5.12285956168575772895E-4, -1.51357245063125314899E-3, 4.15642294431288815669E-3, -1.05640848946261981558E-2, 2.47264490306265168283E-2, -5.29459812080949914269E-2, 1.02643658689847095384E-1, -1.76416518357834055153E-1, 2.52587186443633654823E-1];\n\n/* Chebyshev coefficients for exp(-x) sqrt(x) I1(x)\n * in the inverted interval [8,infinity].\n *\n * lim(x->inf){ exp(-x) sqrt(x) I1(x) } = 1/sqrt(2pi).\n */\n/**\n * @file        i1.js         Modified Bessel function of order one\n *\n *\n *\n * SYNOPSIS:\n *\n * double x, y, i1();\n *\n * y = i1( x );\n *\n *\n *\n * DESCRIPTION:\n *\n * Returns modified Bessel function of order one of the\n * argument.\n *\n * The function is defined as i1(x) = -i j1( ix ).\n *\n * The range is partitioned into the two intervals [0,8] and\n * (8, infinity).  Chebyshev polynomial expansions are employed\n * in each interval.\n *\n *\n *\n * ACCURACY:\n *\n *                      Relative error:\n * arithmetic   domain     # trials      peak         rms\n *    IEEE      0, 30       30000       1.9e-15     2.1e-16\n *\n *\n *  Modified Bessel function of order one,\n *  exponentially scaled\n *\n *\n *\n * SYNOPSIS:\n *\n * double x, y, i1e();\n *\n * y = i1e( x );\n *\n *\n *\n * DESCRIPTION:\n *\n * Returns exponentially scaled modified Bessel function\n * of order one of the argument.\n *\n * The function is defined as i1(x) = -i exp(-|x|) j1( ix ).\n *\n *\n *\n * ACCURACY:\n *\n *                      Relative error:\n * arithmetic   domain     # trials      peak         rms\n *    IEEE      0, 30       30000       2.0e-15     2.0e-16\n * See i1().\n *\n * Cephes Math Library Release 2.8:  June, 2000\n * Copyright 1985, 1987, 2000 by Stephen L. Moshier\n * Ported to ECMAScript 2018\n * Copyright (c) 2018, Kings Distributed Systems\n *\n * @author      KC Erb, kc@kcerb.com\n * @date        April 2018\n */\nvar B = [7.51729631084210481353E-18, 4.41434832307170791151E-18, -4.65030536848935832153E-17, -3.20952592199342395980E-17, 2.96262899764595013876E-16, 3.30820231092092828324E-16, -1.88035477551078244854E-15, -3.81440307243700780478E-15, 1.04202769841288027642E-14, 4.27244001671195135429E-14, -2.10154184277266431302E-14, -4.08355111109219731823E-13, -7.19855177624590851209E-13, 2.03562854414708950722E-12, 1.41258074366137813316E-11, 3.25260358301548823856E-11, -1.89749581235054123450E-11, -5.58974346219658380687E-10, -3.83538038596423702205E-9, -2.63146884688951950684E-8, -2.51223623787020892529E-7, -3.88256480887769039346E-6, -1.10588938762623716291E-4, -9.76109749136146840777E-3, 7.78576235018280120474E-1];\n\nfunction i1(x) {\n  var y = void 0,\n      z = void 0;\n\n  z = Math.abs(x);\n  if (z <= 8.0) {\n    y = z / 2.0 - 2.0;\n    z = (0, _chbevl.chbevl)(y, A, 29) * z * Math.exp(z);\n  } else {\n    z = Math.exp(z) * (0, _chbevl.chbevl)(32.0 / z - 2.0, B, 25) / Math.sqrt(z);\n  }\n  if (x < 0.0) {\n    z = -z;\n  }\n  return z;\n}\n\nfunction i1e(x) {\n  var y = void 0,\n      z = void 0;\n\n  z = Math.abs(x);\n  if (z <= 8.0) {\n    y = z / 2.0 - 2.0;\n    z = (0, _chbevl.chbevl)(y, A, 29) * z;\n  } else {\n    z = (0, _chbevl.chbevl)(32.0 / z - 2.0, B, 25) / Math.sqrt(z);\n  }\n  if (x < 0.0) {\n    z = -z;\n  }\n  return z;\n}\n\nexports.i1 = i1;\nexports.i1e = i1e;\n},{\"./chbevl.js\":50}],64:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.iv = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * @file        iv.js         Modified Bessel function of noninteger order\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * SYNOPSIS:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * double v, x, y, iv();\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * y = iv( v, x );\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * DESCRIPTION:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Returns modified Bessel function of order v of the\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * argument.  If x is negative, v must be integer valued.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * If x < 0, then v must be an integer.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Parts of the code are copyright:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *     Cephes Math Library Release 2.8:  June, 2000\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *     Copyright 1984, 1987, 1988, 2000 by Stephen L. Moshier\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * And other parts:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *     Copyright (c) 2006 Xiaogang Zhang\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *     Use, modification and distribution are subject to the\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *     Boost Software License, Version 1.0.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *     Boost Software License - Version 1.0 - August 17th, 2003\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *     Permission is hereby granted, free of charge, to any person or\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *     organization obtaining a copy of the software and accompanying\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *     documentation covered by this license (the \"Software\") to use, reproduce,\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *     display, distribute, execute, and transmit the Software, and to prepare\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *     derivative works of the Software, and to permit third-parties to whom the\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *     Software is furnished to do so, all subject to the following:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *     The copyright notices in the Software and this entire statement,\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *     including the above license grant, this restriction and the following\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *     disclaimer, must be included in all copies of the Software, in whole or\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *     in part, and all derivative works of the Software, unless such copies or\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *     derivative works are solely in the form of machine-executable object code\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *     generated by a source language processor.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *     NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *     DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY,\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *     WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *     CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *     SOFTWARE.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * And the rest are:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *     Copyright (C) 2009 Pauli Virtanen\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *     Distributed under the same license as Scipy.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * And in 2018:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *   Ported to ECMAScript 2018\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *   Copyright (c) 2018, Kings Distributed Systems\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *   @author      KC Erb, kc@kcerb.com\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *   @date        April 2018\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */\n\n\nvar _ikvTemme3 = require('./iv/ikvTemme.js');\n\nvar _ikvAsymptoticUniform3 = require('./iv/ikvAsymptoticUniform.js');\n\nfunction iv(v, x) {\n  var sign = void 0,\n      t = void 0,\n      ax = void 0,\n      res = void 0;\n\n  /* If v is a negative integer, invoke symmetry */\n  t = Math.floor(v);\n  if (v < 0.0) {\n    if (t === v) {\n      v = -v; /* symmetry */\n      t = -t;\n    }\n  }\n  /* If x is negative, require v to be an integer */\n  sign = 1;\n  if (x < 0.0) {\n    if (t !== v) {\n      // mtherr(\"iv\", DOMAIN);\n      return NaN;\n    }\n    if (v !== 2.0 * Math.floor(v / 2.0)) {\n      sign = -1;\n    }\n  }\n\n  /* Avoid logarithm singularity */\n  if (x === 0.0) {\n    if (v === 0.0) {\n      return 1.0;\n    }\n    if (v < 0.0) {\n      // mtherr(\"iv\", OVERFLOW);\n      return Infinity;\n    } else {\n      return 0.0;\n    }\n  }\n\n  ax = Math.abs(x);\n  if (Math.abs(v) > 50) {\n    var _ikvAsymptoticUniform = (0, _ikvAsymptoticUniform3.ikvAsymptoticUniform)(v, ax);\n    /*\n    * Uniform asymptotic expansion for large orders.\n    *\n    * This appears to overflow slightly later than the Boost\n    * implementation of Temme's method.\n    */\n\n\n    var _ikvAsymptoticUniform2 = _slicedToArray(_ikvAsymptoticUniform, 1);\n\n    res = _ikvAsymptoticUniform2[0];\n  } else {\n    var _ikvTemme = (0, _ikvTemme3.ikvTemme)(v, ax);\n    /* Otherwise: Temme's method */\n\n\n    var _ikvTemme2 = _slicedToArray(_ikvTemme, 1);\n\n    res = _ikvTemme2[0];\n  }\n  res *= sign;\n  return res;\n}\n\nexports.iv = iv;\n},{\"./iv/ikvAsymptoticUniform.js\":65,\"./iv/ikvTemme.js\":66}],65:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ikvAsymptoticUniform = undefined;\n\nvar _constants = require('../constants.js');\n\nvar constants = _interopRequireWildcard(_constants);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/*\n* Compute Iv, Kv from (AMS5 9.7.7 + 9.7.8), asymptotic expansion for large v\n*/\nvar N_UFACTORS = 11;\nvar N_UFACTOR_TERMS = 31;\n\n/*\n* Uniform asymptotic expansion factors, (AMS5 9.3.9; AMS5 9.3.10)\n*/\nvar asymptoticUfactors = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.20833333333333334, 0.0, 0.125, 0.0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.3342013888888889, 0.0, -0.40104166666666669, 0.0, 0.0703125, 0.0, 0.0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1.0258125964506173, 0.0, 1.8464626736111112, 0.0, -0.89121093750000002, 0.0, 0.0732421875, 0.0, 0.0, 0.0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4.6695844234262474, 0.0, -11.207002616222995, 0.0, 8.78912353515625, 0.0, -2.3640869140624998, 0.0, 0.112152099609375, 0.0, 0.0, 0.0, 0.0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -28.212072558200244, 0.0, 84.636217674600744, 0.0, -91.818241543240035, 0.0, 42.534998745388457, 0.0, -7.3687943594796312, 0.0, 0.22710800170898438, 0.0, 0.0, 0.0, 0.0, 0.0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 212.5701300392171, 0.0, -765.25246814118157, 0.0, 1059.9904525279999, 0.0, -699.57962737613275, 0.0, 218.19051174421159, 0.0, -26.491430486951554, 0.0, 0.57250142097473145, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0, 0, 0, 0, 0, 0, 0, 0, 0, -1919.4576623184068, 0.0, 8061.7221817373083, 0.0, -13586.550006434136, 0.0, 11655.393336864536, 0.0, -5305.6469786134048, 0.0, 1200.9029132163525, 0.0, -108.09091978839464, 0.0, 1.7277275025844574, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0, 0, 0, 0, 0, 0, 20204.291330966149, 0.0, -96980.598388637503, 0.0, 192547.0012325315, 0.0, -203400.17728041555, 0.0, 122200.46498301747, 0.0, -41192.654968897557, 0.0, 7109.5143024893641, 0.0, -493.915304773088, 0.0, 6.074042001273483, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0, 0, 0, -242919.18790055133, 0.0, 1311763.6146629769, 0.0, -2998015.9185381061, 0.0, 3763271.2976564039, 0.0, -2813563.2265865342, 0.0, 1268365.2733216248, 0.0, -331645.17248456361, 0.0, 45218.768981362737, 0.0, -2499.8304818112092, 0.0, 24.380529699556064, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [3284469.8530720375, 0.0, -19706819.11843222, 0.0, 50952602.492664628, 0.0, -74105148.211532637, 0.0, 66344512.274729028, 0.0, -37567176.660763353, 0.0, 13288767.166421819, 0.0, -2785618.1280864552, 0.0, 308186.40461266245, 0.0, -13886.089753717039, 0.0, 110.01714026924674, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]];\nfunction ikvAsymptoticUniform(v, x) {\n  // CHECK: I believe the following is equivalent to what we had before ....\n  var iValue = 0;\n  var kValue = null;\n  var iPrefactor = void 0,\n      kPrefactor = void 0,\n      t = void 0,\n      t2 = void 0,\n      eta = void 0,\n      z = void 0,\n      iSum = void 0,\n      kSUm = void 0,\n      term = void 0,\n      divisor = void 0,\n      k = void 0,\n      n = void 0;\n  var sign = 1;\n\n  if (v < 0) {\n    /* Negative v; compute I_{-v} and K_{-v} and use (AMS 9.6.2) */\n    sign = -1;\n    v = -v;\n  }\n\n  z = x / v;\n  t = 1 / Math.sqrt(1 + z * z);\n  t2 = t * t;\n  eta = Math.sqrt(1 + z * z) + Math.log(z / (1 + 1 / t));\n\n  iPrefactor = Math.sqrt(t / (2 * Math.PI * v)) * Math.exp(v * eta);\n  iSum = 1.0;\n\n  kPrefactor = Math.sqrt(Math.PI * t / (2 * v)) * Math.exp(-v * eta);\n  kSUm = 1.0;\n\n  divisor = v;\n  for (n = 1; n < N_UFACTORS; ++n) {\n    /*\n    * Evaluate u_k(t) with Horner's scheme;\n    * (using the knowledge about which coefficients are zero)\n    */\n    term = 0;\n    for (k = N_UFACTOR_TERMS - 1 - 3 * n; k < N_UFACTOR_TERMS - n; k += 2) {\n      term *= t2;\n      term += asymptoticUfactors[n][k];\n    }\n    for (k = 1; k < n; k += 2) {\n      term *= t2;\n    }\n    if (n % 2 === 1) {\n      term *= t;\n    }\n\n    /* Sum terms */\n    term /= divisor;\n    iSum += term;\n    kSUm += n % 2 === 0 ? term : -term;\n\n    /* Check convergence */\n    if (Math.abs(term) < constants.MACHEP) {\n      break;\n    }\n\n    divisor *= v;\n  }\n\n  if (Math.abs(term) > 1e-3 * Math.abs(iSum)) {\n    /* Didn't converge */\n    // mtherr(\"ikvAsymptoticUniform\", TLOSS);\n  }\n  if (Math.abs(term) > constants.MACHEP * Math.abs(iSum)) {\n    /* Some precision lost */\n    // mtherr(\"ikvAsymptoticUniform\", PLOSS);\n  }\n\n  if (kValue !== null) {\n    /* symmetric in v */\n    kValue = kPrefactor * kSUm;\n  }\n\n  if (iValue !== null) {\n    if (sign === 1) {\n      iValue = iPrefactor * iSum;\n    } else {\n      /* (AMS 9.6.2) */\n      iValue = iPrefactor * iSum + 2 / Math.PI * Math.sin(Math.PI * v) * kPrefactor * kSUm;\n    }\n  }\n\n  return [iValue, kValue];\n}\n\nexports.ikvAsymptoticUniform = ikvAsymptoticUniform;\n},{\"../constants.js\":51}],66:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ikvTemme = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _constants = require('../constants.js');\n\nvar constants = _interopRequireWildcard(_constants);\n\nvar _gamma = require('../gamma.js');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/*\n* Compute I(v, x) and K(v, x) simultaneously by Temme's method, see\n* Temme, Journal of Computational Physics, vol 19, 324 (1975)\n*/\nvar NEED_I = 0x1;\nvar NEED_K = 0x2;\n\nfunction ikvTemme(v, x) {\n  var ivP = 0;\n  var kvP = null;\n  var u = void 0,\n      iV = void 0,\n      kv = void 0,\n      kv1 = void 0,\n      ku = void 0,\n      ku1 = void 0,\n      fv = void 0,\n      capitalW = void 0,\n      current = void 0,\n      prev = void 0,\n      next = void 0,\n      n = void 0,\n      k = void 0,\n      kind = void 0,\n      z = void 0,\n      lim = void 0;\n  var reflect = 0;\n  kind = 0;\n  if (ivP !== null) {\n    kind = kind | NEED_I;\n  }\n  if (kvP !== null) {\n    kind = kind | NEED_K;\n  }\n\n  if (v < 0) {\n    reflect = 1;\n    v = -v; /* v is non-negative from here */\n    kind = kind | NEED_K;\n  }\n  n = Math.round(v);\n  u = v - n; /* -1/2 <= u < 1/2 */\n\n  if (x < 0) {\n    if (ivP !== null) {\n      ivP = NaN;\n    }\n    if (kvP !== null) {\n      kvP = NaN;\n    }\n    // mtherr(\"ikv_temme\", DOMAIN);\n    return [ivP, kvP];\n  }\n  if (x === 0) {\n    iV = v === 0 ? 1 : 0;\n    if (kind & NEED_K) {\n      // mtherr(\"ikv_temme\", OVERFLOW);\n      kv = Infinity;\n    } else {\n      kv = NaN; /* any value will do */\n    }\n\n    if (reflect && kind & NEED_I) {\n      z = u + n % 2;\n\n      iV = Math.sin(Math.PI * z) === 0 ? iV : Infinity;\n      if (iV === Infinity || iV === -Infinity) {\n        // mtherr(\"ikv_temme\", OVERFLOW);\n      }\n    }\n\n    if (ivP !== null) {\n      ivP = iV;\n    }\n    if (kvP !== null) {\n      kvP = kv;\n    }\n    return [ivP, kvP];\n  }\n\n  /* x is positive until reflection */\n  capitalW = 1 / x; /* Wronskian */\n  if (x <= 2) {\n    /* Temme series */\n    var _temmeIkSeries = temmeIkSeries(u, x); /* x in (0, 2] */\n\n\n    var _temmeIkSeries2 = _slicedToArray(_temmeIkSeries, 2);\n\n    ku = _temmeIkSeries2[0];\n    ku1 = _temmeIkSeries2[1];\n  } else {\n    /* continued fraction cF2Ik */\n    var _cF2Ik = cF2Ik(u, x, ku, ku1); /* x in (2, \\infty) */\n\n\n    var _cF2Ik2 = _slicedToArray(_cF2Ik, 2);\n\n    ku = _cF2Ik2[0];\n    ku1 = _cF2Ik2[1];\n  }\n  prev = ku;\n  current = ku1;\n  for (k = 1; k <= n; k++) {\n    /* forward recurrence for K */\n    next = 2 * (u + k) * current / x + prev;\n    prev = current;\n    current = next;\n  }\n  kv = prev;\n  kv1 = current;\n  if (kind & NEED_I) {\n    lim = (4 * v * v + 10) / (8 * x);\n    lim *= lim;\n    lim *= lim;\n    lim /= 24;\n    if (lim < constants.MACHEP * 10 && x > 100) {\n      /*\n      * x is huge compared to v, CF1 may be very slow\n      * to converge so use asymptotic expansion for large\n      * x case instead.  Note that the asymptotic expansion\n      * isn't very accurate - so it's deliberately very hard\n      * to get here - probably we're going to overflow:\n      */\n      iV = ivAsymptotic(v, x);\n    } else {\n      fv = cF1Ik(v, x); /* continued fraction cF1Ik */\n      iV = capitalW / (kv * fv + kv1); /* Wronskian relation */\n    }\n  } else {\n    iV = NaN; /* any value will do */\n  }\n\n  if (reflect) {\n    z = u + n % 2;\n\n    if (ivP !== null) {\n      ivP = iV + 2 / Math.PI * Math.sin(Math.PI * z) * kv; /* reflection formula */\n    }\n    if (kvP !== null) {\n      kvP = kv;\n    }\n  } else {\n    if (ivP !== null) {\n      ivP = iV;\n    }\n    if (kvP !== null) {\n      kvP = kv;\n    }\n  }\n  return [ivP, kvP];\n}\n\n/*\n* Compute iV from (AMS5 9.7.1), asymptotic expansion for large |z|\n* iV ~ exp(x)/Math.sqrt(2 pi x) ( 1 + (4*v*v-1)/8x + (4*v*v-1)(4*v*v-9)/8x/2! + ...)\n*/\nfunction ivAsymptotic(v, x) {\n  var mu = void 0,\n      sum = void 0,\n      term = void 0,\n      prefactor = void 0,\n      factor = void 0,\n      k = void 0;\n  prefactor = Math.exp(x) / Math.sqrt(2 * Math.PI * x);\n\n  if (prefactor === Infinity) {\n    return prefactor;\n  }\n\n  mu = 4 * v * v;\n  sum = 1.0;\n  term = 1.0;\n  k = 1;\n\n  do {\n    factor = (mu - (2 * k - 1) * (2 * k - 1)) / (8 * x) / k;\n    if (k > 100) {\n      /* didn't converge */\n      // mtherr(\"iv(ivAsymptotic)\", TLOSS);\n      break;\n    }\n    term *= -factor;\n    sum += term;\n    ++k;\n  } while (Math.abs(term) > constants.MACHEP * Math.abs(sum));\n  return sum * prefactor;\n}\n\n/*\n* Modified Bessel functions of the first and second kind of fractional order\n*\n* Calculate K(v, x) and K(v+1, x) by method analogous to\n* Temme, Journal of Computational Physics, vol 21, 343 (1976)\n*/\nfunction temmeIkSeries(v, x) {\n  var f = void 0,\n      h = void 0,\n      p = void 0,\n      q = void 0,\n      coef = void 0,\n      sum = void 0,\n      sum1 = void 0,\n      tolerance = void 0,\n      a = void 0,\n      b = void 0,\n      c = void 0,\n      d = void 0,\n      sigma = void 0,\n      gamma1 = void 0,\n      gamma2 = void 0,\n      k = void 0,\n      gp = void 0,\n      gm = void 0,\n      kres = void 0,\n      kres1 = void 0;\n\n  /*\n  * |x| <= 2, Temme series converge rapidly\n  * |x| > 2, the larger the |x|, the slower the convergence\n  */\n  boostAssert(Math.abs(x) <= 2, '|x| > 2, the larger the |x|, the slower the convergence');\n  boostAssert(Math.abs(v) <= 0.5, '|v| > 0.5');\n\n  gp = (0, _gamma.gamma)(v + 1) - 1;\n  gm = (0, _gamma.gamma)(-v + 1) - 1;\n\n  a = Math.log(x / 2);\n  b = Math.exp(v * a);\n  sigma = -a * v;\n  c = Math.abs(v) < constants.MACHEP ? 1 : Math.sin(Math.PI * v) / (v * Math.PI);\n  d = Math.abs(sigma) < constants.MACHEP ? 1 : Math.sinh(sigma) / sigma;\n  gamma1 = Math.abs(v) < constants.MACHEP ? -constants.EULER : 0.5 / v * (gp - gm) * c;\n  gamma2 = (2 + gp + gm) * c / 2;\n\n  /* initial values */\n  p = (gp + 1) / (2 * b);\n  q = (1 + gm) * b / 2;\n  f = (Math.cosh(sigma) * gamma1 + d * -a * gamma2) / c;\n  h = p;\n  coef = 1;\n  sum = coef * f;\n  sum1 = coef * h;\n\n  /* series summation */\n  tolerance = constants.MACHEP;\n  for (k = 1; k < constants.MAXITER; k++) {\n    f = (k * f + p + q) / (k * k - v * v);\n    p /= k - v;\n    q /= k + v;\n    h = p - k * f;\n    coef *= x * x / (4 * k);\n    sum += coef * f;\n    sum1 += coef * h;\n    if (Math.abs(coef * f) < Math.abs(sum) * tolerance) {\n      break;\n    }\n  }\n  if (k === constants.MAXITER) {\n    // mtherr(\"ikvTemme(temmeIkSeries)\", TLOSS);\n  }\n\n  kres = sum;\n  kres1 = 2 * sum1 / x;\n\n  return [kres, kres1];\n}\n\n/* Evaluate continued fraction fv = I_(v+1) / I_v, derived from\n* Abramowitz and Stegun, Handbook of Mathematical Functions, 1972, 9.1.73 */\nfunction cF1Ik(v, x) {\n  var capitalC = void 0,\n      capitalD = void 0,\n      f = void 0,\n      a = void 0,\n      b = void 0,\n      delta = void 0,\n      tiny = void 0,\n      tolerance = void 0,\n      fv = void 0,\n      k = void 0;\n  /*\n  * |x| <= |v|, cF1Ik converges rapidly\n  * |x| > |v|, cF1Ik needs O(|x|) iterations to converge\n  */\n\n  /*\n  * modified Lentz's method, see\n  * Lentz, Applied Optics, vol 15, 668 (1976)\n  */\n  tolerance = 2 * constants.MACHEP;\n  tiny = 1 / Math.sqrt(constants.DBL_MAX);\n  capitalC = f = tiny; /* b0 = 0, replace with tiny */\n  capitalD = 0;\n  for (k = 1; k < constants.MAXITER; k++) {\n    a = 1;\n    b = 2 * (v + k) / x;\n    capitalC = b + a / capitalC;\n    capitalD = b + a * capitalD;\n    if (capitalC === 0) {\n      capitalC = tiny;\n    }\n    if (capitalD === 0) {\n      capitalD = tiny;\n    }\n    capitalD = 1 / capitalD;\n    delta = capitalC * capitalD;\n    f *= delta;\n    if (Math.abs(delta - 1) <= tolerance) {\n      break;\n    }\n  }\n  if (k === constants.MAXITER) {\n    // mtherr(\"ikvTemme(cF1Ik)\", TLOSS);\n  }\n\n  fv = f;\n\n  return fv;\n}\n\n/*\n* Calculate K(v, x) and K(v+1, x) by evaluating continued fraction\n* z1 / z0 = U(v+1.5, 2v+1, 2x) / U(v+0.5, 2v+1, 2x), see\n* Thompson and Barnett, Computer Physics Communications, vol 47, 245 (1987)\n*/\nfunction cF2Ik(v, x) {\n  var capitalS = void 0,\n      capitalC = void 0,\n      capitalQ = void 0,\n      capitalD = void 0,\n      f = void 0,\n      a = void 0,\n      b = void 0,\n      q = void 0,\n      delta = void 0,\n      tolerance = void 0,\n      current = void 0,\n      prev = void 0,\n      kvRes = void 0,\n      kv1Res = void 0,\n      k = void 0;\n\n  /*\n  * |x| >= |v|, cF2Ik converges rapidly\n  * |x| -> 0, cF2Ik fails to converge\n  */\n  boostAssert(Math.abs(x) > 1, 'cF2Ik fails to converge since: |x| <= 1');\n\n  /*\n  * Steed's algorithm, see Thompson and Barnett,\n  * Journal of Computational Physics, vol 64, 490 (1986)\n  */\n  tolerance = constants.MACHEP;\n  a = v * v - 0.25;\n  b = 2 * (x + 1); /* b1 */\n  capitalD = 1 / b; /* D1 = 1 / b1 */\n  f = delta = capitalD; /* f1 = delta1 = D1, coincidence */\n  prev = 0; /* q0 */\n  current = 1; /* q1 */\n  capitalQ = capitalC = -a; /* Q1 = C1 because q1 = 1 */\n  capitalS = 1 + capitalQ * delta; /* S1 */\n  for (k = 2; k < constants.MAXITER; k++) {\n    /* starting from 2 */\n    /* continued fraction f = z1 / z0 */\n    a -= 2 * (k - 1);\n    b += 2;\n    capitalD = 1 / (b + a * capitalD);\n    delta *= b * capitalD - 1;\n    f += delta;\n\n    /* series summation capitalS = 1 + \\sum_{n=1}^{\\infty} C_n * z_n / z_0 */\n    q = (prev - (b - 2) * current) / a;\n    prev = current;\n    current = q; /* forward recurrence for q */\n    capitalC *= -a / k;\n    capitalQ += capitalC * q;\n    capitalS += capitalQ * delta;\n\n    /* capitalS converges slower than f */\n    if (Math.abs(capitalQ * delta) < Math.abs(capitalS) * tolerance) {\n      break;\n    }\n  }\n  if (k === constants.MAXITER) {\n    // mtherr(\"ikvTemme(cF2Ik)\", TLOSS);\n  }\n\n  kvRes = Math.sqrt(Math.PI / (2 * x)) * Math.exp(-x) / capitalS;\n  kv1Res = kvRes * (0.5 + v + x + (v * v - 0.25) * f) / x;\n\n  return [kvRes, kv1Res];\n}\n\nfunction boostAssert(expr, msg) {\n  if (expr) {\n    // do nothing\n  } else {\n    throw new Error(msg);\n  }\n}\nexports.ikvTemme = ikvTemme;\n},{\"../constants.js\":51,\"../gamma.js\":55}],67:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.y0 = exports.j0 = undefined;\n\nvar _constants = require('./constants.js');\n\nvar constants = _interopRequireWildcard(_constants);\n\nvar _polevl = require('./polevl.js');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @file        j0.js         Bessel function of order zero\n *\n *\n *\n * SYNOPSIS:\n *\n * double x, y, j0();\n *\n * y = j0( x );\n *\n *\n *\n * DESCRIPTION:\n *\n * Returns Bessel function of order zero of the argument.\n *\n * The domain is divided into the intervals [0, 5] and\n * (5, infinity). In the first interval the following rational\n * approximation is used:\n *\n *\n *        2         2\n * (w - r  ) (w - r  ) P (w) / Q (w)\n *       1         2    3       8\n *\n *            2\n * where w = x  and the two r's are zeros of the function.\n *\n * In the second interval, the Hankel asymptotic expansion\n * is employed with two rational functions of degree 6/6\n * and 7/7.\n *\n *\n *\n * ACCURACY:\n *\n *                      Absolute error:\n * arithmetic   domain     # trials      peak         rms\n *    IEEE      0, 30       60000       4.2e-16     1.1e-16\n *\n *\n *  Bessel function of the second kind, order zero\n *\n *\n *\n * SYNOPSIS:\n *\n * double x, y, y0();\n *\n * y = y0( x );\n *\n *\n *\n * DESCRIPTION:\n *\n * Returns Bessel function of the second kind, of order\n * zero, of the argument.\n *\n * The domain is divided into the intervals [0, 5] and\n * (5, infinity). In the first interval a rational approximation\n * R(x) is employed to compute\n *   y0(x)  = R(x)  +   2 * log(x) * j0(x) / NPY_PI.\n * Thus a call to j0() is required.\n *\n * In the second interval, the Hankel asymptotic expansion\n * is employed with two rational functions of degree 6/6\n * and 7/7.\n *\n *\n *\n * ACCURACY:\n *\n *  Absolute error, when y0(x) < 1; else relative error:\n *\n * arithmetic   domain     # trials      peak         rms\n *    IEEE      0, 30       30000       1.3e-15     1.6e-16\n *\n * Cephes Math Library Release 2.8:  June, 2000\n * Copyright 1984, 1987, 1989, 2000 by Stephen L. Moshier\n *  Ported to ECMAScript 2018\n *  Copyright (c) 2018, Kings Distributed Systems\n *\n *  @author      KC Erb, kc@kcerb.com\n *  @date        April 2018\n */\n\n/* Note: all coefficients satisfy the relative error criterion\n * except YP, YQ which are designed for absolute error. */\nvar PP = [7.96936729297347051624E-4, 8.28352392107440799803E-2, 1.23953371646414299388E0, 5.44725003058768775090E0, 8.74716500199817011941E0, 5.30324038235394892183E0, 9.99999999999999997821E-1];\n\nvar PQ = [9.24408810558863637013E-4, 8.56288474354474431428E-2, 1.25352743901058953537E0, 5.47097740330417105182E0, 8.76190883237069594232E0, 5.30605288235394617618E0, 1.00000000000000000218E0];\n\nvar QP = [-1.13663838898469149931E-2, -1.28252718670509318512E0, -1.95539544257735972385E1, -9.32060152123768231369E1, -1.77681167980488050595E2, -1.47077505154951170175E2, -5.14105326766599330220E1, -6.05014350600728481186E0];\n\nvar QQ = [\n/*  1.00000000000000000000E0, */\n6.43178256118178023184E1, 8.56430025976980587198E2, 3.88240183605401609683E3, 7.24046774195652478189E3, 5.93072701187316984827E3, 2.06209331660327847417E3, 2.42005740240291393179E2];\n\nvar YP = [1.55924367855235737965E4, -1.46639295903971606143E7, 5.43526477051876500413E9, -9.82136065717911466409E11, 8.75906394395366999549E13, -3.46628303384729719441E15, 4.42733268572569800351E16, -1.84950800436986690637E16];\n\nvar YQ = [\n/* 1.00000000000000000000E0, */\n1.04128353664259848412E3, 6.26107330137134956842E5, 2.68919633393814121987E8, 8.64002487103935000337E10, 2.02979612750105546709E13, 3.17157752842975028269E15, 2.50596256172653059228E17];\n\n/*  5.783185962946784521175995758455807035071 */\nvar DR1 = 5.78318596294678452118E0;\n\n/* 30.47126234366208639907816317502275584842 */\nvar DR2 = 3.04712623436620863991E1;\n\nvar RP = [-4.79443220978201773821E9, 1.95617491946556577543E12, -2.49248344360967716204E14, 9.70862251047306323952E15];\n\nvar RQ = [\n/* 1.00000000000000000000E0, */\n4.99563147152651017219E2, 1.73785401676374683123E5, 4.84409658339962045305E7, 1.11855537045356834862E10, 2.11277520115489217587E12, 3.10518229857422583814E14, 3.18121955943204943306E16, 1.71086294081043136091E18];\n\nfunction j0(x) {\n  var w = void 0,\n      z = void 0,\n      p = void 0,\n      q = void 0,\n      xn = void 0;\n\n  if (x < 0) x = -x;\n\n  if (x <= 5.0) {\n    z = x * x;\n    if (x < 1.0e-5) return 1.0 - z / 4.0;\n\n    p = (z - DR1) * (z - DR2);\n    p = p * (0, _polevl.polevl)(z, RP, 3) / (0, _polevl.p1evl)(z, RQ, 8);\n    return p;\n  }\n\n  w = 5.0 / x;\n  q = 25.0 / (x * x);\n  p = (0, _polevl.polevl)(q, PP, 6) / (0, _polevl.polevl)(q, PQ, 6);\n  q = (0, _polevl.polevl)(q, QP, 7) / (0, _polevl.p1evl)(q, QQ, 7);\n  xn = x - constants.NPY_PI_4;\n  p = p * Math.cos(xn) - w * q * Math.sin(xn);\n  return p * constants.SQ2OPI / Math.sqrt(x);\n}\n\n/*                                                     y0() 2  */\n/* Bessel function of second kind, order zero  */\n\n/* Rational approximation coefficients YP[], YQ[] are used here.\n * The function computed is  y0(x)  -  2 * log(x) * j0(x) / NPY_PI,\n * whose value at x = 0 is  2 * ( log(0.5) + EUL ) / NPY_PI\n * = 0.073804295108687225.\n */\n\nfunction y0(x) {\n  var w = void 0,\n      z = void 0,\n      p = void 0,\n      q = void 0,\n      xn = void 0;\n\n  if (x <= 5.0) {\n    if (x === 0.0) {\n      // mtherr('y0', SING);\n      return -Infinity;\n    } else if (x < 0.0) {\n      // mtherr('y0', DOMAIN);\n      return NaN;\n    }\n\n    z = x * x;\n    w = (0, _polevl.polevl)(z, YP, 7) / (0, _polevl.p1evl)(z, YQ, 7);\n    w += constants.NPY_2_PI * Math.log(x) * j0(x);\n    return w;\n  }\n\n  w = 5.0 / x;\n  z = 25.0 / (x * x);\n  p = (0, _polevl.polevl)(z, PP, 6) / (0, _polevl.polevl)(z, PQ, 6);\n  q = (0, _polevl.polevl)(z, QP, 7) / (0, _polevl.p1evl)(z, QQ, 7);\n  xn = x - constants.NPY_PI_4;\n  p = p * Math.sin(xn) + w * q * Math.cos(xn);\n  return p * constants.SQ2OPI / Math.sqrt(x);\n}\n\nexports.j0 = j0;\nexports.y0 = y0;\n},{\"./constants.js\":51,\"./polevl.js\":78}],68:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.y1 = exports.j1 = undefined;\n\nvar _constants = require('./constants.js');\n\nvar constants = _interopRequireWildcard(_constants);\n\nvar _polevl = require('./polevl.js');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @file        j1.js         Bessel function of order one\n *\n *\n *\n * SYNOPSIS:\n *\n * double x, y, j1();\n *\n * y = j1( x );\n *\n *\n *\n * DESCRIPTION:\n *\n * Returns Bessel function of order one of the argument.\n *\n * The domain is divided into the intervals [0, 8] and\n * (8, infinity). In the first interval a 24 term Chebyshev\n * expansion is used. In the second, the asymptotic\n * trigonometric representation is employed using two\n * rational functions of degree 5/5.\n *\n *\n *\n * ACCURACY:\n *\n *                      Absolute error:\n * arithmetic   domain      # trials      peak         rms\n *    IEEE      0, 30       30000       2.6e-16     1.1e-16\n *\n *\n *  Bessel function of second kind of order one\n *\n *\n *\n * SYNOPSIS:\n *\n * double x, y, y1();\n *\n * y = y1( x );\n *\n *\n *\n * DESCRIPTION:\n *\n * Returns Bessel function of the second kind of order one\n * of the argument.\n *\n * The domain is divided into the intervals [0, 8] and\n * (8, infinity). In the first interval a 25 term Chebyshev\n * expansion is used, and a call to j1() is required.\n * In the second, the asymptotic trigonometric representation\n * is employed using two rational functions of degree 5/5.\n *\n *\n *\n * ACCURACY:\n *\n *                      Absolute error:\n * arithmetic   domain      # trials      peak         rms\n *    IEEE      0, 30       30000       1.0e-15     1.3e-16\n *\n * (error criterion relative when |y1| > 1).\n *\n * Cephes Math Library Release 2.8:  June, 2000\n * Copyright 1984, 1987, 1989, 2000 by Stephen L. Moshier\n * Ported to ECMAScript 2018\n * Copyright (c) 2018, Kings Distributed Systems\n *\n * @author      KC Erb, kc@kcerb.com\n * @date        April 2018\n */\nvar RP = [-8.99971225705559398224E8, 4.52228297998194034323E11, -7.27494245221818276015E13, 3.68295732863852883286E15];\n\nvar RQ = [\n/* 1.00000000000000000000E0, */\n6.20836478118054335476E2, 2.56987256757748830383E5, 8.35146791431949253037E7, 2.21511595479792499675E10, 4.74914122079991414898E12, 7.84369607876235854894E14, 8.95222336184627338078E16, 5.32278620332680085395E18];\n\nvar PP = [7.62125616208173112003E-4, 7.31397056940917570436E-2, 1.12719608129684925192E0, 5.11207951146807644818E0, 8.42404590141772420927E0, 5.21451598682361504063E0, 1.00000000000000000254E0];\n\nvar PQ = [5.71323128072548699714E-4, 6.88455908754495404082E-2, 1.10514232634061696926E0, 5.07386386128601488557E0, 8.39985554327604159757E0, 5.20982848682361821619E0, 9.99999999999999997461E-1];\n\nvar QP = [5.10862594750176621635E-2, 4.98213872951233449420E0, 7.58238284132545283818E1, 3.66779609360150777800E2, 7.10856304998926107277E2, 5.97489612400613639965E2, 2.11688757100572135698E2, 2.52070205858023719784E1];\n\nvar QQ = [\n/* 1.00000000000000000000E0, */\n7.42373277035675149943E1, 1.05644886038262816351E3, 4.98641058337653607651E3, 9.56231892404756170795E3, 7.99704160447350683650E3, 2.82619278517639096600E3, 3.36093607810698293419E2];\n\nvar YP = [1.26320474790178026440E9, -6.47355876379160291031E11, 1.14509511541823727583E14, -8.12770255501325109621E15, 2.02439475713594898196E17, -7.78877196265950026825E17];\n\nvar YQ = [\n/* 1.00000000000000000000E0, */\n5.94301592346128195359E2, 2.35564092943068577943E5, 7.34811944459721705660E7, 1.87601316108706159478E10, 3.88231277496238566008E12, 6.20557727146953693363E14, 6.87141087355300489866E16, 3.97270608116560655612E18];\n\nvar Z1 = 1.46819706421238932572E1;\nvar Z2 = 4.92184563216946036703E1;\n\nfunction j1(x) {\n  var w = void 0,\n      z = void 0,\n      p = void 0,\n      q = void 0,\n      xn = void 0;\n\n  w = x;\n  if (x < 0) return -j1(-x);\n\n  if (w <= 5.0) {\n    z = x * x;\n    w = (0, _polevl.polevl)(z, RP, 3) / (0, _polevl.p1evl)(z, RQ, 8);\n    w = w * x * (z - Z1) * (z - Z2);\n    return w;\n  }\n\n  w = 5.0 / x;\n  z = w * w;\n  p = (0, _polevl.polevl)(z, PP, 6) / (0, _polevl.polevl)(z, PQ, 6);\n  q = (0, _polevl.polevl)(z, QP, 7) / (0, _polevl.p1evl)(z, QQ, 7);\n  xn = x - constants.THPIO4;\n  p = p * Math.cos(xn) - w * q * Math.sin(xn);\n  return p * constants.SQ2OPI / Math.sqrt(x);\n}\n\nfunction y1(x) {\n  var w = void 0,\n      z = void 0,\n      p = void 0,\n      q = void 0,\n      xn = void 0;\n\n  if (x <= 5.0) {\n    if (x === 0.0) {\n      // mtherr(\"y1\", SING);\n      return -Infinity;\n    } else if (x <= 0.0) {\n      // mtherr(\"y1\", DOMAIN);\n      return NaN;\n    }\n    z = x * x;\n    w = x * ((0, _polevl.polevl)(z, YP, 5) / (0, _polevl.p1evl)(z, YQ, 8));\n    w += constants.NPY_2_PI * (j1(x) * Math.log(x) - 1.0 / x);\n    return w;\n  }\n\n  w = 5.0 / x;\n  z = w * w;\n  p = (0, _polevl.polevl)(z, PP, 6) / (0, _polevl.polevl)(z, PQ, 6);\n  q = (0, _polevl.polevl)(z, QP, 7) / (0, _polevl.p1evl)(z, QQ, 7);\n  xn = x - constants.THPIO4;\n  p = p * Math.sin(xn) + w * q * Math.cos(xn);\n  return p * constants.SQ2OPI / Math.sqrt(x);\n}\n\nexports.j1 = j1;\nexports.y1 = y1;\n},{\"./constants.js\":51,\"./polevl.js\":78}],69:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.jv = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * @file        jv.js         Bessel function of noninteger order\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * SYNOPSIS:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * double v, x, y, jv();\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * y = jv( v, x );\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * DESCRIPTION:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Returns Bessel function of order v of the argument,\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * where v is real.  Negative x is allowed if v is an integer.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Several expansions are included: the ascending power\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * series, the Hankel expansion, and two transitional\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * expansions for large v.  If v is not too large, it\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * is reduced by recurrence to a region of best accuracy.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * The transitional expansions give 12D accuracy for v > 500.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * ACCURACY:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Results for integer v are indicated by *, where x and v\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * both vary from -125 to +125.  Otherwise,\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * x ranges from 0 to 125, v ranges as indicated by \"domain.\"\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Error criterion is absolute, except relative when |jv()| > 1.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * arithmetic  v domain  x domain    # trials      peak       rms\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *    IEEE      0,125     0,125      100000      4.6e-15    2.2e-16\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *    IEEE   -125,0       0,125       40000      5.4e-11    3.7e-13\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *    IEEE      0,500     0,500       20000      4.4e-15    4.0e-16\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Integer v:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *    IEEE   -125,125   -125,125      50000      3.5e-15*   1.9e-16*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Cephes Math Library Release 2.8:  June, 2000\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright 1984, 1987, 1989, 1992, 2000 by Stephen L. Moshier\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Ported to ECMAScript 2018\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright (c) 2018, Kings Distributed Systems\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * @author      KC Erb, kc@kcerb.com\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * @date        April 2018\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */\n\n\nvar _constants = require('./constants.js');\n\nvar constants = _interopRequireWildcard(_constants);\n\nvar _j = require('./j0.js');\n\nvar _j2 = require('./j1.js');\n\nvar _gamma = require('./gamma.js');\n\nvar _jvs = require('./jv/jvs.js');\n\nvar _hankel = require('./jv/hankel.js');\n\nvar _recur9 = require('./jv/recur.js');\n\nvar _jnx = require('./jv/jnx.js');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction jv(n, x) {\n  var k = void 0,\n      q = void 0,\n      t = void 0,\n      y = void 0,\n      an = void 0,\n      i = void 0,\n      sign = void 0,\n      nint = void 0,\n      condition = void 0;\n\n  nint = 0; /* Flag for integer n */\n  sign = 1; /* Flag for sign inversion */\n  an = Math.abs(n);\n  y = Math.floor(an);\n  if (y === an) {\n    nint = 1;\n    i = an - 16384.0 * Math.floor(an / 16384.0);\n    if (n < 0.0) {\n      if (i & 1) {\n        sign = -sign;\n      }\n      n = an;\n    }\n    if (x < 0.0) {\n      if (i & 1) {\n        sign = -sign;\n      }\n      x = -x;\n    }\n    if (n === 0.0) {\n      return (0, _j.j0)(x);\n    }\n    if (n === 1.0) {\n      return sign * (0, _j2.j1)(x);\n    }\n  }\n\n  if (x < 0.0 && y !== an) {\n    // mtherr(\"Jv\", DOMAIN);\n    y = NaN;\n    return sign * y;\n  }\n\n  if (x === 0 && n < 0 && !nint) {\n    // mtherr(\"Jv\", OVERFLOW);\n    return Infinity / (0, _gamma.gamma)(n + 1);\n  }\n\n  y = Math.abs(x);\n\n  if (y * y < Math.abs(n + 1) * constants.MACHEP) {\n    return Math.pow(0.5 * x, n) / (0, _gamma.gamma)(n + 1);\n  }\n\n  k = 3.6 * Math.sqrt(y);\n  t = 3.6 * Math.sqrt(an);\n\n  if (y < t && an > 21.0) return sign * (0, _jvs.jvs)(n, x);\n  if (an < k && y > 21.0) return sign * (0, _hankel.hankel)(n, x);\n\n  if (an < 500.0) {\n    /* Note: if x is too large, the continued fraction will fail; but then the\n    * Hankel expansion can be used. */\n    if (nint !== 0) {\n      k = 0.0;\n\n      var _recur = (0, _recur9.recur)(n, x, k, 1);\n\n      var _recur2 = _slicedToArray(_recur, 3);\n\n      q = _recur2[0];\n      n = _recur2[1];\n      k = _recur2[2];\n\n      if (k === 0.0) {\n        y = (0, _j.j0)(x) / q;\n        return sign * y;\n      }\n      if (k === 1.0) {\n        y = (0, _j2.j1)(x) / q;\n        return sign * y;\n      }\n    }\n\n    condition = an > 2.0 * y || n >= 0.0 && n < 20.0 && y > 6.0 && y < 20.0;\n\n    if (condition) {\n      /* Recur backwards from a larger value of n */\n      k = n;\n\n      y = y + an + 1.0;\n      if (y < 30.0) y = 30.0;\n      y = n + Math.floor(y - n);\n\n      var _recur3 = (0, _recur9.recur)(y, x, k, 0);\n\n      var _recur4 = _slicedToArray(_recur3, 3);\n\n      q = _recur4[0];\n      y = _recur4[1];\n      k = _recur4[2];\n\n      y = (0, _jvs.jvs)(y, x) * q;\n      return sign * y;\n    }\n\n    if (k <= 30.0) {\n      k = 2.0;\n    } else if (k < 90.0) {\n      k = 3 * k / 4;\n    }\n    if (an > k + 3.0) {\n      if (n < 0.0) k = -k;\n      q = n - Math.floor(n);\n      k = Math.floor(k) + q;\n      if (n > 0.0) {\n        var _recur5 = (0, _recur9.recur)(n, x, k, 1);\n\n        var _recur6 = _slicedToArray(_recur5, 3);\n\n        q = _recur6[0];\n        n = _recur6[1];\n        k = _recur6[2];\n      } else {\n        t = k;\n        k = n;\n\n        var _recur7 = (0, _recur9.recur)(t, x, k, 1);\n\n        var _recur8 = _slicedToArray(_recur7, 3);\n\n        q = _recur8[0];\n        t = _recur8[1];\n        k = _recur8[2];\n\n        k = t;\n      }\n      if (q === 0.0) {\n        y = 0.0;\n        return sign * y;\n      }\n    } else {\n      k = n;\n      q = 1.0;\n    }\n\n    /* boundary between convergence of\n    * power series and Hankel expansion\n    */\n    y = Math.abs(k);\n    if (y < 26.0) {\n      t = (0.0083 * y + 0.09) * y + 12.9;\n    } else {\n      t = 0.9 * y;\n    }\n\n    if (x > t) {\n      y = (0, _hankel.hankel)(k, x);\n    } else {\n      y = (0, _jvs.jvs)(k, x);\n    }\n    if (n > 0.0) {\n      y /= q;\n    } else {\n      y *= q;\n    }\n  } else {\n    /* For large n, use the uniform expansion or the transitional expansion.\n    * But if x is of the order of n**2, these may blow up, whereas the\n    * Hankel expansion will then work.\n    */\n    if (n < 0.0) {\n      // mtherr(\"Jv\", TLOSS);\n      y = NaN;\n      return sign * y;\n    }\n    t = x / n;\n    t /= n;\n    if (t > 0.3) {\n      y = (0, _hankel.hankel)(n, x);\n    } else {\n      y = (0, _jnx.jnx)(n, x);\n    }\n  }\n  return sign * y;\n}\n\nexports.jv = jv;\n},{\"./constants.js\":51,\"./gamma.js\":55,\"./j0.js\":67,\"./j1.js\":68,\"./jv/hankel.js\":70,\"./jv/jnx.js\":72,\"./jv/jvs.js\":73,\"./jv/recur.js\":74}],70:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hankel = undefined;\n\nvar _constants = require('../constants.js');\n\nvar constants = _interopRequireWildcard(_constants);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/* Hankel's asymptotic expansion\n* for large x.\n* AMS55 #9.2.5.\n*/\n\nfunction hankel(n, x) {\n  var t = void 0,\n      u = void 0,\n      z = void 0,\n      k = void 0,\n      sign = void 0,\n      conv = void 0,\n      p = void 0,\n      q = void 0,\n      j = void 0,\n      m = void 0,\n      pp = void 0,\n      qq = void 0,\n      flag = void 0;\n  m = 4.0 * n * n;\n  j = 1.0;\n  z = 8.0 * x;\n  k = 1.0;\n  p = 1.0;\n  u = (m - 1.0) / z;\n  q = u;\n  sign = 1.0;\n  conv = 1.0;\n  flag = 0;\n  t = 1.0;\n  pp = 1.0e38;\n  qq = 1.0e38;\n\n  while (t > constants.MACHEP) {\n    k += 2.0;\n    j += 1.0;\n    sign = -sign;\n    u *= (m - k * k) / (j * z);\n    p += sign * u;\n    k += 2.0;\n    j += 1.0;\n    u *= (m - k * k) / (j * z);\n    q += sign * u;\n    t = Math.abs(u / p);\n    if (t < conv) {\n      conv = t;\n      qq = q;\n      pp = p;\n      flag = 1;\n    }\n    /* stop if the terms start getting larger */\n    if (flag !== 0 && t > conv) break;\n  }\n\n  u = x - (0.5 * n + 0.25) * Math.PI;\n  t = Math.sqrt(2.0 / (Math.PI * x)) * (pp * Math.cos(u) - qq * Math.sin(u));\n  return t;\n}\n\nexports.hankel = hankel;\n},{\"../constants.js\":51}],71:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.jnt = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _airy3 = require('../airy.js');\n\nvar _polevl = require('../polevl.js');\n\n/* Asymptotic expansion for transition region,\n* n large and x close to n.\n* AMS55 #9.3.23.\n*/\nvar PF2 = [-9.0000000000000000000e-2, 8.5714285714285714286e-2];\n\nvar PF3 = [1.3671428571428571429e-1, -5.4920634920634920635e-2, -4.4444444444444444444e-3];\n\nvar PF4 = [1.3500000000000000000e-3, -1.6036054421768707483e-1, 4.2590187590187590188e-2, 2.7330447330447330447e-3];\n\nvar PG1 = [-2.4285714285714285714e-1, 1.4285714285714285714e-2];\n\nvar PG2 = [-9.0000000000000000000e-3, 1.9396825396825396825e-1, -1.1746031746031746032e-2];\n\nvar PG3 = [1.9607142857142857143e-2, -1.5983694083694083694e-1, 6.3838383838383838384e-3];\n\nfunction jnt(n, x) {\n  var z = void 0,\n      zz = void 0,\n      z3 = void 0,\n      cbn = void 0,\n      n23 = void 0,\n      cbtwo = void 0,\n      ai = void 0,\n      aip = void 0,\n      bi = void 0,\n      bip = void 0,\n      nk = void 0,\n      fk = void 0,\n      gk = void 0,\n      pp = void 0,\n      qq = void 0,\n      k = void 0;\n\n  var fArr = new Float64Array(5);\n  var gArr = new Float64Array(4);\n\n  cbn = Math.cbrt(n);\n  z = (x - n) / cbn;\n  cbtwo = Math.cbrt(2.0);\n\n  /* Airy function */\n  zz = -cbtwo * z;\n\n  /* polynomials in expansion */\n  var _airy = (0, _airy3.airy)(zz, ai, aip, bi, bip);\n\n  var _airy2 = _slicedToArray(_airy, 4);\n\n  ai = _airy2[0];\n  aip = _airy2[1];\n  bi = _airy2[2];\n  bip = _airy2[3];\n  zz = z * z;\n  z3 = zz * z;\n  fArr[0] = 1.0;\n  fArr[1] = -z / 5.0;\n  fArr[2] = (0, _polevl.polevl)(z3, PF2, 1) * zz;\n  fArr[3] = (0, _polevl.polevl)(z3, PF3, 2);\n  fArr[4] = (0, _polevl.polevl)(z3, PF4, 3) * z;\n  gArr[0] = 0.3 * zz;\n  gArr[1] = (0, _polevl.polevl)(z3, PG1, 1);\n  gArr[2] = (0, _polevl.polevl)(z3, PG2, 2) * z;\n  gArr[3] = (0, _polevl.polevl)(z3, PG3, 2) * zz;\n\n  pp = 0.0;\n  qq = 0.0;\n  nk = 1.0;\n  n23 = Math.cbrt(n * n);\n\n  for (k = 0; k <= 4; k++) {\n    fk = fArr[k] * nk;\n    pp += fk;\n    if (k !== 4) {\n      gk = gArr[k] * nk;\n      qq += gk;\n    }\n\n    nk /= n23;\n  }\n\n  fk = cbtwo * ai * pp / cbn + Math.cbrt(4.0) * aip * qq / n;\n  return fk;\n}\n\nexports.jnt = jnt;\n},{\"../airy.js\":49,\"../polevl.js\":78}],72:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.jnx = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _airy3 = require('../airy.js');\n\nvar _polevl = require('../polevl.js');\n\nvar _jnt = require('./jnt.js');\n\nvar _constants = require('../constants.js');\n\nvar constants = _interopRequireWildcard(_constants);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/* Asymptotic expansion for large n.\n* AMS55 #9.3.35.\n*/\nvar lambda = [1.0, 1.041666666666666666666667E-1, 8.355034722222222222222222E-2, 1.282265745563271604938272E-1, 2.918490264641404642489712E-1, 8.816272674437576524187671E-1, 3.321408281862767544702647E+0, 1.499576298686255465867237E+1, 7.892301301158651813848139E+1, 4.744515388682643231611949E+2, 3.207490090890661934704328E+3];\n\nvar mu = [1.0, -1.458333333333333333333333E-1, -9.874131944444444444444444E-2, -1.433120539158950617283951E-1, -3.172272026784135480967078E-1, -9.424291479571202491373028E-1, -3.511203040826354261542798E+0, -1.572726362036804512982712E+1, -8.228143909718594444224656E+1, -4.923553705236705240352022E+2, -3.316218568547972508762102E+3];\n\nvar P1 = [-2.083333333333333333333333E-1, 1.250000000000000000000000E-1];\n\nvar P2 = [3.342013888888888888888889E-1, -4.010416666666666666666667E-1, 7.031250000000000000000000E-2];\n\nvar P3 = [-1.025812596450617283950617E+0, 1.846462673611111111111111E+0, -8.912109375000000000000000E-1, 7.324218750000000000000000E-2];\n\nvar P4 = [4.669584423426247427983539E+0, -1.120700261622299382716049E+1, 8.789123535156250000000000E+0, -2.364086914062500000000000E+0, 1.121520996093750000000000E-1];\n\nvar P5 = [-2.8212072558200244877E1, 8.4636217674600734632E1, -9.1818241543240017361E1, 4.2534998745388454861E1, -7.3687943594796316964E0, 2.27108001708984375E-1];\n\nvar P6 = [2.1257013003921712286E2, -7.6525246814118164230E2, 1.0599904525279998779E3, -6.9957962737613254123E2, 2.1819051174421159048E2, -2.6491430486951555525E1, 5.7250142097473144531E-1];\n\nvar P7 = [-1.9194576623184069963E3, 8.0617221817373093845E3, -1.3586550006434137439E4, 1.1655393336864533248E4, -5.3056469786134031084E3, 1.2009029132163524628E3, -1.0809091978839465550E2, 1.7277275025844573975E0];\n\nfunction jnx(n, x) {\n  var zeta = void 0,\n      sqz = void 0,\n      zz = void 0,\n      zp = void 0,\n      np = void 0,\n      cbn = void 0,\n      n23 = void 0,\n      t = void 0,\n      z = void 0,\n      sz = void 0,\n      pp = void 0,\n      qq = void 0,\n      z32i = void 0,\n      zzi = void 0,\n      ak = void 0,\n      bk = void 0,\n      akl = void 0,\n      bkl = void 0,\n      sign = void 0,\n      doa = void 0,\n      dob = void 0,\n      nflg = void 0,\n      k = void 0,\n      s = void 0,\n      tk = void 0,\n      tkp1 = void 0,\n      m = void 0,\n      ai = void 0,\n      aip = void 0,\n      bi = void 0,\n      bip = void 0,\n      uArr = void 0;\n  uArr = new Float64Array(8);\n\n  /* Test for x very close to n. Use expansion for transition region if so. */\n  cbn = Math.cbrt(n);\n  z = (x - n) / cbn;\n  if (Math.abs(z) <= 0.7) return (0, _jnt.jnt)(n, x);\n\n  z = x / n;\n  zz = 1.0 - z * z;\n  if (zz === 0.0) return 0.0;\n\n  if (zz > 0.0) {\n    sz = Math.sqrt(zz);\n    t = 1.5 * (Math.log((1.0 + sz) / z) - sz); /* zeta ** 3/2          */\n    zeta = Math.cbrt(t * t);\n    nflg = 1;\n  } else {\n    sz = Math.sqrt(-zz);\n    t = 1.5 * (sz - Math.acos(1.0 / z));\n    zeta = -Math.cbrt(t * t);\n    nflg = -1;\n  }\n  z32i = Math.abs(1.0 / t);\n  sqz = Math.cbrt(t);\n\n  /* Airy function */\n  n23 = Math.cbrt(n * n);\n  t = n23 * zeta;\n\n  /* polynomials in expansion */\n  var _airy = (0, _airy3.airy)(t, ai, aip, bi, bip);\n\n  var _airy2 = _slicedToArray(_airy, 4);\n\n  ai = _airy2[0];\n  aip = _airy2[1];\n  bi = _airy2[2];\n  bip = _airy2[3];\n  uArr[0] = 1.0;\n  zzi = 1.0 / zz;\n  uArr[1] = (0, _polevl.polevl)(zzi, P1, 1) / sz;\n  uArr[2] = (0, _polevl.polevl)(zzi, P2, 2) / zz;\n  uArr[3] = (0, _polevl.polevl)(zzi, P3, 3) / (sz * zz);\n  pp = zz * zz;\n  uArr[4] = (0, _polevl.polevl)(zzi, P4, 4) / pp;\n  uArr[5] = (0, _polevl.polevl)(zzi, P5, 5) / (pp * sz);\n  pp *= zz;\n  uArr[6] = (0, _polevl.polevl)(zzi, P6, 6) / pp;\n  uArr[7] = (0, _polevl.polevl)(zzi, P7, 7) / (pp * sz);\n\n  pp = 0.0;\n  qq = 0.0;\n  np = 1.0;\n  /* flags to stop when terms get larger */\n  doa = 1;\n  dob = 1;\n  akl = Infinity;\n  bkl = Infinity;\n\n  for (k = 0; k <= 3; k++) {\n    tk = 2 * k;\n    tkp1 = tk + 1;\n    zp = 1.0;\n    ak = 0.0;\n    bk = 0.0;\n    for (s = 0; s <= tk; s++) {\n      if (doa) {\n        if ((s & 3) > 1) sign = nflg;else sign = 1;\n        ak += sign * mu[s] * zp * uArr[tk - s];\n      }\n\n      if (dob) {\n        m = tkp1 - s;\n        if ((m + 1 & 3) > 1) sign = nflg;else sign = 1;\n        bk += sign * lambda[s] * zp * uArr[m];\n      }\n      zp *= z32i;\n    }\n\n    if (doa) {\n      ak *= np;\n      t = Math.abs(ak);\n      if (t < akl) {\n        akl = t;\n        pp += ak;\n      } else {\n        doa = 0;\n      }\n    }\n\n    if (dob) {\n      bk += lambda[tkp1] * zp * uArr[0];\n      bk *= -np / sqz;\n      t = Math.abs(bk);\n      if (t < bkl) {\n        bkl = t;\n        qq += bk;\n      } else {\n        dob = 0;\n      }\n    }\n\n    if (np < constants.MACHEP) break;\n    np /= n * n;\n  }\n\n  /* normalizing factor ( 4*zeta/(1 - z**2) )**1/4    */\n  t = 4.0 * zeta / zz;\n  t = Math.sqrt(Math.sqrt(t));\n\n  t *= ai * pp / Math.cbrt(n) + aip * qq / (n23 * n);\n  return t;\n}\n\nexports.jnx = jnx;\n},{\"../airy.js\":49,\"../constants.js\":51,\"../polevl.js\":78,\"./jnt.js\":71}],73:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.jvs = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _constants = require('../constants.js');\n\nvar constants = _interopRequireWildcard(_constants);\n\nvar _pythonHelpers = require('../../../utils/pythonHelpers.js');\n\nvar py = _interopRequireWildcard(_pythonHelpers);\n\nvar _gamma = require('../gamma.js');\n\nvar _lgam = require('../gamma/lgam.js');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/* Ascending power series for Jv(x).\n* AMS55 #9.1.10.\n*/\nfunction jvs(n, x) {\n  var t = void 0,\n      u = void 0,\n      y = void 0,\n      z = void 0,\n      k = void 0,\n      ex = void 0,\n      sgngam = void 0,\n      res = void 0;\n\n  z = -x * x / 4.0;\n  u = 1.0;\n  y = u;\n  k = 1.0;\n  t = 1.0;\n\n  while (t > constants.MACHEP) {\n    u *= z / (k * (n + k));\n    y += u;\n    k += 1.0;\n    if (y !== 0) t = Math.abs(u / y);\n  }\n\n  var _py$frexp = py.frexp(0.5 * x);\n\n  var _py$frexp2 = _slicedToArray(_py$frexp, 2);\n\n  t = _py$frexp2[0];\n  ex = _py$frexp2[1];\n\n  ex = ex * n;\n  if (ex > -1023 && ex < 1023 && n > 0.0 && n < constants.MAXGAM - 1.0) {\n    t = Math.pow(0.5 * x, n) / (0, _gamma.gamma)(n + 1.0);\n    y *= t;\n  } else {\n    var _lgamSgn = (0, _lgam.lgamSgn)(n + 1.0);\n\n    var _lgamSgn2 = _slicedToArray(_lgamSgn, 2);\n\n    res = _lgamSgn2[0];\n    sgngam = _lgamSgn2[1];\n\n    t = n * Math.log(0.5 * x) - res;\n    if (y < 0) {\n      sgngam = -sgngam;\n      y = -y;\n    }\n    t += Math.log(y);\n    if (t < -constants.MAXLOG) {\n      return 0.0;\n    }\n    if (t > constants.MAXLOG) {\n      // mtherr(\"Jv\", OVERFLOW);\n      return Infinity;\n    }\n    y = sgngam * Math.exp(t);\n  }\n  return y;\n}\n\nexports.jvs = jvs;\n},{\"../../../utils/pythonHelpers.js\":94,\"../constants.js\":51,\"../gamma.js\":55,\"../gamma/lgam.js\":56}],74:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.recur = undefined;\n\nvar _constants = require('../constants.js');\n\nvar constants = _interopRequireWildcard(_constants);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/* Reduce the order by backward recurrence.\n* AMS55 #9.1.27 and 9.1.73.\n*/\nfunction recur(n, x, newn, cancel) {\n  var pkm2 = void 0,\n      pkm1 = void 0,\n      pk = void 0,\n      qkm2 = void 0,\n      qkm1 = void 0,\n      k = void 0,\n      ans = void 0,\n      qk = void 0,\n      xk = void 0,\n      yk = void 0,\n      r = void 0,\n      t = void 0,\n      kf = void 0,\n      nflag = void 0,\n      ctr = void 0,\n      miniter = void 0,\n      maxiter = void 0;\n\n  /* Continued fraction for Jn(x)/Jn-1(x)\n  * AMS 9.1.73\n  *\n  *    x       -x^2      -x^2\n  * ------  ---------  ---------   ...\n  * 2 n +   2(n+1) +   2(n+2) +\n  *\n  * Compute it with the simplest possible algorithm.\n  *\n  * This continued fraction starts to converge when (|n| + m) > |x|.\n  * Hence, at least |x|-|n| iterations are necessary before convergence is\n  * achieved. There is a hard limit set below, m <= 30000, which is chosen\n  * so that no branch in `jv` requires more iterations to converge.\n  * The exact maximum number is (500/3.6)^2 - 500 ~ 19000\n  */\n  var BIG = 1.44115188075855872E+17;\n  maxiter = 22000;\n  miniter = Math.abs(x) - Math.abs(n);\n  if (miniter < 1) miniter = 1;\n  if (n < 0.0) nflag = 1;else nflag = 0;\n\n  var goToLabel = 'fstart';\n  mainExecutionLoop: while (true) {\n    innerSwitch: switch (goToLabel) {\n      case 'fstart':\n        pkm2 = 0.0;\n        qkm2 = 1.0;\n        pkm1 = x;\n        qkm1 = 2 * n;\n        xk = -x * x;\n        yk = qkm1;\n        ans = 0.0; /* ans=0.0 ensures that t=1.0 in the first iteration */\n        ctr = 0;\n        do {\n          yk += 2.0;\n          pk = pkm1 * yk + pkm2 * xk;\n          qk = qkm1 * yk + qkm2 * xk;\n          pkm2 = pkm1;\n          pkm1 = pk;\n          qkm2 = qkm1;\n          qkm1 = qk;\n\n          /* check convergence */\n          if (qk !== 0 && ctr > miniter) r = pk / qk;else r = 0.0;\n\n          if (r !== 0) {\n            t = Math.abs((ans - r) / r);\n            ans = r;\n          } else {\n            t = 1.0;\n          }\n\n          if (++ctr > maxiter) {\n            // mtherr(\"jv\", UNDERFLOW);\n            goToLabel = 'done';break innerSwitch;\n          }\n          if (t < constants.MACHEP) {\n            goToLabel = 'done';break innerSwitch;\n          }\n\n          /* renormalize coefficients */\n          if (Math.abs(pk) > BIG) {\n            pkm2 /= BIG;\n            pkm1 /= BIG;\n            qkm2 /= BIG;\n            qkm1 /= BIG;\n          }\n        } while (t > constants.MACHEP);\n\n      case 'done':\n        if (ans === 0) ans = 1.0;\n\n        /* Change n to n-1 if n < 0 and the continued fraction is small */\n        if (nflag > 0) {\n          if (Math.abs(ans) < 0.125) {\n            nflag = -1;\n            n--;\n            goToLabel = 'fstart';break;\n          }\n        }\n\n        kf = newn;\n\n        /* backward recurrence\n        *              2k\n        *  J   (x)  =  --- J (x)  -  J   (x)\n        *   k-1         x   k         k+1\n        */\n\n        pk = 1.0;\n        pkm1 = 1.0 / ans;\n        k = n - 1.0;\n        r = 2 * k;\n        do {\n          pkm2 = (pkm1 * r - pk * x) / x;\n          /*      pkp1 = pk; */\n          pk = pkm1;\n          pkm1 = pkm2;\n          r -= 2.0;\n          /*\n          * t = Math.abs(pkp1) + Math.abs(pk);\n          * if( (k > (kf + 2.5)) && (Math.abs(pkm1) < 0.25*t) )\n          * {\n          * k -= 1.0;\n          * t = x*x;\n          * pkm2 = ( (r*(r+2.0)-t)*pk - r*x*pkp1 )/t;\n          * pkp1 = pk;\n          * pk = pkm1;\n          * pkm1 = pkm2;\n          * r -= 2.0;\n          * }\n          */\n          k -= 1.0;\n        } while (k > kf + 0.5);\n\n        /* Take the larger of the last two iterates\n        * on the theory that it may have less cancellation error.\n        */\n\n        if (cancel) {\n          if (kf >= 0.0 && Math.abs(pk) > Math.abs(pkm1)) {\n            k += 1.0;\n            pkm2 = pk;\n          }\n        }\n        newn = k;\n      default:\n        break mainExecutionLoop;\n    }\n  }\n  return [pkm2, n, newn];\n} /* eslint-disable no-labels */\n/* eslint-disable no-fallthrough */\nexports.recur = recur;\n},{\"../constants.js\":51}],75:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.k0e = exports.k0 = undefined;\n\nvar _chbevl = require('./chbevl.js');\n\nvar _i = require('./i0.js');\n\n/**\n * @file        k0.js         Modified Bessel function, third kind, order zero\n *\n *\n *\n * SYNOPSIS:\n *\n * double x, y, k0();\n *\n * y = k0( x );\n *\n *\n *\n * DESCRIPTION:\n *\n * Returns modified Bessel function of the third kind\n * of order zero of the argument.\n *\n * The range is partitioned into the two intervals [0,8] and\n * (8, infinity).  Chebyshev polynomial expansions are employed\n * in each interval.\n *\n *\n *\n * ACCURACY:\n *\n * Tested at 2000 random points between 0 and 8.  Peak absolute\n * error (relative when K0 > 1) was 1.46e-14; rms, 4.26e-15.\n *                      Relative error:\n * arithmetic   domain     # trials      peak         rms\n *    IEEE      0, 30       30000       1.2e-15     1.6e-16\n *\n * ERROR MESSAGES:\n *\n *   message         condition      value returned\n *  K0 domain          x <= 0          NPY_INFINITY\n *\n *\n *  Modified Bessel function, third kind, order zero,\n *  exponentially scaled\n *\n *\n *\n * SYNOPSIS:\n *\n * double x, y, k0e();\n *\n * y = k0e( x );\n *\n *\n *\n * DESCRIPTION:\n *\n * Returns exponentially scaled modified Bessel function\n * of the third kind of order zero of the argument.\n *\n *\n *\n * ACCURACY:\n *\n *                      Relative error:\n * arithmetic   domain     # trials      peak         rms\n *    IEEE      0, 30       30000       1.4e-15     1.4e-16\n * See k0().\n *\n * Cephes Math Library Release 2.8:  June, 2000\n * Copyright 1984, 1987, 2000 by Stephen L. Moshier\n * Ported to ECMAScript 2018\n * Copyright (c) 2018, Kings Distributed Systems\n *\n * @author      KC Erb, kc@kcerb.com\n * @date        April 2018\n */\nvar A = [1.37446543561352307156E-16, 4.25981614279661018399E-14, 1.03496952576338420167E-11, 1.90451637722020886025E-9, 2.53479107902614945675E-7, 2.28621210311945178607E-5, 1.26461541144692592338E-3, 3.59799365153615016266E-2, 3.44289899924628486886E-1, -5.35327393233902768720E-1];\n\n/* Chebyshev coefficients for exp(x) sqrt(x) K0(x)\n * in the inverted interval [2,infinity].\n *\n * lim(x->inf){ exp(x) sqrt(x) K0(x) } = sqrt(pi/2).\n */\nvar B = [5.30043377268626276149E-18, -1.64758043015242134646E-17, 5.21039150503902756861E-17, -1.67823109680541210385E-16, 5.51205597852431940784E-16, -1.84859337734377901440E-15, 6.34007647740507060557E-15, -2.22751332699166985548E-14, 8.03289077536357521100E-14, -2.98009692317273043925E-13, 1.14034058820847496303E-12, -4.51459788337394416547E-12, 1.85594911495471785253E-11, -7.95748924447710747776E-11, 3.57739728140030116597E-10, -1.69753450938905987466E-9, 8.57403401741422608519E-9, -4.66048989768794782956E-8, 2.76681363944501510342E-7, -1.83175552271911948767E-6, 1.39498137188764993662E-5, -1.28495495816278026384E-4, 1.56988388573005337491E-3, -3.14481013119645005427E-2, 2.44030308206595545468E0];\n\nfunction k0(x) {\n  var y = void 0,\n      z = void 0;\n\n  if (x === 0.0) {\n    // mtherr(\"k0\", SING);\n    return Infinity;\n  } else if (x < 0.0) {\n    // mtherr(\"k0\", DOMAIN);\n    return NaN;\n  }\n\n  if (x <= 2.0) {\n    y = x * x - 2.0;\n    y = (0, _chbevl.chbevl)(y, A, 10) - Math.log(0.5 * x) * (0, _i.i0)(x);\n    return y;\n  }\n  z = 8.0 / x - 2.0;\n  y = Math.exp(-x) * (0, _chbevl.chbevl)(z, B, 25) / Math.sqrt(x);\n  return y;\n}\n\nfunction k0e(x) {\n  var y = void 0;\n\n  if (x === 0.0) {\n    // mtherr(\"k0e\", SING);\n    return Infinity;\n  } else if (x < 0.0) {\n    // mtherr(\"k0e\", DOMAIN);\n    return NaN;\n  }\n\n  if (x <= 2.0) {\n    y = x * x - 2.0;\n    y = (0, _chbevl.chbevl)(y, A, 10) - Math.log(0.5 * x) * (0, _i.i0)(x);\n    return y * Math.exp(x);\n  }\n\n  y = (0, _chbevl.chbevl)(8.0 / x - 2.0, B, 25) / Math.sqrt(x);\n  return y;\n}\n\nexports.k0 = k0;\nexports.k0e = k0e;\n},{\"./chbevl.js\":50,\"./i0.js\":62}],76:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.k1e = exports.k1 = undefined;\n\nvar _chbevl = require('./chbevl.js');\n\nvar _i = require('./i1.js');\n\n/**\n * @file     k1.js         Modified Bessel function, third kind, order one\n *\n *\n *\n * SYNOPSIS:\n *\n * double x, y, k1();\n *\n * y = k1( x );\n *\n *\n *\n * DESCRIPTION:\n *\n * Computes the modified Bessel function of the third kind\n * of order one of the argument.\n *\n * The range is partitioned into the two intervals [0,2] and\n * (2, infinity).  Chebyshev polynomial expansions are employed\n * in each interval.\n *\n *\n *\n * ACCURACY:\n *\n *                      Relative error:\n * arithmetic   domain     # trials      peak         rms\n *    IEEE      0, 30       30000       1.2e-15     1.6e-16\n *\n * ERROR MESSAGES:\n *\n *   message         condition      value returned\n * k1 domain          x <= 0          NPY_INFINITY\n *\n *\n *  Modified Bessel function, third kind, order one,\n *  exponentially scaled\n *\n *\n *\n * SYNOPSIS:\n *\n * double x, y, k1e();\n *\n * y = k1e( x );\n *\n *\n *\n * DESCRIPTION:\n *\n * Returns exponentially scaled modified Bessel function\n * of the third kind of order one of the argument:\n *\n *      k1e(x) = exp(x) * k1(x).\n *\n *\n *\n * ACCURACY:\n *\n *                      Relative error:\n * arithmetic   domain     # trials      peak         rms\n *    IEEE      0, 30       30000       7.8e-16     1.2e-16\n * See k1().\n *\n * Cephes Math Library Release 2.8:  June, 2000\n * Copyright 1984, 1987, 2000 by Stephen L. Moshier\n * Ported to ECMAScript 2018\n * Copyright (c) 2018, Kings Distributed Systems\n *\n * @author      KC Erb, kc@kcerb.com\n * @date        April 2018\n */\nvar A = [-7.02386347938628759343E-18, -2.42744985051936593393E-15, -6.66690169419932900609E-13, -1.41148839263352776110E-10, -2.21338763073472585583E-8, -2.43340614156596823496E-6, -1.73028895751305206302E-4, -6.97572385963986435018E-3, -1.22611180822657148235E-1, -3.53155960776544875667E-1, 1.52530022733894777053E0];\n\n/* Chebyshev coefficients for exp(x) sqrt(x) K1(x)\n* in the interval [2,infinity].\n*\n* lim(x->inf){ exp(x) sqrt(x) K1(x) } = sqrt(pi/2).\n*/\nvar B = [-5.75674448366501715755E-18, 1.79405087314755922667E-17, -5.68946255844285935196E-17, 1.83809354436663880070E-16, -6.05704724837331885336E-16, 2.03870316562433424052E-15, -7.01983709041831346144E-15, 2.47715442448130437068E-14, -8.97670518232499435011E-14, 3.34841966607842919884E-13, -1.28917396095102890680E-12, 5.13963967348173025100E-12, -2.12996783842756842877E-11, 9.21831518760500529508E-11, -4.19035475934189648750E-10, 2.01504975519703286596E-9, -1.03457624656780970260E-8, 5.74108412545004946722E-8, -3.50196060308781257119E-7, 2.40648494783721712015E-6, -1.93619797416608296024E-5, 1.95215518471351631108E-4, -2.85781685962277938680E-3, 1.03923736576817238437E-1, 2.72062619048444266945E0];\n\nfunction k1(x) {\n  var y = void 0,\n      z = void 0;\n\n  if (x === 0.0) {\n    // mtherr(\"k1\", SING);\n    return Infinity;\n  } else if (x < 0.0) {\n    // mtherr(\"k1\", DOMAIN);\n    return NaN;\n  }\n  z = 0.5 * x;\n\n  if (x <= 2.0) {\n    y = x * x - 2.0;\n    y = Math.log(z) * (0, _i.i1)(x) + (0, _chbevl.chbevl)(y, A, 11) / x;\n    return y;\n  }\n\n  return Math.exp(-x) * (0, _chbevl.chbevl)(8.0 / x - 2.0, B, 25) / Math.sqrt(x);\n}\n\nfunction k1e(x) {\n  var y = void 0;\n\n  if (x === 0.0) {\n    // mtherr(\"k1e\", SING);\n    return Infinity;\n  } else if (x < 0.0) {\n    // mtherr(\"k1e\", DOMAIN);\n    return NaN;\n  }\n\n  if (x <= 2.0) {\n    y = x * x - 2.0;\n    y = Math.log(0.5 * x) * (0, _i.i1)(x) + (0, _chbevl.chbevl)(y, A, 11) / x;\n    return y * Math.exp(x);\n  }\n\n  return (0, _chbevl.chbevl)(8.0 / x - 2.0, B, 25) / Math.sqrt(x);\n}\n\nexports.k1 = k1;\nexports.k1e = k1e;\n},{\"./chbevl.js\":50,\"./i1.js\":63}],77:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.kn = undefined;\n\nvar _constants = require('./constants.js');\n\nvar constants = _interopRequireWildcard(_constants);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar EUL = 5.772156649015328606065e-1; /**\n                                       * @file     kn.js         Modified Bessel function, third kind, integer order\n                                       *\n                                       *\n                                       *\n                                       * SYNOPSIS:\n                                       *\n                                       * double x, y, kn();\n                                       * int n;\n                                       *\n                                       * y = kn( n, x );\n                                       *\n                                       *\n                                       *\n                                       * DESCRIPTION:\n                                       *\n                                       * Returns modified Bessel function of the third kind\n                                       * of order n of the argument.\n                                       *\n                                       * The range is partitioned into the two intervals [0,9.55] and\n                                       * (9.55, infinity).  An ascending power series is used in the\n                                       * low range, and an asymptotic expansion in the high range.\n                                       *\n                                       *\n                                       *\n                                       * ACCURACY:\n                                       *\n                                       *                      Relative error:\n                                       * arithmetic   domain     # trials      peak         rms\n                                       *    IEEE      0,30        90000       1.8e-8      3.0e-10\n                                       *\n                                       *  Error is high only near the crossover point x = 9.55\n                                       * between the two expansions used.\n                                       *\n                                       * Cephes Math Library Release 2.8:  June, 2000\n                                       * Copyright 1984, 1987, 1988, 2000 by Stephen L. Moshier\n                                       * Ported to ECMAScript 2018\n                                       * Copyright (c) 2018, Kings Distributed Systems\n                                       *\n                                       * @author      KC Erb, kc@kcerb.com\n                                       * @date        April 2018\n                                       */\n\n/*\n * Algorithm for Kn.\n *                        n-1\n *                    -n   -  (n-k-1)!    2   k\n * K (x)  =  0.5 (x/2)     >  -------- (-x /4)\n *  n                      -     k!\n *                        k=0\n *\n *                     inf.                                   2   k\n *        n         n   -                                   (x /4)\n *  + (-1)  0.5(x/2)    >  {p(k+1) + p(n+k+1) - 2log(x/2)} ---------\n *                      -                                  k! (n+k)!\n *                     k=0\n *\n * where  p(m) is the psi function: p(1) = -EUL and\n *\n *                       m-1\n *                        -\n *       p(m)  =  -EUL +  >  1/k\n *                        -\n *                       k=1\n *\n * For large x,\n *                                          2        2     2\n *                                       u-1     (u-1 )(u-3 )\n * K (z)  =  sqrt(pi/2z) exp(-z) { 1 + ------- + ------------ + ...}\n *  v                                        1            2\n *                                     1! (8z)     2! (8z)\n * asymptotically, where\n *\n *            2\n *     u = 4 v .\n *\n */\n\nvar MAXFAC = 31;\n\nfunction kn(nn, x) {\n  var k = void 0,\n      kf = void 0,\n      nk1f = void 0,\n      zn = void 0,\n      t = void 0,\n      s = void 0,\n      z0 = void 0,\n      z = void 0,\n      ans = void 0,\n      fn = void 0,\n      pn = void 0,\n      pk = void 0,\n      zmn = void 0,\n      tlg = void 0,\n      tox = void 0,\n      i = void 0,\n      n = void 0;\n\n  if (nn < 0) n = -nn;else n = nn;\n\n  if (n > MAXFAC) {\n    // mtherr(\"kn\", OVERFLOW);\n    return Infinity;\n  }\n\n  if (x <= 0.0) {\n    if (x < 0.0) {\n      // mtherr(\"kn\", DOMAIN);\n      return NaN;\n    } else {\n      // mtherr(\"kn\", SING);\n      return Infinity;\n    }\n  }\n\n  if (x > 9.55) return asymp(x, n);\n\n  ans = 0.0;\n  z0 = 0.25 * x * x;\n  fn = 1.0;\n  pn = 0.0;\n  zmn = 1.0;\n  tox = 2.0 / x;\n\n  if (n > 0) {\n    /* compute factorial of n and psi(n) */\n    pn = -EUL;\n    k = 1.0;\n    for (i = 1; i < n; i++) {\n      pn += 1.0 / k;\n      k += 1.0;\n      fn *= k;\n    }\n\n    zmn = tox;\n\n    if (n === 1) {\n      ans = 1.0 / x;\n    } else {\n      nk1f = fn / n;\n      kf = 1.0;\n      s = nk1f;\n      z = -z0;\n      zn = 1.0;\n      for (i = 1; i < n; i++) {\n        nk1f = nk1f / (n - i);\n        kf = kf * i;\n        zn *= z;\n        t = nk1f * zn / kf;\n        s += t;\n        if (constants.DBL_MAX - Math.abs(t) < Math.abs(s)) {\n          // mtherr(\"kn\", OVERFLOW);\n          return Infinity;\n        }\n        if (tox > 1.0 && constants.DBL_MAX / tox < zmn) {\n          // mtherr(\"kn\", OVERFLOW);\n          return Infinity;\n        }\n        zmn *= tox;\n      }\n      s *= 0.5;\n      t = Math.abs(s);\n      if (zmn > 1.0 && constants.DBL_MAX / zmn < t) {\n        // mtherr(\"kn\", OVERFLOW);\n        return Infinity;\n      }\n      if (t > 1.0 && constants.DBL_MAX / t < zmn) {\n        // mtherr(\"kn\", OVERFLOW);\n        return Infinity;\n      }\n      ans = s * zmn;\n    }\n  }\n\n  tlg = 2.0 * Math.log(0.5 * x);\n  pk = -EUL;\n  if (n === 0) {\n    pn = pk;\n    t = 1.0;\n  } else {\n    pn = pn + 1.0 / n;\n    t = 1.0 / fn;\n  }\n  s = (pk + pn - tlg) * t;\n  k = 1.0;\n  do {\n    t *= z0 / (k * (k + n));\n    pk += 1.0 / k;\n    pn += 1.0 / (k + n);\n    s += (pk + pn - tlg) * t;\n    k += 1.0;\n  } while (Math.abs(t / s) > constants.MACHEP);\n\n  s = 0.5 * s / zmn;\n  if (n & 1) s = -s;\n  ans += s;\n\n  return ans;\n}\n\n/* Asymptotic expansion for Kn(x) */\n/* Converges to 1.4e-17 for x > 18.4 */\nfunction asymp(x, n) {\n  var nkf = void 0,\n      k = void 0,\n      pn = void 0,\n      pk = void 0,\n      z0 = void 0,\n      fn = void 0,\n      t = void 0,\n      s = void 0,\n      i = void 0,\n      z = void 0,\n      nk1f = void 0,\n      ans = void 0;\n  if (x > constants.MAXLOG) {\n    // mtherr(\"kn\", UNDERFLOW);\n    return 0.0;\n  }\n  k = n;\n  pn = 4.0 * k * k;\n  pk = 1.0;\n  z0 = 8.0 * x;\n  fn = 1.0;\n  t = 1.0;\n  s = t;\n  nkf = Infinity;\n  i = 0;\n  do {\n    z = pn - pk * pk;\n    t = t * z / (fn * z0);\n    nk1f = Math.abs(t);\n    if (i >= n && nk1f > nkf) break;\n    nkf = nk1f;\n    s += t;\n    fn += 1.0;\n    pk += 2.0;\n    i += 1;\n  } while (Math.abs(t / s) > constants.MACHEP);\n\n  ans = Math.exp(-x) * Math.sqrt(Math.PI / (2.0 * x)) * s;\n  return ans;\n}\n\nexports.kn = kn;\n},{\"./constants.js\":51}],78:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @file     polevl.js       Evaluate polynomial\n *\n *\n *\n * SYNOPSIS:\n *\n * int N;\n * double x, y, coef[N+1], polevl[];\n *\n * y = polevl( x, coef, N );\n *\n *\n *\n * DESCRIPTION:\n *\n * Evaluates polynomial of degree N:\n *\n *                     2          N\n * y  =  C  + C x + C x  +...+ C x\n *        0    1     2          N\n *\n * Coefficients are stored in reverse order:\n *\n * coef[0] = C  , ..., coef[N] = C  .\n *            N                   0\n *\n *  The function p1evl() assumes that coef[N] = 1.0 and is\n * omitted from the array.  Its calling arguments are\n * otherwise the same as polevl().\n *\n *\n * SPEED:\n *\n * In the interest of speed, there are no checks for out\n * of bounds arithmetic.  This routine is used by most of\n * the functions in the library.  Depending on available\n * equipment features, the user may wish to rewrite the\n * program in microcode or assembly language.\n *\n * Cephes Math Library Release 2.1:  December, 1988\n * Copyright 1984, 1987, 1988 by Stephen L. Moshier\n * Ported to ECMAScript 2018\n * Copyright (c) 2018, Kings Distributed Systems\n *\n * @author      KC Erb, kc@kcerb.com\n * @date        April 2018\n */\nfunction polevl(x, coef, n) {\n  var ans = void 0,\n      i = void 0;\n  ans = coef[0];\n  for (i = 1; i <= n; i++) {\n    ans = ans * x + coef[i];\n  }\n\n  return ans;\n}\n\nfunction p1evl(x, coef, n) {\n  var ans = void 0,\n      i = void 0;\n\n  ans = x + coef[0];\n\n  for (i = 1; i < n; i++) {\n    ans = ans * x + coef[i];\n  }\n\n  return ans;\n};\n\n// TODO: ratevl\n\nexports.polevl = polevl;\nexports.p1evl = p1evl;\n},{}],79:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.psi = undefined;\n\nvar _polevl = require('./polevl.js');\n\n// Psi (digamma) function\nfunction psi(x) {\n  var q = void 0,\n      p = void 0;\n  var A = new Float64Array([8.33333333333333333333E-2, -8.33333333333333333333E-3, 3.96825396825396825397E-3, -4.16666666666666666667E-3, 7.57575757575757575758E-3, -2.10927960927960927961E-2, 8.33333333333333333333E-2]);\n\n  var negative = 0;\n  var nz = 0.0;\n  var y = void 0;\n\n  if (x <= 0.0) {\n    negative = 1;\n    q = x;\n    p = Math.floor(q);\n    if (p === q) {\n      // mtherr(\"psi\", SING);\n      return Infinity;\n    }\n    // Remove the zeros of tan(PI x)\n    // by subtracting the nearest integer from x\n    nz = q - p;\n    if (nz !== 0.5) {\n      if (nz > 0.5) {\n        p += 1.0;\n        nz = q - p;\n      }\n      nz = Math.PI / Math.tan(Math.PI * nz);\n    } else {\n      nz = 0.0;\n    }\n    x = 1.0 - x;\n  }\n\n  // check for positive integer up to 10\n  if (x <= 10.0 && x === Math.floor(x)) {\n    y = 0.0;\n    var n = x;\n    for (var i = 1; i < n; i++) {\n      var _w = i;\n      y += 1.0 / _w;\n    }\n    y -= Math.E;\n    return done(negative, y, nz);\n  }\n\n  var s = x;\n  var w = 0.0;\n  while (s < 10.0) {\n    w += 1.0 / s;\n    s += 1.0;\n  }\n\n  if (s < 1.0e17) {\n    var z = 1.0 / (s * s);\n    y = z * (0, _polevl.polevl)(z, A, 6);\n  } else {\n    y = 0.0;\n  }\n\n  y = Math.log(s) - 0.5 / s - y - w;\n\n  return done(negative, y, nz);\n} /**\n   * @file     psi.js  Psi (digamma) function\n   *\n   *\n   * SYNOPSIS:\n   *\n   * double x, y, psi();\n   *\n   * y = psi( x );\n   *\n   *\n   * DESCRIPTION:\n   *\n   *              d      -\n   *   psi(x)  =  -- ln | (x)\n   *              dx\n   *\n   * is the logarithmic derivative of the gamma function.\n   * For integer x,\n   *                   n-1\n   *                    -\n   * psi(n) = -EUL  +   >  1/k.\n   *                    -\n   *                   k=1\n   *\n   * This formula is used for 0 < n <= 10.  If x is negative, it\n   * is transformed to a positive argument by the reflection\n   * formula  psi(1-x) = psi(x) + pi cot(pi x).\n   * For general positive x, the argument is made greater than 10\n   * using the recurrence  psi(x+1) = psi(x) + 1/x.\n   * Then the following asymptotic expansion is applied:\n   *\n   *                           inf.   B\n   *                            -      2k\n   * psi(x) = log(x) - 1/2x -   >   -------\n   *                            -        2k\n   *                           k=1   2k x\n   *\n   * where the B2k are Bernoulli numbers.\n   *\n   * ACCURACY:\n   *    Relative error (except absolute when |psi| < 1):\n   * arithmetic   domain     # trials      peak         rms\n   *    IEEE      0,30        30000       1.3e-15     1.4e-16\n   *    IEEE      -30,0       40000       1.5e-15     2.2e-16\n   *\n   * ERROR MESSAGES:\n   *     message         condition      value returned\n   * psi singularity    x integer <=0      NPY_INFINITY\n   *\n   * Cephes Math Library Release 2.8:  June, 2000\n   * Copyright 1984, 1987, 1992, 2000 by Stephen L. Moshier\n   *\n   * Code for the rational approximation on [1, 2] is:\n   *\n   * (C) Copyright John Maddock 2006.\n   * Use, modification and distribution are subject to the\n   * Boost Software License, Version 1.0. (See accompanying file\n   * LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n   *\n   * Ported to ECMAScript 2018\n   * Copyright (c) 2018, Kings Distributed Systems\n   *\n   * @author      KC Erb, kc@kcerb.com\n   * @date        April 2018\n   */\n;\n\nfunction done(negative, y, nz) {\n  if (negative) {\n    y -= nz;\n  }\n  return y;\n};\n\nexports.psi = psi;\n},{\"./polevl.js\":78}],80:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.yn = undefined;\n\nvar _j = require('./j0.js');\n\nvar _j2 = require('./j1.js');\n\n/**\n * @file     yn.js    Bessel function of second kind of integer order\n *\n *\n *\n *\n * SYNOPSIS:\n *\n * double x, y, yn();\n * int n;\n *\n * y = yn( n, x );\n *\n *\n *\n * DESCRIPTION:\n *\n * Returns Bessel function of order n, where n is a\n * (possibly negative) integer.\n *\n * The function is evaluated by forward recurrence on\n * n, starting with values computed by the routines\n * y0() and y1().\n *\n * If n = 0 or 1 the routine for y0 or y1 is called\n * directly.\n *\n *\n *\n * ACCURACY:\n *\n *\n *                      Absolute error, except relative\n *                      when y > 1:\n * arithmetic   domain     # trials      peak         rms\n *    IEEE      0, 30       30000       3.4e-15     4.3e-16\n *\n *\n * ERROR MESSAGES:\n *\n *   message         condition      value returned\n * yn singularity   x = 0              NPY_INFINITY\n * yn overflow                         NPY_INFINITY\n *\n * Spot checked against tables for x, n between 0 and 100.\n *\n *\n * Cephes Math Library Release 2.8:  June, 2000\n * Copyright 1984, 1987, 2000 by Stephen L. Moshier\n * Ported to ECMAScript 2018\n * Copyright (c) 2018, Kings Distributed Systems\n *\n * @author      KC Erb, kc@kcerb.com\n * @date        April 2018\n */\n\nfunction yn(n, x) {\n  var an = void 0,\n      anm1 = void 0,\n      anm2 = void 0,\n      r = void 0,\n      k = void 0,\n      sign = void 0;\n\n  if (n < 0) {\n    n = -n;\n    /* -1**n */\n    if ((n & 1) === 0) {\n      sign = 1;\n    } else {\n      sign = -1;\n    }\n  } else {\n    sign = 1;\n  }\n\n  if (n === 0) {\n    return sign * (0, _j.y0)(x);\n  }\n  if (n === 1) {\n    return sign * (0, _j2.y1)(x);\n  }\n\n  /* test for overflow */\n  if (x === 0.0) {\n    // mtherr('yn', SING);\n    return -Infinity * sign;\n  } else if (x < 0.0) {\n    // mtherr('yn', DOMAIN);\n    return NaN;\n  }\n\n  /* forward recurrence on n */\n  anm2 = (0, _j.y0)(x);\n  anm1 = (0, _j2.y1)(x);\n  k = 1;\n  r = 2 * k;\n  do {\n    an = r * anm1 / x - anm2;\n    anm2 = anm1;\n    anm1 = an;\n    r += 2.0;\n    ++k;\n  } while (k < n);\n\n  return sign * an;\n}\n\nexports.yn = yn;\n},{\"./j0.js\":67,\"./j1.js\":68}],81:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.yv = undefined;\n\nvar _jv = require('./jv.js');\n\nvar _yn = require('./yn.js');\n\n/**\n * @file     yv.js    Bessel function of second kind of non-integer order\n *\n * Cephes Math Library Release 2.8: June, 2000\n * Copyright 1984, 1987, 2000 by Stephen L. Moshier\n * Ported to ECMAScript 2018\n * Copyright (c) 2018, Kings Distributed Systems\n *\n * @author      KC Erb, kc@kcerb.com\n * @date        April 2018\n */\nfunction yv(v, x) {\n  var y = void 0,\n      t = void 0,\n      n = void 0;\n  n = Math.trunc(v);\n  if (n === v) {\n    y = (0, _yn.yn)(n, x);\n    return y;\n  } else if (v === Math.floor(v)) {\n    /* Zero in denominator. */\n    // mtherr('yv', DOMAIN);\n    return NaN;\n  }\n\n  t = Math.PI * v;\n  y = (Math.cos(t) * (0, _jv.jv)(v, x) - (0, _jv.jv)(-v, x)) / Math.sin(t);\n\n  if (!isFinite(y)) {\n    if (v > 0) {\n      // mtherr('yv', OVERFLOW);\n      return -Infinity;\n    } else if (v < -1e10) {\n      /* Whether it's +inf or -inf is numerically ill-defined. */\n      // mtherr('yv', DOMAIN);\n      return NaN;\n    }\n  }\n\n  return y;\n}\n\nexports.yv = yv;\n},{\"./jv.js\":69,\"./yn.js\":80}],82:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Chebyshev = function () {\n  function Chebyshev() {\n    _classCallCheck(this, Chebyshev);\n  }\n\n  _createClass(Chebyshev, null, [{\n    key: 'tn',\n\n    // SOURCE: https://en.wikipedia.org/wiki/Chebyshev_polynomials#Explicit_expressions\n    // TODO: the following only accepts integer `n`s -\n    //       Make continuous via the Gauss hypergeometric function\n    // https://github.com/scipy/scipy/blob/master/scipy/special/cephes/hyp2f1.c\n    value: function tn(n, viewX, x, viewR, r) {\n      var arg = void 0;\n      switch (true) {\n        case Math.abs(viewX[x]) <= 1:\n          arg = n * Math.acos(viewX[x]);\n          viewR[r] = Math.cos(arg);\n          break;\n        case viewX[x] > 1:\n          arg = n * Math.acosh(viewX[x]);\n          viewR[r] = Math.cosh(arg);\n          break;\n        default:\n          var sign = Math.pow(-1, n);\n          arg = n * Math.acosh(-viewX[x]);\n          viewR[r] = sign * Math.cosh(arg);\n      }\n    }\n\n    // SOURCE: https://en.wikipedia.org/wiki/Chebyshev_polynomials#Explicit_expressions\n    // TODO: same as tn\n\n  }, {\n    key: 'un',\n    value: function un(n, viewX, x, viewR, r) {\n      switch (true) {\n        case Math.abs(viewX[x]) > 1:\n          var rad = Math.sqrt(viewX[x] * viewX[x] - 1);\n          var numerator = Math.pow(viewX[x] + rad, n + 1) - Math.pow(viewX[x] - rad, n + 1);\n          var denominator = 2 * rad;\n          viewR[r] = numerator / denominator;\n          break;\n        case Math.abs(viewX[x]) <= 1:\n          // TODO, implement as hypergeometric to cover all ranges\n          break;\n        default:\n      }\n    }\n\n    // Approximate the function `func` in the interval [a, b] with\n    // an order-n Chebyshev polynomial (T).\n    // f  c_k T_k(y) - c_0/2 where k = 0->(m-1) in integer steps.\n    // Return the coeffecients c_n of that polynomial.\n    // TODO - Numerical Recipes suggests that if `Math.cos` is bogging this down,\n    // we should look at 12.3 and consider \"fast cosine transform methods\"\n\n  }, {\n    key: 'approx',\n    value: function approx(func, a, b) {\n      var n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 50;\n\n      var y = void 0;\n      var c = new Float64Array(n);\n      var f = new Float64Array(n);\n\n      var bma = 0.5 * (b - a);\n      var bpa = 0.5 * (b + a);\n\n      // Evaluate func at n points\n      for (var k = 0; k < n; k++) {\n        y = Math.cos(Math.PI * (k + 0.5) / n);\n        f[k] = func(y * bma + bpa);\n      }\n\n      // Calculate the c_j\n      var fac = 2.0 / n;\n      var sum = 0.0;\n      for (var j = 0; j < n; j++) {\n        sum = 0.0;\n        for (var _k = 0; _k < n; _k++) {\n          sum += f[_k] * Math.cos(Math.PI * j * (_k + 0.5) / n);\n        }\n\n        c[j] = fac * sum;\n      }\n\n      return c;\n    }\n\n    // Chebyshev evaluation: The Chebyshev polynomial c_k T_k(y) - c_0/2 where k=0->(m-1)\n    // is evaluated at y = [x - (b+a)/2] / [(b-a)/2] using the coeffecients c. These coeffecients\n    // can be calculated by AdvMathChebyshev::approx.\n\n  }, {\n    key: 'eval',\n    value: function _eval(viewX, x, viewR, r, a, b, c) {\n      var opts = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {};\n\n      var outOfRange = (viewX[x] - a) * (viewX[x] - b) > 0.0;\n      if (outOfRange) {\n        throw new Error('x not in range in Chebyshev::eval');\n      }\n\n      var sv = void 0,\n          j = void 0;\n      var d = 0.0;\n      var dd = 0.0;\n\n      // Change of variable\n      var y = (2.0 * viewX[x] - a - b) / (b - a);\n      var y2 = 2.0 * y;\n\n      // Clenshaws recurrence\n      var m = this.setm(c, opts);\n      for (j = m - 1; j > 0; j--) {\n        sv = d;\n        d = y2 * d - dd + c[j];\n        dd = sv;\n      }\n\n      viewR[r] = y * d - dd + 0.5 * c[0];\n    }\n\n    // Don't bother iterating over coeffecients less than opts.thresh\n\n  }, {\n    key: 'setm',\n    value: function setm(c, opts) {\n      var m = c.length;\n\n      if (opts.thresh) {\n        while (m > 1 && Math.abs(c[m - 1]) < opts.thresh) {\n          m--;\n        }\n      } else if (opts.m) {\n        m = opts.m;\n      }\n      return m;\n    }\n  }]);\n\n  return Chebyshev;\n}();\n\nexports.default = Chebyshev;\n},{}],83:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sinpi = exports.rgamma = exports.gamma = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _complex = require('../../utils/complex.js');\n\nvar _complex2 = _interopRequireDefault(_complex);\n\nvar _pythonHelpers = require('../../utils/pythonHelpers.js');\n\nvar py = _interopRequireWildcard(_pythonHelpers);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar EXACT_GAMMA = [Infinity, 1.0, 1.0, 2.0, 6.0, 24.0, 120.0, 720.0, 5040.0, 40320.0, 362880.0, 3628800.0, 39916800.0, 479001600.0, 6227020800.0, 87178291200.0, 1307674368000.0, 20922789888000.0, 355687428096000.0, 6402373705728000.0, 121645100408832000.0, 2432902008176640000.0];\n\n// Lanczos coefficients used by the GNU Scientific Library\nvar LANCZOS_G = 7;\nvar LANCZOS_P = [0.99999999999980993, 676.5203681218851, -1259.1392167224028, 771.32342877765313, -176.61502916214059, 12.507343278686905, -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7];\n\nfunction gammaReal(x) {\n  var _intx = Math.round(x);\n  if (_intx === x) {\n    if (_intx <= 0) {\n      // return (-1)**_intx * INF\n      throw new ZeroDivisionError('gamma function pole');\n    }\n    if (EXACT_GAMMA[_intx]) {\n      return EXACT_GAMMA[_intx];\n    }\n  }\n\n  if (x < 0.5) {\n    // TODO: sinpi\n    return Math.PI / (sinpiReal(x) * gammaReal(1 - x));\n  } else {\n    x -= 1.0;\n    var r = LANCZOS_P[0];\n    for (var i = 1; i < LANCZOS_G + 2; i++) {\n      r += LANCZOS_P[i] / (x + i);\n    }\n    var t = x + LANCZOS_G + 0.5;\n    return 2.506628274631000502417 * t ** (x + 0.5) * Math.exp(-t) * r;\n  }\n}\n\nfunction gammaComplex(x) {\n  if (_complex2.default.re(x) < 0.5) {\n    // TODO: sinpi\n    var oneMinusX = _complex2.default.sub(1, x);\n    var denom = _complex2.default.mul(sinpiComplex(x), gammaComplex(oneMinusX));\n    return _complex2.default.div(Math.PI, denom);\n  } else {\n    x = _complex2.default.sub(x, 1.0);\n    var r = LANCZOS_P[0];\n    for (var i = 1; i < LANCZOS_G + 2; i++) {\n      var xPlusI = _complex2.default.add(x, i);\n      var term = _complex2.default.div(LANCZOS_P[i], xPlusI);\n      r = _complex2.default.add(r, term);\n    }\n    var t = _complex2.default.add(x, LANCZOS_G + 0.5);\n    // return 2.506628274631000502417 * t**(x+0.5) * Complex.exp(-t) * r\n    var xPlusHalf = _complex2.default.add(x, 0.5);\n    var tToTheXPlusHalf = _complex2.default.pow(t, xPlusHalf);\n    var negT = _complex2.default.mul(-1, t);\n    var rTimesEToTheMinusT = _complex2.default.mul(r, _complex2.default.exp(negT));\n    var product = _complex2.default.mul(tToTheXPlusHalf, rTimesEToTheMinusT);\n    return _complex2.default.mul(2.506628274631000502417, product);\n  }\n}\n\nfunction gamma(x) {\n  if (x.constructor === Array) {\n    return gammaComplex(x);\n  } else {\n    return gammaReal(x);\n  }\n}\n\nfunction rgamma(x) {\n  try {\n    return _complex2.default.inverse(gamma(x));\n  } catch (e) {\n    if (e.name === 'ZeroDivisionError') {\n      return _complex2.default.mul(x, 0.0);\n    } else {\n      // only catch ZeroDivisionError\n      throw e;\n    }\n  }\n}\n\nfunction sinpiReal(x) {\n  if (x < 0) return -sinpiReal(-x);\n\n  var _py$divmod = py.divmod(x, 0.5),\n      _py$divmod2 = _slicedToArray(_py$divmod, 2),\n      n = _py$divmod2[0],\n      r = _py$divmod2[1];\n\n  r *= Math.PI;\n  n = py.mod(n, 4);\n  if (n === 0) return Math.sin(r);\n  if (n === 1) return Math.cos(r);\n  if (n === 2) return -Math.sin(r);\n  if (n === 3) return -Math.cos(r);\n}\n\nfunction sinpiComplex(z) {\n  if (_complex2.default.re(z) < 0) {\n    var negZ = _complex2.default.mul(-1, z);\n    var res = sinpiComplex(negZ);\n    return _complex2.default.mul(-1, res);\n  };\n\n  var _py$divmod3 = py.divmod(_complex2.default.re(z), 0.5),\n      _py$divmod4 = _slicedToArray(_py$divmod3, 2),\n      n = _py$divmod4[0],\n      r = _py$divmod4[1];\n\n  z = _complex2.default.mul(Math.PI, [r, _complex2.default.im(z)]);\n  n = py.mod(n, 4);\n  if (n === 0) return _complex2.default.sin(z);\n  if (n === 1) return _complex2.default.cos(z);\n  if (n === 2) return _complex2.default.mul(-1, _complex2.default.sin(z));\n  if (n === 3) return _complex2.default.mul(-1, _complex2.default.cos(z));\n}\n\nfunction sinpi(x) {\n  if (x.constructor === Array) {\n    return sinpiComplex(x);\n  } else {\n    return sinpiReal(x);\n  }\n}\n\nfunction ZeroDivisionError(message) {\n  this.message = message;\n  this.name = 'ZeroDivisionError';\n}\n\nexports.gamma = gamma;\nexports.rgamma = rgamma;\nexports.sinpi = sinpi;\n},{\"../../utils/complex.js\":89,\"../../utils/pythonHelpers.js\":94}],84:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.reset = exports.j = exports.expj = exports.expjpi = exports._defaultHyperMaxprec = exports.eps = exports._fixedPrecision = exports.dps = exports.prec = exports.isint = exports.NoConvergence = exports.isComplexType = exports._isRealType = exports.nstr = exports.convertParam = exports.hypsum = exports.fprod = exports.isnpint = exports.mag = exports.nintDistance = exports.convert = undefined;\n\nvar _pythonHelpers = require('../../utils/pythonHelpers.js');\n\nvar py = _interopRequireWildcard(_pythonHelpers);\n\nvar _complex = require('../../utils/complex.js');\n\nvar _complex2 = _interopRequireDefault(_complex);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n// Make fixed precision\nvar prec = 53;\nvar dps = 15;\nvar _fixedPrecision = true;\nvar eps = Number.EPSILON;\nvar j = [0, 1];\n\nfunction reset() {\n  exports.prec = prec = 53;\n}\n\n// mpmath relies on a bunch of helper functions stored in `ctx`.\nfunction nintDistance(z) {\n  var n = void 0,\n      distance = void 0;\n  if (z.constructor === Array) {\n    n = Math.round(z[0]);\n  } else {\n    n = Math.round(z);\n  }\n\n  if (n === z) {\n    distance = -Infinity;\n  } else {\n    distance = mag(_complex2.default.sub(z, n));\n  }\n\n  return [n, distance];\n}\n\n// function magc(z) {\n//   return Math.max(mag(Complex.re(z)), mag(Complex.im(z))) + 1;\n// }\n\nfunction mag(x) {\n  if (x) {\n    return py.frexp(_complex2.default.abs(x))[1];\n  } else {\n    return -Infinity;\n  }\n}\n\nfunction isnpint(x) {\n  if (x.constructor === Array) {\n    if (x[1] !== 0) {\n      return false;\n    }\n    x = x[0];\n  }\n  return x <= 0.0 && Math.round(x) === x;\n}\n\nfunction fprod(args) {\n  var prod = 1;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = args[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var arg = _step.value;\n\n      prod = _complex2.default.mul(prod, arg);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return prod;\n}\n\n// function hypsumMp(p, q, flags, coeffs, z, opts={}){\n//   if (!('accurate_small' in opts)) {\n//     opts['accurate_small'] = true;\n//   }\n//\n//   if (hasattr(z, \"_mpf_\")) {\n//     key = p, q, flags, 'R';\n//     v = z._mpf_;\n//   } else if (hasattr(z, \"_mpc_\")) {\n//     key = p, q, flags, 'C';\n//     v = z._mpc_;\n//   }\n//   if (key not in ctx.hyp_summators) {\n//     ctx.hyp_summators[key] = libmp.make_hyp_summator(key)[1];\n//   };\n//   summator = ctx.hyp_summators[key];\n//   prec = ctx.prec;\n//   maxprec = kwargs.get('maxprec', ctx._default_hyper_maxprec(prec));\n//   extraprec = 50;\n//   epsshift = 25;\n//   // Jumps in magnitude occur when parameters are close to negative\n//   // integers. We must ensure that these terms are included in\n//   // the sum and added accurately\n//   magnitude_check = {};\n//   max_total_jump = 0;\n//   for (i, c in enumerate(coeffs)) {\n//     if (flags[i]==='Z') {\n//       if (i >= p and c <= 0) {\n//         ok = False;\n//         for (ii, cc in enumerate(coeffs[:p])) {\n//           // Note: c <= cc or c < cc, depending on convention\n//           if (flags[ii]==='Z' and cc <= 0 and c <= cc) {\n//             ok = True;\n//           }\n//         }\n//         if (not ok) {\n//           raise ZeroDivisionError(\"pole in hypergeometric series\")\n//         }\n//       }\n//       continue\n//     }\n//     [n, d] = ctx.nint_distance(c);\n//     n = -int(n);\n//     d = -d;\n//     if (i >= p and n >= 0 and d > 4) {\n//       if (n in magnitude_check) {\n//         magnitude_check[n] += d;\n//       } else {\n//         magnitude_check[n] = d\n//       }\n//       extraprec = max(extraprec, d - prec + 60)\n//     }\n//     max_total_jump += abs(d);\n//   }\n//   while (1) {\n//     if (extraprec > maxprec) {\n//       raise ValueError(ctx._hypsum_msg % (prec, prec+extraprec))\n//     }\n//     wp = prec + extraprec;\n//     if (magnitude_check) {\n//       mag_dict = dict((n,None) for n in magnitude_check);\n//     } else {\n//       mag_dict = {}\n//     }\n//     [zv, have_complex, magnitude] = summator(coeffs, v, prec, wp, epsshift, mag_dict, **kwargs);\n//     cancel = -magnitude;\n//     jumps_resolved = true;\n//     if (extraprec < max_total_jump) {\n//       for (n in mag_dict.values()) {\n//         if ((n is None) or (n < prec)) {\n//           jumps_resolved = false;\n//           break\n//         }\n//       }\n//     }\n//     accurate = (cancel < extraprec-25-5 or not accurate_small)\n//     if (jumps_resolved) {\n//       if (accurate) {\n//         break\n//       }\n//       //zero?\n//       zeroprec = kwargs.get('zeroprec');\n//       if (zeroprec is not None) {\n//         if (cancel > zeroprec) {\n//           if (have_complex) {\n//             return ctx.mpc(0);\n//           } else {\n//             return ctx.zerol\n//           }\n//         }\n//       }\n//     }\n//     // Some near-singularities were not included, so increase\n//     // precision and repeat until they are\n//     extraprec *= 2;\n//     // Possible workaround for bad roundoff in fixed-point arithmetic\n//     epsshift += 5;\n//     extraprec += 5;\n//   }\n//   if (type(zv) is tuple) {\n//     if (have_complex) {\n//       return ctx.make_mpc(zv);\n//     } else {\n//       return ctx.make_mpf(zv);\n//     }\n//   } else {\n//     return zv;\n//   }\n// }\n\n// Depending on the context, mpmath might call any one of a number of hypsum functions\n// this one got translated by accident for our immediate usecase, but may be useful later\nfunction hypsum(p, q, types, coeffs, z) {\n  var opts = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n\n  if (!('maxterms' in opts)) {\n    opts['maxterms'] = 6000;\n  }\n\n  var num = py.range(p);\n  var den = py.range(p, p + q);\n  var tol = eps;\n  var s = 1.0;\n  var t = 1.0;\n  var k = 0;\n\n  while (1) {\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = num[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var i = _step2.value;\n        t = _complex2.default.mul(t, _complex2.default.add(coeffs[i], k));\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = den[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var _i = _step3.value;\n        t = _complex2.default.div(t, _complex2.default.add(coeffs[_i], k));\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n\n    k += 1;\n    t = _complex2.default.div(t, k);\n    t = _complex2.default.mul(t, z);\n    s = _complex2.default.add(s, t);\n    if (_complex2.default.abs(t) < tol) {\n      return s;\n    }\n    if (k > opts.maxterms) {\n      throw new NoConvergence('hypsum failed to converge');\n    }\n  }\n}\n\n// original divided when given a tuple, since js doesn't have tuples or\n// much in the way of numeric types, we'll leave that out and assume numbers\n// passed are either ints, real, or complex.\nfunction convertParam(z) {\n  // if (tuple) {\n  //   [p, q] = z;\n  //   return [p / q, 'R'];\n  // }\n  var intz = void 0;\n  if (z.constructor === Array) {\n    intz = Math.floor(z[0]);\n  } else {\n    intz = Math.floor(z);\n  }\n\n  if (z === intz) {\n    return [intz, 'Z'];\n  }\n\n  return [z, 'R'];\n}\n\nfunction convert(x) {\n  return _complex2.default.ensureComplex(x);\n}\n\nfunction nstr(x) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  // x = Complex.ensureComplex(x);\n\n  // TODO - to string function - mpi\n  // if (hasattr(x, \"_mpi_\")) {\n  //   return libmp.mpi_to_str(x._mpi_, n, opts)\n  // }\n  // if (hasattr(x, \"_mpci_\")) {\n  //   re = libmp.mpi_to_str(x._mpci_[0], n, opts)\n  //   im = libmp.mpi_to_str(x._mpci_[1], n, opts)\n  //   return \"(%s + %s*j)\" % (re, im)\n  // }\n  return String(x);\n}\n\nfunction isint(z) {\n  if (z.constructor === Array) {\n    if (_complex2.default.im(z)) {\n      return false;\n    }\n    z = _complex2.default.re(z);\n  }\n  return Number.isInteger(z);\n}\n\nfunction expjpi(x) {\n  return _complex2.default.exp(_complex2.default.mul([0, Math.PI], x));\n}\n\nfunction expj(x) {\n  return _complex2.default.exp(_complex2.default.mul([0, 1], x));\n}\n\nfunction _isRealType(z) {\n  return z.constructor !== Array;\n}\n\nfunction isComplexType(z) {\n  return z.constructor === Array;\n}\n\nfunction NoConvergence(message) {\n  this.message = message;\n  this.name = 'NoConvergence';\n}\n\nfunction _defaultHyperMaxprec(p) {\n  return Math.trunc(1000 * p ** 0.25 + 4 * p);\n}\n\nexports.convert = convert;\nexports.nintDistance = nintDistance;\nexports.mag = mag;\nexports.isnpint = isnpint;\nexports.fprod = fprod;\nexports.hypsum = hypsum;\nexports.convertParam = convertParam;\nexports.nstr = nstr;\nexports._isRealType = _isRealType;\nexports.isComplexType = isComplexType;\nexports.NoConvergence = NoConvergence;\nexports.isint = isint;\nexports.prec = prec;\nexports.dps = dps;\nexports._fixedPrecision = _fixedPrecision;\nexports.eps = eps;\nexports._defaultHyperMaxprec = _defaultHyperMaxprec;\nexports.expjpi = expjpi;\nexports.expj = expj;\nexports.j = j;\nexports.reset = reset;\n},{\"../../utils/complex.js\":89,\"../../utils/pythonHelpers.js\":94}],85:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.struvel = exports.besselk = exports.besseli = undefined;\n\nvar _complex = require('../../../utils/complex.js');\n\nvar _complex2 = _interopRequireDefault(_complex);\n\nvar _hypergeometric = require('./hypergeometric.js');\n\nvar mpHypergeometric = _interopRequireWildcard(_hypergeometric);\n\nvar _ctx = require('../ctx.js');\n\nvar ctx = _interopRequireWildcard(_ctx);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// besselI of complex order and arg of selected derivative\nfunction besseli(n, z) {\n  var derivative = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  ctx.reset();\n  var v = void 0,\n      r = void 0,\n      t = void 0;\n  n = ctx.convert(n);\n  z = ctx.convert(z);\n\n  if (_complex2.default.isZero(z)) {\n    if (derivative !== 0) {\n      // raise ValueError\n      throw new Error('besseli derivative not defined for z[0] = z[1] = 0');\n    }\n\n    if (_complex2.default.isZero(n)) {\n      // I(0,0) = 1\n      return 1;\n    }\n\n    // Integer orders are zero when z is zero\n    if (n[1] === 0 && Number.isInteger(n[0])) {\n      return 0;\n    }\n\n    // Non-integer orders (the real part) are either NaN, 0, or Infinity\n    if (n[0] === 0) {\n      return NaN;\n    } else if (n[0] > 0) {\n      return 0;\n    } else {\n      return Infinity;\n    }\n  }\n\n  if (derivative) {\n    var h = function h(n, d) {\n      var zSquared = _complex2.default.mul(z, z);\n      r = _complex2.default.mul(zSquared, 0.25);\n      var nOver2 = _complex2.default.div(n, 2);\n      var nPlus1 = _complex2.default.add(n, 1);\n      var b = [_complex2.default.add(nOver2, 0.5 - d / 2), _complex2.default.add(nOver2, 1 - d / 2), nPlus1];\n      // mpmath returns a tuple wrapped in a list\n      // [([2,ctx.pi,z],[d-2*n,0.5,n-d],[n+1],B,[(n+1)*0.5,(n+2)*0.5],B,r)]\n      t = [[2, Math.PI, z], // ws\n      // [d-2*n,0.5,n-d]\n      [_complex2.default.sub(d, _complex2.default.mul(2, n)), 0.5, _complex2.default.sub(n, d)], // cs\n      [nPlus1], // alphas\n      b, // betas\n      // [(n+1)*0.5,(n+2)*0.5]\n      [_complex2.default.mul(nPlus1, 0.5), _complex2.default.mul(_complex2.default.add(n, 2), 0.5)], // as = 2\n      b, // bs = 1\n      r // z\n      ];\n      return [t];\n    };\n    v = mpHypergeometric.hypercomb(h, [n, derivative], opts);\n  } else {\n    var _h = function _h(n) {\n      var nPlus1 = _complex2.default.add(n, 1);\n      var w = _complex2.default.mul(z, 0.5);\n      r = _complex2.default.mul(w, w);\n      // as = 0 bs = 1\n      t = [[w], [n], [], [nPlus1], [], [nPlus1], r];\n      return [t];\n    };\n    v = mpHypergeometric.hypercomb(_h, [n], opts);\n  }\n  return v;\n}\n\n// complex arg - besselK\nfunction besselk(n, z) {\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  ctx.reset();\n  n = _complex2.default.ensureComplex(n);\n  z = _complex2.default.ensureComplex(z);\n  if (_complex2.default.isZero(z)) {\n    return Infinity;\n  }\n\n  var h = void 0;\n  var capitalM = ctx.mag(z);\n  if (capitalM < 1) {\n    // Represent as limit definition\n    h = function h(n) {\n      var nPlus1 = _complex2.default.add(n, 1);\n      var zOver2 = _complex2.default.div(z, 2);\n      var negN = _complex2.default.mul(n, -1);\n      var r = _complex2.default.pow(zOver2, 2);\n      //    ws       cs                       alphas betas as=0 bs=1\n      var t1 = [[z, 2], [negN, _complex2.default.sub(n, 1)], [n], [], [], [_complex2.default.sub(1, n)], r];\n      var t2 = [[z, 2], [n, _complex2.default.mul(nPlus1, -1)], [negN], [], [], [nPlus1], r];\n      return [t1, t2];\n    };\n    // We could use the limit definition always, but it leads\n    // to very bad cancellation (of exponentially large terms)\n    // for large real z\n    // Instead represent in terms of 2F0\n  } else {\n    ctx.prec += capitalM;\n    h = function h(n) {\n      var negZ = _complex2.default.mul(z, -1);\n      var t = [[Math.PI / 2, z, _complex2.default.exp(negZ)], [0.5, -0.5, 1], [], [], [_complex2.default.add(n, 0.5), _complex2.default.sub(0.5, n)], // a=2\n      [], // b=0\n      _complex2.default.mul(-0.5, _complex2.default.inverse(z))];\n      return [t];\n    };\n  }\n\n  return mpHypergeometric.hypercomb(h, [n], opts);\n}\n\nfunction struvel(n, z, opts) {\n  ctx.reset();\n  n = ctx.convert(n);\n  z = ctx.convert(z);\n  // http://functions.wolfram.com/Bessel-TypeFunctions/StruveL/26/01/02/\n  var h = function h(n) {\n    var capitalT = [[_complex2.default.div(z, 2), 0.5 * Math.sqrt(Math.PI)], [_complex2.default.add(n, 1), -1], [], [_complex2.default.add(n, 1.5)], [1], [1.5, _complex2.default.add(n, 1.5)], _complex2.default.pow(_complex2.default.div(z, 2), 2)];\n    return [capitalT];\n  };\n  return mpHypergeometric.hypercomb(h, [n], opts);\n}\n\nexports.besseli = besseli;\nexports.besselk = besselk;\nexports.struvel = struvel;\n},{\"../../../utils/complex.js\":89,\"../ctx.js\":84,\"./hypergeometric.js\":88}],86:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.gammaprod = undefined;\n\nvar _ctx = require('../ctx.js');\n\nvar ctx = _interopRequireWildcard(_ctx);\n\nvar _complex = require('../../../utils/complex.js');\n\nvar _complex2 = _interopRequireDefault(_complex);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction gammaprod(a, b) {\n  var _infsign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  a = a.map(function (x) {\n    return ctx.convert(x);\n  });\n  b = b.map(function (x) {\n    return ctx.convert(x);\n  });\n  var polesNum = [];\n  var polesDen = [];\n  var regularNum = [];\n  var regularDen = [];\n\n  var sign = void 0;\n\n  a.map(function (x) {\n    if (ctx.isnpint(x)) {\n      polesNum.push(x);\n    } else {\n      regularNum.push(x);\n    }\n  });\n\n  b.map(function (x) {\n    if (ctx.isnpint(x)) {\n      polesDen.push(x);\n    } else {\n      regularDen.push(x);\n    }\n  });\n\n  // One more pole in numerator or denominator gives 0 or inf\n  if (polesNum.length < polesDen.length) return 0;\n  if (polesNum.length > polesDen.length) {\n    // Get correct sign of infinity for x+h, h -> 0 from above\n    // XXX: hack, this should be done properly\n    if (_infsign) {\n      var _a, _b;\n\n      a = polesNum.map(function (x) {\n        return x && (_complex2.default.mul(x, 1 + ctx.eps) || _complex2.default.add(x, ctx.eps));\n      });\n      b = polesDen.map(function (x) {\n        return x && (_complex2.default.mul(x, 1 + ctx.eps) || _complex2.default.add(x, ctx.eps));\n      });\n      sign = ctx.sign(ctx.gammaprod((_a = a).push.apply(_a, regularNum), (_b = b).push.apply(_b, regularDen)));\n      return _complex2.default.mul(sign, Infinity);\n    } else {\n      return Infinity;\n    }\n  }\n  // All poles cancel\n  // lim G(i)/G(j) = (-1)**(i+j) * gamma(1-j) / gamma(1-i)\n  var p = 1;\n  var orig = ctx.prec;\n  try {\n    ctx.prec = orig + 15;\n    while (polesNum.length > 0) {\n      var i = polesNum.pop();\n      var j = polesDen.pop();\n      var iPlusJ = _complex2.default.add(i, j);\n      sign = _complex2.default.pow(-1, iPlusJ);\n      var gammaOneMinusJ = ctx.gamma(_complex2.default.sub(1, j));\n      var gammaOneMinusI = ctx.gamma(_complex2.default.sub(1, i));\n      var quotient = _complex2.default.div(gammaOneMinusJ, gammaOneMinusI);\n      p *= _complex2.default.mul(sign, quotient);\n    }\n    regularNum.forEach(function (x) {\n      p = _complex2.default.mul(p, ctx.gamma(x));\n    });\n    regularDen.forEach(function (x) {\n      p = _complex2.default.div(p, ctx.gamma(x));\n    });\n  } finally {\n    ctx.prec = orig;\n  }\n  return p;\n}\n\nexports.gammaprod = gammaprod;\n},{\"../../../utils/complex.js\":89,\"../ctx.js\":84}],87:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sign = undefined;\n\nvar _complex = require('../../../utils/complex.js');\n\nvar _complex2 = _interopRequireDefault(_complex);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction sign(ctx, x) {\n  if (!x || Number.isNaN(x)) return x;\n  if (ctx._isRealType(x)) {\n    if (x > 0) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n\n  return _complex2.default.div(x, _complex2.default.abs(x));\n}\n\nexports.sign = sign;\n},{\"../../../utils/complex.js\":89}],88:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hyp1f2 = exports.hyp2f0 = exports.hyper = exports.hypercomb = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _complex = require('../../../utils/complex.js');\n\nvar _complex2 = _interopRequireDefault(_complex);\n\nvar _ctx = require('../ctx.js');\n\nvar ctx = _interopRequireWildcard(_ctx);\n\nvar _pythonHelpers = require('../../../utils/pythonHelpers.js');\n\nvar py = _interopRequireWildcard(_pythonHelpers);\n\nvar _math = require('../../math2/math2.js');\n\nvar math2 = _interopRequireWildcard(_math);\n\nvar _factorials = require('./factorials.js');\n\nvar mpFactorials = _interopRequireWildcard(_factorials);\n\nvar _functions = require('./functions.js');\n\nvar mpFunctions = _interopRequireWildcard(_functions);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n// In original this is called hypercomb\n\n// Thoughts:\n//   I'd rather it was given / returned a keyed object.\n\nfunction hypercomb(func) {\n  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var hmag = void 0,\n      zeroOk = void 0,\n      infOk = void 0;\n  var orig = ctx.prec;\n  var discardKnownZeros = py.get(opts, 'discardKnownZeros', true);\n  var sumvalue = 0;\n  var origParams = [].concat(_toConsumableArray(params));\n  var verbose = py.get(opts, 'verbose', false);\n  var maxprec = py.get(opts, 'maxprec', ctx._defaultHyperMaxprec(orig));\n  opts.maxprec = maxprec; // For calls to hypsum\n  var zeroprec = py.get(opts, 'zeroprec');\n  var infprec = py.get(opts, 'infprec');\n  var perturbedReferenceValue = null;\n  var hextra = 0;\n  try {\n    while (1) {\n      ctx.prec += 10;\n      if (ctx.prec > maxprec) {\n        // raise ValueError(_hypercomb_msg % (orig, ctx.prec));\n        throw new Error('_hypercomb_msg: orig: ' + orig + ' | ctx.prec: ' + ctx.prec);\n      }\n\n      var orig2 = ctx.prec;\n      params = [].concat(_toConsumableArray(origParams));\n      var terms = func.apply(undefined, _toConsumableArray(params));\n      if (verbose) {\n        console.log();\n        console.log('ENTERING hypercomb main loop');\n        console.log('prec =', ctx.prec);\n        console.log('hextra', hextra);\n      }\n\n      var _checkNeedPerturb2 = _checkNeedPerturb(terms, orig, discardKnownZeros),\n          _checkNeedPerturb3 = _slicedToArray(_checkNeedPerturb2, 4),\n          perturb = _checkNeedPerturb3[0],\n          recompute = _checkNeedPerturb3[1],\n          extraprec = _checkNeedPerturb3[2],\n          discard = _checkNeedPerturb3[3];\n\n      ctx.prec += extraprec;\n      if (perturb) {\n        if (opts.hasOwnProperty('hmag')) {\n          hmag = opts.hmag;\n        } else if (ctx._fixedPrecision) {\n          hmag = Math.trunc(ctx.prec * 0.3);\n        } else {\n          hmag = orig + 10 + hextra;\n        }\n        opts.perturbParams = [];\n        var h = py.ldexp(1, -hmag);\n        ctx.prec = orig2 + 10 + hmag + 10;\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = py.range(params.length)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var k = _step.value;\n\n            opts.perturbParams[k] = h;\n            params[k] = _complex2.default.add(params[k], h);\n            // Heuristically ensure that the perturbations\n            // are \"independent\" so that two perturbations\n            // don't accidentally cancel each other out\n            // in a subtraction.\n            h += h / (k + 1);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n      if (recompute) {\n        terms = func.apply(undefined, _toConsumableArray(params).concat([opts]));\n      }\n      if (discardKnownZeros) {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = discard[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var index = _step2.value;\n            delete terms[index];\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n\n        terms = terms.filter(Boolean);\n      }\n      if (!terms.length) {\n        return 0;\n      }\n\n      // Now actually perform the calculation!\n      var evaluatedTerms = [];\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        var _loop = function _loop() {\n          var _step3$value = _slicedToArray(_step3.value, 2),\n              termIndex = _step3$value[0],\n              termData = _step3$value[1];\n\n          var _termData = _slicedToArray(termData, 7),\n              ws = _termData[0],\n              cs = _termData[1],\n              alphas = _termData[2],\n              betas = _termData[3],\n              aS = _termData[4],\n              bS = _termData[5],\n              z = _termData[6]; // tuple\n\n\n          if (verbose) {\n            console.log();\n            console.log('Evaluating term %i/%i : %iF%i', termIndex + 1, terms.length, aS.length, bS.length);\n            console.log('powers: ws: ' + ws + ' | cs: ' + cs);\n            console.log('gamma: alphas: ' + alphas + ' | betas: ' + betas);\n            console.log('hyper: as: ' + aS + ' | bs: ' + bS + ' ');\n            console.log('z', ctx.nstr(z));\n          }\n\n          // ===========================\n          var v = hyper(aS, bS, z, opts);\n          alphas.map(function (a) {\n            v = _complex2.default.mul(v, math2.gamma(a));\n          });\n          betas.map(function (b) {\n            v = _complex2.default.mul(v, math2.rgamma(b));\n          });\n          py.zipmap(ws, cs, function (w, c) {\n            v = _complex2.default.mul(v, _complex2.default.pow(w, c));\n          });\n          // ===========================\n\n          if (verbose) {\n            console.log('Value: ' + v);\n          }\n          evaluatedTerms.push(v);\n        };\n\n        for (var _iterator3 = terms.entries()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          _loop();\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      if (terms.length === 1 && !perturb) {\n        sumvalue = evaluatedTerms[0];\n        break;\n      }\n\n      if (ctx._fixedPrecision) {\n        sumvalue = _complex2.default.sum(evaluatedTerms);\n        break;\n      }\n\n      sumvalue = _complex2.default.sum(evaluatedTerms);\n      var termMagnitudes = evaluatedTerms.map(function (x) {\n        return ctx.mag(x);\n      });\n      var maxMagnitude = Math.max.apply(Math, _toConsumableArray(termMagnitudes));\n      var sumMagnitude = ctx.mag(sumvalue);\n      var cancellation = maxMagnitude - sumMagnitude;\n      if (verbose) {\n        console.log('Cancellation: ' + cancellation + ' bits');\n        console.log('Increased precision: ' + (ctx.prec - orig) + ' bits');\n      }\n\n      var precisionOk = cancellation < ctx.prec - orig;\n\n      if (opts.zeroprec) {\n        zeroOk = false;\n      } else {\n        zeroOk = maxMagnitude - ctx.prec < -zeroprec;\n      }\n      if (opts.infprec) {\n        infOk = false;\n      } else {\n        infOk = maxMagnitude > infprec;\n      }\n\n      if (precisionOk && (!perturb || isNaN(cancellation))) {\n        break;\n      } else if (precisionOk) {\n        if (perturbedReferenceValue === null) {\n          hextra += 20;\n          perturbedReferenceValue = sumvalue;\n          continue;\n        } else if (ctx.mag(sumvalue - perturbedReferenceValue) <= ctx.mag(sumvalue) - orig) {\n          break;\n        } else if (zeroOk) {\n          sumvalue = 0;\n          break;\n        } else if (infOk) {\n          sumvalue = Infinity;\n          break;\n        } else if ('hmag' in opts) {\n          break;\n        } else {\n          hextra *= 2;\n          perturbedReferenceValue = sumvalue;\n        }\n      } else {\n        // Increase precision\n        var maxDiff = Math.max(cancellation, Math.floor(orig / 2));\n        var increment = Math.min(maxDiff, Math.max(extraprec, orig));\n        ctx.prec += increment;\n        if (verbose) {\n          console.log('Must start over with increased precision');\n        }\n        continue;\n      }\n    } // while\n  } finally {\n    // reset precision for other funcs\n    ctx.prec = orig;\n  }\n  return sumvalue;\n}\n\nfunction _checkNeedPerturb(terms, prec, discardKnownZeros) {\n  var recompute = false;\n  var perturb = false;\n  var extraprec = 0;\n  var discard = [];\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    for (var _iterator4 = terms.entries()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var _step4$value = _slicedToArray(_step4.value, 2),\n          _termIndex = _step4$value[0],\n          term = _step4$value[1];\n\n      var _term = _slicedToArray(term, 7),\n          _ws = _term[0],\n          _cs = _term[1],\n          _alphas = _term[2],\n          _betas = _term[3],\n          as = _term[4],\n          bs = _term[5],\n          _z2 = _term[6]; // eslint-disable-line no-unused-vars\n\n\n      var haveSingularNongammaWeight = false;\n      // Avoid division by zero in leading factors (TODO:\n      // also check for near division by zero?)\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = _ws.entries()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var _step5$value = _slicedToArray(_step5.value, 2),\n              k = _step5$value[0],\n              w = _step5$value[1];\n\n          if (_complex2.default.isZero(w)) {\n            if (_complex2.default.re(_cs[k]) <= 0 && _cs[k]) {\n              perturb = true;\n              recompute = true;\n              haveSingularNongammaWeight = true;\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      var poleCount = [0, 0, 0];\n      // Check for gamma and series poles and near-poles\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = [_alphas, _betas, bs].entries()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var _step6$value = _slicedToArray(_step6.value, 2),\n              dataIndex = _step6$value[0],\n              data = _step6$value[1];\n\n          var _iteratorNormalCompletion7 = true;\n          var _didIteratorError7 = false;\n          var _iteratorError7 = undefined;\n\n          try {\n            for (var _iterator7 = data.entries()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n              var _step7$value = _slicedToArray(_step7.value, 2),\n                  index = _step7$value[0],\n                  x = _step7$value[1];\n\n              // eslint-disable-line no-unused-vars\n              var _ctx$nintDistance = ctx.nintDistance(x),\n                  _ctx$nintDistance2 = _slicedToArray(_ctx$nintDistance, 2),\n                  n = _ctx$nintDistance2[0],\n                  d = _ctx$nintDistance2[1];\n              // Poles\n\n\n              if (n > 0) {\n                continue;\n              }\n              if (d === -Infinity) {\n                // OK if we have a polynomial\n                // ------------------------------\n                var ok = false;\n                if (dataIndex === 2) {\n                  var _iteratorNormalCompletion8 = true;\n                  var _didIteratorError8 = false;\n                  var _iteratorError8 = undefined;\n\n                  try {\n                    for (var _iterator8 = as[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n                      var u = _step8.value;\n\n                      if (ctx.isnpint(u) && u >= n) {\n                        ok = true;\n                        break;\n                      }\n                    }\n                  } catch (err) {\n                    _didIteratorError8 = true;\n                    _iteratorError8 = err;\n                  } finally {\n                    try {\n                      if (!_iteratorNormalCompletion8 && _iterator8.return) {\n                        _iterator8.return();\n                      }\n                    } finally {\n                      if (_didIteratorError8) {\n                        throw _iteratorError8;\n                      }\n                    }\n                  }\n                }\n\n                if (ok) {\n                  continue;\n                }\n                poleCount[dataIndex] += 1;\n                // ------------------------------\n                // perturb = recompute = True\n                // return perturb, recompute, extraprec}\n              } else if (d < -4) {\n                extraprec += -d;\n                recompute = true;\n              }\n            }\n          } catch (err) {\n            _didIteratorError7 = true;\n            _iteratorError7 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion7 && _iterator7.return) {\n                _iterator7.return();\n              }\n            } finally {\n              if (_didIteratorError7) {\n                throw _iteratorError7;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      if (discardKnownZeros && poleCount[1] > poleCount[0] + poleCount[2] && !haveSingularNongammaWeight) {\n        discard.append(_termIndex);\n      } else if (py.sum(poleCount)) {\n        perturb = true;\n        recompute = true;\n      }\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n\n  return [perturb, recompute, extraprec, discard];\n}\n\nfunction hyper(aS, bS, z, opts) {\n  // \"\"\"\n  // Hypergeometric function, general case.\n  // \"\"\"\n  z = _complex2.default.ensureComplex(z);\n  var p = aS.length;\n  var q = bS.length;\n  aS = aS.map(function (a) {\n    return ctx.convertParam(a);\n  });\n  bS = bS.map(function (b) {\n    return ctx.convertParam(b);\n  });\n\n  // Reduce degree by eliminating common parameters\n  if (py.get(opts, 'eliminate', true)) {\n    var elimNonpositive = py.get(opts, 'eliminate_all', false);\n    var i = 0;\n    while (i < q && aS.length > 0) {\n      var b = bS[i];\n      // better way than index of to determine if b is in aS?\n      var indexOfB = aS.indexOf(b);\n      if (indexOfB > -1 && (elimNonpositive || !ctx.isnpint(b[0]))) {\n        aS.splice(indexOfB);\n        bS.splice(bS.indexOf(b));\n        p -= 1;\n        q -= 1;\n      } else {\n        i += 1;\n      }\n    }\n  }\n\n  // Handle special cases\n  if (p === 0) {\n    if (q === 1) return _hyp0f1(bS, z, opts);else if (q === 0) return _complex2.default.exp(z);\n  } else if (p === 1) {\n    if (q === 1) {\n      var res = _hyp1f1(aS[0], bS[0], z, opts);\n      return res;\n    } else if (q === 2) return _hyp1f2(aS, bS, z, opts);else if (q === 0) return _hyp1f0(aS[0][0], z);\n  } else if (p === 2) {\n    if (q === 1) return _hyp2f1(aS, bS, z, opts);else if (q === 2) return _hyp2f2(aS, bS, z, opts);else if (q === 3) return _hyp2f3(aS, bS, z, opts);else if (q === 0) {\n      var _res = _hyp2f0(aS, bS, z, opts);\n      return _res;\n    }\n  } else if (p === q + 1) {\n    return _hypq1fq(p, q, aS, bS, z, opts);\n  } else if (p > q + 1 && !py.get(opts, 'force_series')) {\n    return _hypBorel(p, q, aS, bS, z, opts);\n  }\n\n  var _py$unzip = py.unzip([].concat(_toConsumableArray(aS), _toConsumableArray(bS))),\n      _py$unzip2 = _slicedToArray(_py$unzip, 2),\n      coeffs = _py$unzip2[0],\n      types = _py$unzip2[1];\n\n  return ctx.hypsum(p, q, types, coeffs, z, opts);\n}\n\n// function hyp0f1(b, z, opts) {\n//     return hyper([], [b], z, opts);\n// }\n\n// function hyp1f1(a, b, z, opts) {\n//     return hyper([a], [b], z, opts);\n// }\n\nfunction hyp1f2(a1, b1, b2, z, opts) {\n  return hyper([a1], [b1, b2], z, opts);\n}\n\nfunction hyp2f1(a, b, c, z, opts) {\n  return hyper([a, b], [c], z, opts);\n}\n\n// function hyp2f2(a1, a2, b1, b2, z, opts) {\n//     return hyper([a1, a2], [b1, b2], z, opts);\n// }\n\n// function hyp2f3(a1, a2, b1, b2, b3, z, opts) {\n//     return hyper([a1, a2], [b1, b2, b3], z, opts);\n// }\n\nfunction hyp2f0(a, b, z, opts) {\n  return hyper([a, b], [], z, opts);\n}\n\n// function hyp3f2(a1, a2, a3, b1, b2, z, opts) {\n//     return hyper([a1, a2, a3], [b1, b2], z, opts);\n// }\n\n// TODO\nfunction _hyp0f1(bS, z, opts) {\n  var magz = void 0,\n      v = void 0;\n\n  var _bS$ = _slicedToArray(bS[0], 2),\n      b = _bS$[0],\n      btype = _bS$[1];\n\n  if (z) {\n    magz = ctx.mag(z);\n  } else {\n    magz = 0;\n  }\n  if (magz >= 8 && !opts.force_series) {\n    try {\n      // http://functions.wolfram.com/HypergeometricFunctions/\n      // Hypergeometric0F1/06/02/03/0004/\n      // TODO: handle the all-real case more efficiently!\n      // TODO: figure out how much precision is needed (exponential growth)\n      var orig = ctx.prec;\n      try {\n        ctx.prec += 12 + Math.floor(magz / 2);\n        var w = _complex2.default.sqrt(_complex2.default.mul(-1, z));\n        var jw = _complex2.default.mul([0, 1], w);\n        var minusJw = _complex2.default.mul(-1, jw);\n        var u = _complex2.default.inverse(_complex2.default.mul(4, jw));\n        var minusU = _complex2.default.mul(-1, u);\n        var c = _complex2.default.sub(0.5, b);\n        var bMinusHalf = _complex2.default.sub(b, 0.5);\n        var oneAndHalfMinusB = _complex2.default.sub(1.5, b);\n        var capitalE = _complex2.default.exp(_complex2.default.mul(2, jw));\n        var hyp2f0Res = hyp2f0(bMinusHalf, oneAndHalfMinusB, minusU, { 'force_series': true });\n        var prefactor = _complex2.default.div(_complex2.default.pow(minusJw, c), capitalE);\n        var capitalH1 = _complex2.default.mul(prefactor, hyp2f0Res);\n        hyp2f0Res = hyp2f0(bMinusHalf, oneAndHalfMinusB, u, { 'force_series': true });\n        prefactor = _complex2.default.mul(_complex2.default.pow(jw, c), capitalE);\n        var capitalH2 = _complex2.default.mul(prefactor, hyp2f0Res);\n        var hSum = _complex2.default.add(capitalH1, capitalH2);\n        var quotient = _complex2.default.div(math2.gamma(b), 2 * Math.sqrt(Math.PI));\n        v = _complex2.default.mul(quotient, hSum);\n      } finally {\n        ctx.prec = orig;\n      }\n      // if b and z are real\n      if (ctx._isRealType(b) && ctx._isRealType(z)) {\n        v = _complex2.default.re(v);\n      }\n      // below was return +v - in python this means carry context settings like rounding out with the decimal.\n      return v;\n    } catch (e) {\n      if (e.name !== 'NoConvergence') {\n        throw e;\n      }\n    }\n  }\n  return ctx.hypsum(0, 1, [btype], [b], z, opts);\n};\n\nfunction _hyp1f1(aS, bS, z, opts) {\n  var _aS = _slicedToArray(aS, 2),\n      a = _aS[0],\n      atype = _aS[1];\n\n  var _bS = _slicedToArray(bS, 2),\n      b = _bS[0],\n      btype = _bS[1];\n\n  if (_complex2.default.isZero(z)) {\n    return _complex2.default.add(1, z);\n  }\n  var magz = ctx.mag(z);\n  var v = void 0;\n  if (magz >= 7 && !(ctx.isint(a) && _complex2.default.re(a) <= 0)) {\n    if (!isFinite(z)) {\n      if (mpFunctions.sign(a) === mpFunctions.sign(b) === mpFunctions.sign(z) === 1) {\n        return Infinity;\n      }\n      return _complex2.default.mul(NaN, z);\n    }\n    try {\n      try {\n        ctx.prec += magz;\n        var sector = _complex2.default.im(z) < 0;\n        var h = function h(a, b) {\n          var negA = _complex2.default.mul(-1, a);\n          var aMinusB = _complex2.default.sub(a, b);\n          var bMinusA = _complex2.default.sub(b, a);\n          var capitalE = void 0;\n          if (sector) {\n            capitalE = ctx.expjpi(negA);\n          } else {\n            capitalE = ctx.expjpi(a);\n          }\n          var rz = _complex2.default.inverse(z);\n          var capitalT1 = [[capitalE, z], [1, negA], [b], [bMinusA], [a, _complex2.default.add(1, aMinusB)], [], _complex2.default.mul(-1, rz)];\n          var capitalT2 = [[_complex2.default.exp(z), z], [1, aMinusB], [b], [a], [bMinusA, 1 - a], [], rz];\n          return [capitalT1, capitalT2];\n        };\n        v = hypercomb(h, [a, b], { 'force_series': true });\n        if (ctx._is_real_type(a) && ctx._is_real_type(b) && ctx._is_real_type(z)) {\n          v = _complex2.default.re(v);\n        }\n        return v;\n      } catch (e) {\n        if (e.name !== 'NoConvergence') {\n          throw e;\n        }\n      }\n    } finally {\n      ctx.prec -= magz;\n    }\n  }\n\n  v = ctx.hypsum(1, 1, (atype, btype), [a, b], z, opts);\n  return v;\n};\n\nfunction _hyp2f1Gosper(a, b, c, z) {\n  var opts = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\n  var f1 = void 0;\n  // Use Gosper's recurrence\n  // See http://www.math.utexas.edu/pipermail/maxima/2006/000126.html\n  var _a = a,\n      _b = b,\n      _c = c,\n      _z = z;\n\n  var orig = ctx.prec;\n  var maxprec = py.get(opts, 'maxprec', 100 * orig);\n  var extra = 10;\n  while (1) {\n    ctx.prec = orig + extra;\n    a = ctx.convert(_a);\n    b = ctx.convert(_b);\n    c = ctx.convert(_c);\n    z = ctx.convert(_z);\n    var d = 0;\n    var e = 1;\n    var f = 0;\n    var k = 0;\n    // Common subexpression elimination, unfortunately making\n    // things a bit unreadable. The formula is quite messy to begin\n    // with, though...\n    var abz = _complex2.default.mul(_complex2.default.mul(a, b), z);\n    var ch = _complex2.default.mul(c, 0.5);\n    var c1h = _complex2.default.mul(_complex2.default.add(c, 1), 0.5);\n    var nz = _complex2.default.sub(1, z);\n    var g = _complex2.default.div(z, nz);\n    var abg = _complex2.default.mul(_complex2.default.mul(a, b), g);\n    var cba = _complex2.default.sub(_complex2.default.sub(c, b), a);\n    var z2 = _complex2.default.sub(z, 2);\n    var tol = -ctx.prec - 10;\n    var maxmag = -Infinity;\n    while (1) {\n      var kch = _complex2.default.add(k, ch);\n      // kakbz = (k+a)*(k+b)*z / (4*(k+1)*kch*(k+c1h));\n      var numerator = _complex2.default.prod([_complex2.default.add(k, a), _complex2.default.add(k, b), z]);\n      var denominator = _complex2.default.prod([4, _complex2.default.add(k, 1), kch, _complex2.default.add(k, c1h)]);\n      var kakbz = _complex2.default.div(numerator, denominator);\n      // d1 = kakbz*(e-(k+cba)*d*g)\n      var kcbadg = _complex2.default.prod([_complex2.default.add(k, cba), d, g]);\n      var d1 = _complex2.default.mul(kakbz, _complex2.default.sub(e, kcbadg));\n      // e1 = kakbz*(d*abg+(k+c)*e);\n      var dabgkce = _complex2.default.add(_complex2.default.mul(d, abg), _complex2.default.mul(_complex2.default.add(k, c), e));\n      var e1 = _complex2.default.mul(kakbz, dabgkce);\n      // ft = d*(k*(cba*z+k*z2-c)-abz)/(2*kch*nz);\n      var cbazkz2 = _complex2.default.add(_complex2.default.mul(cba, z), _complex2.default.mul(k, z2));\n      var cbazkz2c = _complex2.default.sub(cbazkz2, c);\n      var kcbazkz2cabz = _complex2.default.sub(_complex2.default.mul(k, cbazkz2c), abz);\n      numerator = _complex2.default.mul(d, kcbazkz2cabz);\n      denominator = _complex2.default.prod([2, kch, nz]);\n      var ft = _complex2.default.div(numerator, denominator);\n      f1 = _complex2.default.sub(_complex2.default.add(f, e), ft);\n      maxmag = Math.max(maxmag, ctx.mag(f1));\n      if (ctx.mag(_complex2.default.sub(f1, f)) < tol) {\n        break;\n      }\n      d = d1;\n      e = e1;\n      f = f1;\n\n      k = _complex2.default.add(k, 1);\n    }\n    var cancellation = maxmag - ctx.mag(f1);\n    if (cancellation < extra) {\n      break;\n    } else {\n      extra += cancellation;\n      if (extra > maxprec) {\n        throw new ctx.NoConvergence();\n      }\n    }\n  }\n  return f1;\n}\n\nfunction _hyp1f2(aS, bS, z, opts) {\n  var _aS$ = _slicedToArray(aS[0], 2),\n      a1 = _aS$[0],\n      a1type = _aS$[1];\n\n  var _bS2 = _slicedToArray(bS, 2),\n      _bS2$ = _slicedToArray(_bS2[0], 2),\n      b1 = _bS2$[0],\n      b1type = _bS2$[1],\n      _bS2$2 = _slicedToArray(_bS2[1], 2),\n      b2 = _bS2$2[0],\n      b2type = _bS2$2[1];\n\n  var absz = _complex2.default.abs(z);\n  var magz = ctx.mag(z);\n  var orig = ctx.prec;\n\n  // Asymptotic expansion is ~ exp(sqrt(z))\n  var asympExtraprec = z && Math.floor(magz / 2);\n\n  // # Asymptotic series is in terms of 3F0\n  // set to true for the moment, normally false for some reason.\n  var canUseAsymptotic = !py.get(opts, 'force_series') && ctx.mag(absz) > 19 && Math.sqrt(absz) > 1.5 * orig; // # and \\\n  // #   ctx._hyp_check_convergence([a1, a1-b1+1, a1-b2+1], [],\n  // #                              1/absz, orig+40+asympExtraprec)\n\n  // # TODO: much of the following could be shared with 2F3 instead of\n  // # copypasted\n  if (canUseAsymptotic) {\n    // #print \"using asymp\"\n    try {\n      try {\n        ctx.prec += asympExtraprec;\n        // # http://functions.wolfram.com/HypergeometricFunctions/\n        // # Hypergeometric1F2/06/02/03/\n        var h = function h(a1, b1, b2) {\n          var a1Sqrd = _complex2.default.pow(a1, 2);\n          var b1Plusb2 = _complex2.default.add(b1, b2);\n          var a1Minusb1Minusb2 = _complex2.default.sub(a1, b1Plusb2);\n          var capitalX = _complex2.default.mul(0.5, _complex2.default.add(a1Minusb1Minusb2, 0.5));\n          var c = [];\n          c[0] = 1;\n          // c1\n          var b1Plusb2Minus2 = _complex2.default.sub(b1Plusb2, 2);\n          var threeA1Plus = _complex2.default.add(_complex2.default.mul(3, a1), b1Plusb2Minus2);\n          var b1b2 = _complex2.default.mul(b1, b2);\n          var prod = _complex2.default.prod([0.25, threeA1Plus, a1Minusb1Minusb2]);\n          var bigTerm = _complex2.default.sum(prod, b1b2, -3 / 16);\n          c[1] = _complex2.default.mul(2, bigTerm);\n\n          // c2\n          var nEightA1Sqr = _complex2.default.mul(-8, a1Sqrd);\n          var sum = _complex2.default.sum([nEightA1Sqr, _complex2.default.mul(11, a1), b1Plusb2Minus2]);\n          var twoA1minus3 = _complex2.default.sub(_complex2.default.mul(2, a1), 3);\n          var capitalA = _complex2.default.prod([-16, twoA1minus3, b1b2]);\n          var capitalB = _complex2.default.prod([4, a1Minusb1Minusb2, sum]);\n          var thing3 = _complex2.default.sum(capitalA, capitalB, -3);\n          var twoBigTermSqrd = _complex2.default.mul(2, _complex2.default.pow(bigTerm, 2));\n          c[2] = _complex2.default.add(twoBigTermSqrd, _complex2.default.mul(1 / 16, thing3));\n          var s1 = 0;\n          var s2 = 0;\n          var k = 0;\n          var tprev = 0;\n\n          while (1) {\n            if (c[k] === undefined) {\n              var _sum = _complex2.default.sum([_complex2.default.mul(-6, a1), _complex2.default.mul(2, b1), _complex2.default.mul(2, b2), -4]);\n              var kSum = _complex2.default.mul(k, _sum);\n              var threeA1Sqrd = _complex2.default.mul(3, a1Sqrd);\n              var threekSqrd = _complex2.default.mul(3, _complex2.default.pow(k, 2));\n              var uu1 = _complex2.default.sum([threekSqrd, kSum, threeA1Sqrd, _complex2.default.mul(-1, _complex2.default.pow(b1Plusb2, 2)), _complex2.default.prod([-1, 2, a1, b1Plusb2Minus2]), 0.25]);\n              var minusA1 = _complex2.default.mul(-1, a1);\n              var minusB1 = _complex2.default.mul(-1, b1);\n              var minusB2 = _complex2.default.mul(-1, b2);\n              var uu2 = _complex2.default.prod([_complex2.default.sum([k, minusA1, b1, minusB2, -0.5]), _complex2.default.sum([k, minusA1, minusB1, b2, -0.5]), _complex2.default.sum([k, minusA1, b1, b2, -5 / 2])]);\n              var oneOver2k = _complex2.default.inverse(_complex2.default.mul(2, k));\n              var diff = _complex2.default.sub(_complex2.default.mul(uu1, c[k - 1]), _complex2.default.mul(uu2, c[k - 2]));\n              c[k] = _complex2.default.mul(oneOver2k, diff);\n            }\n            var minusHalfK = _complex2.default.mul(-0.5, k);\n            var twoToTheMinusK = _complex2.default.pow(2, _complex2.default.mul(-1, k));\n            var minusZ = _complex2.default.mul(-1, z);\n            var w = _complex2.default.mul(c[k], _complex2.default.pow(minusZ, minusHalfK));\n            var t1 = _complex2.default.prod([_complex2.default.pow([0, -1], k), twoToTheMinusK, w]);\n            var t2 = _complex2.default.prod([_complex2.default.pow(ctx.j, k), twoToTheMinusK, w]);\n            if (_complex2.default.abs(t1) < 0.1 * ctx.eps) {\n              // #print \"Convergence :)\"\n              break;\n            }\n            // # Quit if the series doesn't converge quickly enough\n            if (k > 5 && _complex2.default.abs(tprev) / _complex2.default.abs(t1) < 1.5) {\n              // #print \"No convergence :(\"\n              throw new ctx.NoConvergence();\n            }\n            s1 = _complex2.default.add(s1, t1);\n            s2 = _complex2.default.add(s2, t2);\n            tprev = t1;\n            k += 1;\n          }\n          var capitalS = ctx.expj(Math.PI * capitalX + 2 * _complex2.default.sqrt(-z)) * s1 + ctx.expj(-(Math.PI * capitalX + 2 * _complex2.default.sqrt(-z))) * s2;\n          var capitalT1 = [[0.5 * capitalS, Math.PI, -z], [1, -0.5, capitalX], [b1, b2], [a1], [], [], 0];\n          var capitalT2 = [[-z], [-a1], [b1, b2], [b1 - a1, b2 - a1], [a1, a1 - b1 + 1, a1 - b2 + 1], [], 1 / z];\n          return [capitalT1, capitalT2];\n        };\n\n        var _v = hypercomb(h, [a1, b1, b2], { force_series: true, maxterms: 4 * ctx.prec });\n        if ([a1, b1, b2, z].every(ctx._isRealType)) {\n          _v = _complex2.default.re(_v);\n        }\n        return _v;\n      } catch (e) {\n        if (e.name === 'NoConvergence') {\n          // pass // python statement for do nothing.\n        } else {\n          // only catch NoConvergence errors\n          throw e;\n        }\n      }\n    } finally {\n      ctx.prec = orig;\n    }\n  }\n  // #print \"not using asymp\"\n  var res = ctx.hypsum(1, 2, (a1type, b1type, b2type), [a1, b1, b2], z, opts);\n  return res;\n};\nfunction _hyp1f0() {\n  throw new Error('Not Implemented');\n};\nfunction _hyp2f1(aS, bS, z) {\n  var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  var h = void 0,\n      v = void 0,\n      t = void 0,\n      ca = void 0,\n      cb = void 0,\n      rz = void 0,\n      capitalT1 = void 0,\n      capitalT2 = void 0;\n\n  var _aS2 = _slicedToArray(aS, 2),\n      _aS2$ = _slicedToArray(_aS2[0], 2),\n      a = _aS2$[0],\n      atype = _aS2$[1],\n      _aS2$2 = _slicedToArray(_aS2[1], 2),\n      b = _aS2$2[0],\n      btype = _aS2$2[1];\n\n  var _bS3 = _slicedToArray(bS, 2),\n      c = _bS3[0],\n      ctype = _bS3[1];\n\n  if (_complex2.default.equals(z, 1)) {\n    // TODO: the following logic can be simplified\n    var convergent = _complex2.default.re(_complex2.default.sub(c, _complex2.default.add(a, b))) > 0;\n    var finite = ctx.isint(a) && a <= 0 || ctx.isint(b) && b <= 0;\n    var condition2 = !(ctx.isint(a) && c <= a <= 0 || ctx.isint(b) && c <= b <= 0);\n    var zerodiv = ctx.isint(c) && c <= 0 && condition2;\n    // print \"bz\", a, b, c, z, convergent, finite, zerodiv\n    // Gauss's theorem gives the value if convergent\n    if ((convergent || finite) && !zerodiv) {\n      var _ca = _complex2.default.sub(c, a);\n      return mpFactorials.gammaprod([c, _complex2.default.minus(_ca, b)], [_ca, _complex2.default.sub(c, b)], true);\n    }\n    // Otherwise, there is a pole and we take the\n    // sign to be that when approaching from below\n    // XXX: this evaluation is not necessarily correct in all cases\n    return _complex2.default.mul(hyp2f1(a, b, c, 1 - ctx.eps * 2), Infinity);\n  }\n  // Equal to 1 (first term), unless there is a subsequent\n  // division by zero\n  if (!_complex2.default.isZero(z)) {\n    // Division by zero but power of z is higher than\n    // first order so cancels\n    if (!_complex2.default.isZero(c) || _complex2.default.isZero(a) || _complex2.default.isZero(b)) {\n      return _complex2.default.add(1, z);\n    }\n    // Indeterminate\n    return NaN;\n  }\n\n  // Hit zero denominator unless numerator goes to 0 first\n  if (ctx.isint(c) && c <= 0) {\n    if (ctx.isint(a) && c <= a <= 0 || ctx.isint(b) && c <= b <= 0) {\n      // pass; // Python statement to move on.\n    } else {\n      // Pole in series\n      return Infinity;\n    }\n  }\n  var absz = _complex2.default.abs(z);\n\n  // Fast case: standard series converges rapidly,\n  // possibly in finitely many terms\n  if (absz <= 0.8 || ctx.isint(a) && a <= 0 && a >= -1000 || ctx.isint(b) && b <= 0 && b >= -1000) {\n    return ctx.hypsum(2, 1, [atype, btype, ctype], [a, b, c], z, opts);\n  }\n  var orig = ctx.prec;\n  try {\n    ctx.prec += 10;\n    // Use 1/z transformation\n    if (absz >= 1.3) {\n      h = function h(a, b) {\n        var t = _complex2.default.sub(1, c);\n        var ab = _complex2.default.sub(a, b);\n        var rz = _complex2.default.div(1, z);\n        var capitalT1 = ([_complex2.default.mul(-1, z)], [_complex2.default.mul(-1, a)], [c, _complex2.default.mul(-1, ab)], [b, _complex2.default.sub(c, a)], [a, _complex2.default.add(t, a)], [_complex2.default.add(1, ab)], rz);\n        var capitalT2 = ([_complex2.default.mul(-1, z)], [_complex2.default.mul(-1, b)], [c, ab], [a, _complex2.default.sub(c, b)], [b, _complex2.default.add(t, b)], [_complex2.default.sub(1, ab)], rz);\n        return [capitalT1, capitalT2];\n      };\n      v = hypercomb(h, [a, b], opts);\n\n      // Use 1-z transformation\n    } else if (_complex2.default.abs(_complex2.default.sub(1, z)) <= 0.75) {\n      h = function h(a, b) {\n        t = _complex2.default.sub(c, _complex2.default.add(a, b));\n        ca = _complex2.default.sub(c, a);\n        cb = _complex2.default.sub(c, b);\n        rz = _complex2.default.sub(1, z);\n        capitalT1 = [[], [], [c, t], [ca, cb], [a, b], [_complex2.default.sub(1, t)], rz];\n        capitalT2 = [[rz], [t], [c, _complex2.default.mul(-1, t)], [a, b], [ca, cb], [_complex2.default.add(1, t)], rz];\n        return [capitalT1, capitalT2];\n      };\n      v = hypercomb(h, [a, b], opts);\n\n      // Use z/(z-1) transformation\n    } else if (_complex2.default.abs(_complex2.default.div(z, _complex2.default.sub(z, 1))) <= 0.75) {\n      var h2f1 = hyp2f1(a, _complex2.default.sub(c, b), c, _complex2.default.div(z, _complex2.default.sub(z, 1)));\n      v = _complex2.default.div(h2f1, _complex2.default.pow(_complex2.default.sub(1, z), a));\n    } else {\n      // Remaining part of unit circle\n      v = _hyp2f1Gosper(a, b, c, z, opts);\n    }\n  } finally {\n    ctx.prec = orig;\n  }\n  return v;\n};\n\nfunction _hyp2f2() {\n  throw new Error('Not Implemented');\n};\nfunction _hyp2f3() {\n  throw new Error('Not Implemented');\n};\nfunction _hyp2f0(aS, bS, z) {\n  var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  var _aS3 = _slicedToArray(aS, 2),\n      _aS3$ = _slicedToArray(_aS3[0], 2),\n      a = _aS3$[0],\n      atype = _aS3$[1],\n      _aS3$2 = _slicedToArray(_aS3[1], 2),\n      b = _aS3$2[0],\n      btype = _aS3$2[1];\n  // We want to try aggressively to use the asymptotic expansion,\n  // and fall back only when absolutely necessary\n\n\n  try {\n    var optsb = JSON.parse(JSON.stringify(opts)); // TODO: do we really need a copy? copying is sorta rough in JS\n    optsb['maxterms'] = py.get(optsb, 'maxterms', ctx.prec);\n    return ctx.hypsum(2, 0, [atype, btype], [a, b], z, optsb);\n  } catch (e) {\n    if (e.name === 'NoConvergence') {\n      if (py.get(opts, 'force_series')) {\n        throw e;\n      }\n    } else {\n      // only catch NoConvergence errors\n      throw e;\n    }\n  }\n\n  // THOUGHTS: you have the perturb of a so handle the subtraction better down below?\n  var h = function h(a, b) {\n    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    // HACK = manually handle perturbations\n    // sin(pi*(b + h)) = sin(pi*b)cos(pi*h) + cos(pi * b)sin(pi*h)\n    //\n    // b = 0, 2, 4,\n    // sin(pi*h)\n    //\n    // b = 1,3,5\n    // -sin(pi*h)\n    //\n    // b = 1/2, 5/2, 9/2\n    // cos(pi*h)\n    //\n    // b = 3/2, 7/2, 11/2\n    // -cos(pi*h)\n    var w = void 0;\n    if (opts.perturbParams) {\n      switch ((b * 2 + 1) % 4) {\n        case 1:\n          // 0, 2, 4\n          w = Math.sin(Math.PI * opts.perturbParams[1]);\n          break;\n        case 2:\n          // 1/2, 5/2, 9/2\n          w = Math.cos(Math.PI * opts.perturbParams[1]);\n          break;\n        case 3:\n          // 1,3,5\n          w = -Math.sin(Math.PI * opts.perturbParams[1]);\n          break;\n        case 0:\n          // 3/2, 7/2, 11/2\n          w = -Math.cos(Math.PI * opts.perturbParams[1]);\n          break;\n        default:\n          console.log('sinpi was perturbed but b was not half integer');\n          w = math2.sinpi(b);\n      }\n    } else {\n      w = math2.sinpi(b);\n    }\n    var rz = _complex2.default.mul(-1, _complex2.default.inverse(z));\n    var aMinusB = _complex2.default.sub(a, b);\n    var twoMinusB = _complex2.default.sub(2, b);\n    // ws, cs, alphas, betas, as, bs, z\n    var capitalT1 = [[Math.PI, w, rz], [1, -1, a], [], [_complex2.default.add(aMinusB, 1), b], [a], [b], rz];\n    var capitalT2 = [[-Math.PI, w, rz], [1, -1, _complex2.default.add(1, aMinusB)], [], [a, twoMinusB], [_complex2.default.add(aMinusB, 1)], [twoMinusB], rz];\n    return [capitalT1, capitalT2];\n  };\n\n  var aMinusB = _complex2.default.sub(a, b);\n  return hypercomb(h, [a, _complex2.default.add(1, aMinusB)], opts);\n};\n\nfunction _hypq1fq() {\n  throw new Error('Not Implemented');\n};\n\n// TODO - this was abandoned near completion because we realized we don't need it for\n// the use case we're starting with. It's only lacking the quad function.\nfunction _hypBorel(p, q, aS, bS, z, opts) {\n  throw new Error('Not Fully Implemented / Tested');\n  // if (aS) {\n  //   [aS, aTypes] = pyp.unzip(aS)\n  // } else {\n  //   aS = []\n  //   aTypes = []\n  // }\n  // if (bS) {\n  //   [bS, bTypes] = py.unzip(bS)\n  // } else {\n  //   bS = []\n  //   bTypes = []\n  // }\n  //\n  // opts['maxterms'] = py.get(opts, 'maxterms', ctx.prec)\n  // try {\n  //   return ctx.hypsum(p, q, aTypes + bTypes, aS + bS, z, opts)\n  // } catch (e) {\n  //   if (e.name === 'NoConvergence') {\n  //     // pass // python statement for do nothing.\n  //   } else {\n  //     // only catch NoConvergence errors\n  //     throw e\n  //   }\n  // }\n  // prec = ctx.prec\n  // try {\n  //   tol = opts.asymp_tol || (ctx.eps / 4)\n  //   ctx.prec += 10\n  //   function term (k, cache = { 0: 1 }) {\n  //     if (k in cache) {\n  //       return cache[k]\n  //     }\n  //     t = term(k - 1)\n  //     aS.map((a) => t *= a + (k - 1))\n  //     bS.map((b) => t /= b + (k - 1))\n  //     t *= z\n  //     t /= k\n  //     cache[k] = t\n  //     return t\n  //   }\n  //   s = 1\n  //   for (k of py.range(1, ctx.prec)) {\n  //     t = term(k)\n  //     s += t\n  //     if (Math.abs(t) <= tol) {\n  //       return s\n  //     }\n  //   }\n  // } finally {\n  //   ctx.prec = prec\n  // }\n  // if (p <= q + 3) {\n  //   if (!opts.contour) {\n  //     if (Complex.arg(z) < 0.25) {\n  //       u = Complex.div(z, max(1, Complex.abs(z)))\n  //       if (Complex.arg(z) >= 0) {\n  //         contour = [0, [0, 2], Complex.div([2, 2], u), Complex.div(2, u), Infinity]\n  //       } else {\n  //         contour = [0, [0, -2], Complex.div([2, -2], u), Complex.div(2, u), Infinity]\n  //       }\n  //       // contour = [0, 2j/z, 2/z, ctx.inf]\n  //       // contour = [0, 2j, 2/z, ctx.inf]\n  //       // contour = [0, 2j, ctx.inf]}\n  //     } else {\n  //       contour = [0, Infinity]\n  //     }\n  //   }\n  //   quadOpts = opts.quadOpts || {}\n  //   function g (t) {\n  //     eToTheMinusT = Complex.exp(-t)\n  //     hyperVal = hyper(aS, [...bS, 1], Complex.mul(t, z))\n  //     return Complex.mul(eToTheMinusT, hyperVal)\n  //   }\n  //   quadOpts['error'] = true;\n  //   [capitalI, err] = mpmath.quad(g, contour, quadOpts) // todo-missingfunc quad\n  //   if (err <= abs(capitalI) * ctx.eps * 8) {\n  //     return capitalI\n  //   }\n  // }\n  // throw new ctx.UserException('_hyp_borel failed to converge')\n};\n\nexports.hypercomb = hypercomb;\nexports.hyper = hyper;\nexports.hyp2f0 = hyp2f0;\nexports.hyp1f2 = hyp1f2;\n},{\"../../../utils/complex.js\":89,\"../../../utils/pythonHelpers.js\":94,\"../../math2/math2.js\":83,\"../ctx.js\":84,\"./factorials.js\":86,\"./functions.js\":87}],89:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// List of sources:\n//\n// ComplexJS: https://github.com/infusion/Complex.js\n\n// Thoughts:\n// Inline functions instead of calling class?\nvar Complex = function () {\n  function Complex() {\n    _classCallCheck(this, Complex);\n  }\n\n  _createClass(Complex, null, [{\n    key: \"equals\",\n    value: function equals(a, b) {\n      var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1e-14;\n\n      a = Complex.ensureComplex(a);\n      b = Complex.ensureComplex(b);\n      return Math.abs(a[0] - b[0]) <= precision && Math.abs(a[1] - b[1]) <= precision;\n    }\n  }, {\n    key: \"abs\",\n    value: function abs(a) {\n      if (Complex.isReal(a)) {\n        return Math.abs(Complex.re(a));\n      }\n      return Math.sqrt(a[0] ** 2 + a[1] ** 2);\n    }\n\n    // angle\n\n  }, {\n    key: \"arg\",\n    value: function arg(a) {\n      a = Complex.ensureComplex(a);\n      return Math.atan2(a[1], a[0]);\n    }\n  }, {\n    key: \"add\",\n    value: function add(a, b) {\n      if (Complex.isReal(a) && Complex.isReal(b)) {\n        return Complex.re(a) + Complex.re(b);\n      }\n      a = Complex.ensureComplex(a);\n      b = Complex.ensureComplex(b);\n      return [a[0] + b[0], a[1] + b[1]];\n    }\n  }, {\n    key: \"sub\",\n    value: function sub(a, b) {\n      if (Complex.isReal(a) && Complex.isReal(b)) {\n        return Complex.re(a) - Complex.re(b);\n      }\n      a = Complex.ensureComplex(a);\n      b = Complex.ensureComplex(b);\n      return [a[0] - b[0], a[1] - b[1]];\n    }\n  }, {\n    key: \"mul\",\n    value: function mul(a, b) {\n      if (Complex.isReal(a) && Complex.isReal(b)) {\n        return Complex.re(a) * Complex.re(b);\n      }\n      a = Complex.ensureComplex(a);\n      b = Complex.ensureComplex(b);\n      var realPart = a[0] * b[0] - a[1] * b[1];\n      var imagPart = a[0] * b[1] + a[1] * b[0];\n      return [realPart, imagPart];\n    }\n  }, {\n    key: \"div\",\n    value: function div(a, b) {\n      if (Complex.isReal(a) && Complex.isReal(b)) {\n        return Complex.re(a) / Complex.re(b);\n      }\n      a = Complex.ensureComplex(a);\n      b = Complex.ensureComplex(b);\n      var denominator = b[0] ** 2 + b[1] ** 2;\n      var realPart = (a[0] * b[0] + a[1] * b[1]) / denominator;\n      var imagPart = (a[1] * b[0] - a[0] * b[1]) / denominator;\n      return [realPart, imagPart];\n    }\n  }, {\n    key: \"sqrt\",\n    value: function sqrt(a) {\n      if (Complex.isReal(a) && a >= 0) {\n        return Math.sqrt(Complex.re(a));\n      }\n      if (Complex.isReal(a) && a < 0) {\n        return [0, Math.sqrt(-Complex.re(a))];\n      }\n      a = Complex.ensureComplex(a);\n      var mod = Math.sqrt(a[0] ** 2 + a[1] ** 2);\n      var realPart = Math.sqrt((mod + a[0]) / 2);\n      var sign = Math.sign(a[1]);\n      // If imaginary part is 0 then use positive\n      if (sign === 0) {\n        sign = 1;\n      }\n      var imagPart = sign * Math.sqrt((mod - a[0]) / 2);\n      return [realPart, imagPart];\n    }\n  }, {\n    key: \"exp\",\n    value: function exp(a) {\n      if (Complex.isReal(a)) {\n        return Math.exp(Complex.re(a));\n      }\n      var expA = Math.exp(a[0]);\n      var realPart = expA * Math.cos(a[1]);\n      var imagPart = expA * Math.sin(a[1]);\n      return [realPart, imagPart];\n    }\n\n    /* Notes from complex.js for Complex.pow\n    *\n    * a + bi ^ c + di   = (a + bi)^(c + di)\n    *               = exp((c + di) * log(a + bi)\n    *               = pow(a^2 + b^2, (c + di) / 2) * exp(i(c + di)atan2(b, a))\n    * =>...\n    * Re = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * cos(d * log(a^2 + b^2) / 2 + c * atan2(b, a))\n    * Im = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * sin(d * log(a^2 + b^2) / 2 + c * atan2(b, a))\n    *\n    * =>...\n    * Re = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * cos(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))\n    * Im = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * sin(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))\n    *\n    * =>\n    * Re = exp(c * logsq2 - d * arg(z_1)) * cos(d * logsq2 + c * arg(z_1))\n    * Im = exp(c * logsq2 - d * arg(z_1)) * sin(d * logsq2 + c * arg(z_1))\n    *\n    */\n\n  }, {\n    key: \"pow\",\n    value: function pow(a, b) {\n      if (Complex.isReal(a) && Complex.isReal(b)) {\n        var result = Math.pow(Complex.re(a), Complex.re(b));\n        if (!isNaN(result)) {\n          return result;\n        }\n      }\n      a = Complex.ensureComplex(a);\n      b = Complex.ensureComplex(b);\n      var atan2 = Math.atan2(a[1], a[0]);\n      var logsqr = Math.log(Math.sqrt(a[0] ** 2 + a[1] ** 2));\n\n      var preR = Math.exp(b[0] * logsqr - b[1] * atan2);\n      var preRi = b[1] * logsqr + b[0] * atan2;\n\n      var realPart = preR * Math.cos(preRi);\n      var imagPart = preR * Math.sin(preRi);\n\n      return [realPart, imagPart];\n    }\n  }, {\n    key: \"log\",\n    value: function log(a) {\n      if (Complex.isReal(a)) {\n        return Math.log(Complex.re(a));\n      }\n      var realPart = Math.log(Math.sqrt(a[0] ** 2 + a[1] ** 2));\n      var imagPart = Math.atan2(a[1], a[0]);\n      return [realPart, imagPart];\n    }\n  }, {\n    key: \"sin\",\n    value: function sin(a) {\n      if (Complex.isReal(a)) {\n        return Math.sin(Complex.re(a));\n      }\n      var realPart = Math.sin(a[0]) * Math.cosh(a[1]);\n      var imagPart = Math.cos(a[0]) * Math.sinh(a[1]);\n      return [realPart, imagPart];\n    }\n  }, {\n    key: \"cos\",\n    value: function cos(a) {\n      if (Complex.isReal(a)) {\n        return Math.cos(Complex.re(a));\n      }\n      var realPart = Math.cos(a[0]) * Math.cosh(a[1]);\n      var imagPart = -Math.sin(a[0]) * Math.sinh(a[1]);\n      return [realPart, imagPart];\n    }\n  }, {\n    key: \"tan\",\n    value: function tan(a) {\n      if (Complex.isReal(a)) {\n        return Math.tan(Complex.re(a));\n      }\n      var denominator = Math.cos(a[0] * 2) + Math.cosh(a[1] * 2);\n      var realPart = Math.sin(a[0] * 2) / denominator;\n      var imagPart = Math.sinh(a[1] * 2) / denominator;\n      return [realPart, imagPart];\n    }\n  }, {\n    key: \"cot\",\n    value: function cot(a) {\n      a = Complex.ensureComplex(a);\n      var denominator = Math.cos(a[0] * 2) - Math.cosh(a[1] * 2);\n      var realPart = -Math.sin(a[0] * 2) / denominator;\n      var imagPart = Math.sinh(a[1] * 2) / denominator;\n      return [realPart, imagPart];\n    }\n  }, {\n    key: \"sec\",\n    value: function sec(a) {\n      a = Complex.ensureComplex(a);\n      var denominator = 0.5 * Math.cosh(a[1] * 2) + 0.5 * Math.cos(a[0] * 2);\n      var realPart = Math.cos(a[0]) * Math.cosh(a[1]) / denominator;\n      var imagPart = Math.sin(a[0]) * Math.sinh(a[1]) / denominator;\n      return [realPart, imagPart];\n    }\n  }, {\n    key: \"csc\",\n    value: function csc(a) {\n      a = Complex.ensureComplex(a);\n      var denominator = 0.5 * Math.cosh(a[1] * 2) - 0.5 * Math.cos(a[0] * 2);\n      var realPart = Math.sin(a[0]) * Math.cosh(a[1]) / denominator;\n      var imagPart = -Math.cos(a[0]) * Math.sinh(a[1]) / denominator;\n      return [realPart, imagPart];\n    }\n  }, {\n    key: \"asin\",\n    value: function asin(a) {\n      if (Complex.isReal(a)) {\n        return Math.asin(Complex.re(a));\n      }\n      var realPart = a[1] ** 2 - a[0] ** 2 + 1;\n      var imagPart = -2 * a[0] * a[1];\n\n      var _Complex$sqrt = Complex.sqrt([realPart, imagPart]);\n\n      var _Complex$sqrt2 = _slicedToArray(_Complex$sqrt, 2);\n\n      realPart = _Complex$sqrt2[0];\n      imagPart = _Complex$sqrt2[1];\n\n\n      realPart = realPart - a[1];\n      imagPart = imagPart + a[0];\n\n      var _Complex$log = Complex.log([realPart, imagPart]);\n\n      var _Complex$log2 = _slicedToArray(_Complex$log, 2);\n\n      realPart = _Complex$log2[0];\n      imagPart = _Complex$log2[1];\n\n\n      return [imagPart, -realPart];\n    }\n  }, {\n    key: \"acos\",\n    value: function acos(a) {\n      if (Complex.isReal(a)) {\n        return Math.acos(Complex.re(a));\n      }\n      var realPart = void 0,\n          imagPart = void 0;\n\n      var _Complex$asin = Complex.asin(a);\n\n      var _Complex$asin2 = _slicedToArray(_Complex$asin, 2);\n\n      realPart = _Complex$asin2[0];\n      imagPart = _Complex$asin2[1];\n\n      return [Math.PI / 2 - realPart, -imagPart];\n    }\n  }, {\n    key: \"atan\",\n    value: function atan(a) {\n      if (Complex.isReal(a)) {\n        return Math.atan(Complex.re(a));\n      }\n      var denominator = a[0] ** 2 + (a[1] - 1) ** 2;\n\n      var realPart = (1 - a[1] ** 2 - a[0] ** 2) / denominator;\n      var imagPart = -2 * a[0] / denominator;\n\n      var _Complex$log3 = Complex.log([realPart, imagPart]);\n\n      var _Complex$log4 = _slicedToArray(_Complex$log3, 2);\n\n      realPart = _Complex$log4[0];\n      imagPart = _Complex$log4[1];\n\n\n      return [imagPart * -0.5, realPart * 0.5];\n    }\n  }, {\n    key: \"acot\",\n    value: function acot(a) {\n      a = Complex.ensureComplex(a);\n      var denominator = a[0] ** 2 + a[1] ** 2;\n\n      var realPart = a[0] / denominator;\n      var imagPart = -a[1] / denominator;\n\n      return Complex.atan([realPart, imagPart]);\n    }\n  }, {\n    key: \"asec\",\n    value: function asec(a) {\n      a = Complex.ensureComplex(a);\n      var denominator = a[0] ** 2 + a[1] ** 2;\n\n      var realPart = a[0] / denominator;\n      var imagPart = -a[1] / denominator;\n\n      return Complex.acos([realPart, imagPart]);\n    }\n  }, {\n    key: \"acsc\",\n    value: function acsc(a) {\n      a = Complex.ensureComplex(a);\n      var denominator = a[0] ** 2 + a[1] ** 2;\n\n      var realPart = a[0] / denominator;\n      var imagPart = -a[1] / denominator;\n\n      return Complex.asin([realPart, imagPart]);\n    }\n  }, {\n    key: \"sinh\",\n    value: function sinh(a) {\n      if (Complex.isReal(a)) {\n        return Math.sinh(Complex.re(a));\n      }\n      var realPart = Math.sinh(a[0]) * Math.cos(a[1]);\n      var imagPart = Math.cosh(a[0]) * Math.sin(a[1]);\n      return [realPart, imagPart];\n    }\n  }, {\n    key: \"cosh\",\n    value: function cosh(a) {\n      if (Complex.isReal(a)) {\n        return Math.cosh(Complex.re(a));\n      }\n      var realPart = Math.cosh(a[0]) * Math.cos(a[1]);\n      var imagPart = Math.sinh(a[0]) * Math.sin(a[1]);\n      return [realPart, imagPart];\n    }\n  }, {\n    key: \"tanh\",\n    value: function tanh(a) {\n      if (Complex.isReal(a)) {\n        return Math.tanh(Complex.re(a));\n      }\n      var denominator = Math.cosh(a[0] * 2) + Math.cos(a[1] * 2);\n      var realPart = Math.sinh(a[0] * 2) / denominator;\n      var imagPart = Math.sin(a[1] * 2) / denominator;\n      return [realPart, imagPart];\n    }\n  }, {\n    key: \"coth\",\n    value: function coth(a) {\n      a = Complex.ensureComplex(a);\n      var denominator = Math.cosh(a[0] * 2) - Math.cos(a[1] * 2);\n      var realPart = Math.sinh(a[0] * 2) / denominator;\n      var imagPart = -Math.sin(a[1] * 2) / denominator;\n      return [realPart, imagPart];\n    }\n  }, {\n    key: \"csch\",\n    value: function csch(a) {\n      a = Complex.ensureComplex(a);\n      var denominator = Math.cos(a[1] * 2) - Math.cosh(a[0] * 2);\n      var realPart = -2 * Math.sinh(a[0]) * Math.cos(a[1]) / denominator;\n      var imagPart = 2 * Math.cosh(a[0]) * Math.sin(a[1]) / denominator;\n      return [realPart, imagPart];\n    }\n  }, {\n    key: \"sech\",\n    value: function sech(a) {\n      a = Complex.ensureComplex(a);\n      var denominator = Math.cos(a[1] * 2) + Math.cosh(a[0] * 2);\n      var realPart = 2 * Math.cosh(a[0]) * Math.cos(a[1]) / denominator;\n      var imagPart = -2 * Math.sinh(a[0]) * Math.sin(a[1]) / denominator;\n      return [realPart, imagPart];\n    }\n  }, {\n    key: \"asinh\",\n    value: function asinh(a) {\n      if (Complex.isReal(a)) {\n        return Math.asinh(Complex.re(a));\n      }\n      var realPart = void 0,\n          imagPart = void 0;\n\n      var _Complex$asin3 = Complex.asin([a[1], -a[0]]);\n\n      var _Complex$asin4 = _slicedToArray(_Complex$asin3, 2);\n\n      realPart = _Complex$asin4[0];\n      imagPart = _Complex$asin4[1];\n\n      return [-imagPart, realPart];\n    }\n  }, {\n    key: \"acosh\",\n    value: function acosh(a) {\n      if (Complex.isReal(a)) {\n        return Math.acosh(Complex.re(a));\n      }\n\n      var _Complex$acos = Complex.acos(a),\n          _Complex$acos2 = _slicedToArray(_Complex$acos, 2),\n          realPart = _Complex$acos2[0],\n          imagPart = _Complex$acos2[1];\n\n      if (imagPart <= 0) {\n        return [-imagPart, realPart];\n      } else {\n        return [imagPart, -realPart];\n      }\n    }\n  }, {\n    key: \"atanh\",\n    value: function atanh(a) {\n      if (Complex.isReal(a)) {\n        return Math.atanh(Complex.re(a));\n      }\n      var denominator = (1 - a[0]) ** 2 + a[1] ** 2;\n\n      var realPart = ((1 + a[0]) * (1 - a[0]) - a[1] ** 2) / denominator;\n      var imagPart = (a[1] * (1 - a[0]) + a[1] * (1 + a[0])) / denominator;\n\n      var cache = Math.log(Math.sqrt(realPart ** 2 + imagPart ** 2)) / 2;\n      imagPart = Math.atan2(imagPart, realPart) / 2;\n      realPart = cache;\n\n      return [realPart, imagPart];\n    }\n  }, {\n    key: \"acoth\",\n    value: function acoth(a) {\n      a = Complex.ensureComplex(a);\n      var denominator = a[0] ** 2 + a[1] ** 2;\n\n      var realPart = a[0] / denominator;\n      var imagPart = -a[1] / denominator;\n\n      return Complex.atanh([realPart, imagPart]);\n    }\n  }, {\n    key: \"acsch\",\n    value: function acsch(a) {\n      a = Complex.ensureComplex(a);\n      var denominator = a[0] ** 2 + a[1] ** 2;\n\n      var realPart = a[0] / denominator;\n      var imagPart = -a[1] / denominator;\n\n      return Complex.asinh([realPart, imagPart]);\n    }\n  }, {\n    key: \"asech\",\n    value: function asech(a) {\n      a = Complex.ensureComplex(a);\n      var denominator = a[0] ** 2 + a[1] ** 2;\n\n      var realPart = a[0] / denominator;\n      var imagPart = -a[1] / denominator;\n\n      return Complex.acosh([realPart, imagPart]);\n    }\n  }, {\n    key: \"inverse\",\n    value: function inverse(a) {\n      if (Complex.isReal(a)) {\n        return 1 / Complex.re(a);\n      }\n      a = Complex.ensureComplex(a);\n      var denominator = a[0] ** 2 + a[1] ** 2;\n\n      var realPart = a[0] === 0 ? 0 : a[0] / denominator;\n      var imagPart = a[1] === 0 ? 0 : -a[1] / denominator;\n\n      return [realPart, imagPart];\n    }\n\n    // default imaginary part to zero if non-array is passed\n\n  }, {\n    key: \"ensureComplex\",\n    value: function ensureComplex(arg) {\n      return arg.constructor === Array ? arg : [arg, 0];\n    }\n\n    // Return the real part of complex or just return if float\n\n  }, {\n    key: \"re\",\n    value: function re(arg) {\n      return arg.constructor === Array ? arg[0] : arg;\n    }\n\n    // Return the imaginary part or just 0 if float\n\n  }, {\n    key: \"im\",\n    value: function im(arg) {\n      return arg.constructor === Array ? arg[1] : 0;\n    }\n  }, {\n    key: \"isZero\",\n    value: function isZero(arg) {\n      if (arg.constructor === Array && arg.length > 1) {\n        return arg[0] === 0 && arg[1] === 0;\n      } else if (arg.constructor === Array && arg.length > 0) {\n        return arg[0] === 0;\n      } else {\n        return arg === 0;\n      }\n    }\n  }, {\n    key: \"prod\",\n    value: function prod(numbers) {\n      var total = Complex.mul(numbers[0], numbers[1]);\n      for (var i = 2; i < numbers.length; i++) {\n        total = Complex.mul(total, numbers[i]);\n      }\n      return total;\n    }\n  }, {\n    key: \"sum\",\n    value: function sum(numbers) {\n      var total = [0, 0];\n      for (var i = 0; i < numbers.length; i++) {\n        if (numbers[i].constructor === Array) {\n          total[0] += numbers[i][0];\n          total[1] += numbers[i][1];\n        } else {\n          total[0] += numbers[i];\n        }\n      }\n      return total;\n    }\n\n    // Check for size of imaginary component compared to real component.\n\n  }, {\n    key: \"isReal\",\n    value: function isReal(x) {\n      if (x.constructor === Array) {\n        return x[0] + x[1] === x[0];\n      } else {\n        return true;\n      }\n    }\n  }]);\n\n  return Complex;\n}();\n\nexports.default = Complex;\n},{}],90:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _complex = require('../utils/complex.js');\n\nvar _complex2 = _interopRequireDefault(_complex);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// These can be used for lightweight stuff, but they are much slower (~200 times slower)\n// They should compile to c structures well\nvar ComplexNumber = function () {\n  function ComplexNumber() {\n    var buffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new ArrayBuffer(16);\n\n    _classCallCheck(this, ComplexNumber);\n\n    this.buffer = buffer;\n  }\n\n  _createClass(ComplexNumber, [{\n    key: 'add',\n\n\n    // example wrapper\n    value: function add(complexV) {\n      var result = new ComplexNumber();\n      _complex2.default.add(this.buffer, 0, complexV.buffer, 0, result.buffer, 0);\n      return result;\n    }\n\n    // could be created dynamically?\n\n  }, {\n    key: 'mul',\n    value: function mul(complexV) {\n      var result = new ComplexNumber();\n      _complex2.default.mul(this.buffer, 0, complexV.buffer, 0, result.buffer, 0);\n      return result;\n    }\n\n    // about 10 times faster than mul, still 20 x slower than structureless complex numbers\n\n  }, {\n    key: 'mulEql',\n    value: function mulEql(complexV) {\n      _complex2.default.mul(this.buffer, 0, complexV.buffer, 0, this.buffer, 0);\n      return this;\n    }\n  }, {\n    key: 'buffer',\n    set: function set(buffer) {\n      this._buffer = buffer;\n      this._r = new Float64Array(this._buffer, 0, 1);\n      this._i = new Float64Array(this._buffer, 8, 1);\n    },\n    get: function get() {\n      return this._buffer;\n    }\n  }, {\n    key: 'r',\n    set: function set(v) {\n      this._r[0] = v;\n    },\n    get: function get() {\n      return this._r[0];\n    }\n  }, {\n    key: 'i',\n    set: function set(v) {\n      this._i[0] = v;\n    },\n    get: function get() {\n      return this._i[0];\n    }\n  }]);\n\n  return ComplexNumber;\n}();\n\nexports.default = ComplexNumber;\n},{\"../utils/complex.js\":89}],91:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.d1mach = d1mach;\n// !***BEGIN PROLOGUE  D1MACH\n// !***PURPOSE  Return floating point machine dependent constants.\n// !***LIBRARY   SLATEC\n// !***CATEGORY  R1\n// !***TYPE      SINGLE PRECISION (D1MACH-S, D1MACH-D)\n// !***KEYWORDS  MACHINE CONSTANTS\n// !***AUTHOR  Fox, P. A., (Bell Labs)\n// !           Hall, A. D., (Bell Labs)\n// !           Schryer, N. L., (Bell Labs)\n// !***DESCRIPTION\n// !\n// !   D1MACH can be used to obtain machine-dependent parameters for the\n// !   local machine environment.  It is a function subprogram with one\n// !   (input) argument, and can be referenced as follows:\n// !\n// !        A = D1MACH(I)\n// !\n// !   where I=1,...,5.  The (output) value of A above is determined by\n// !   the (input) value of I.  The results for various values of I are\n// !   discussed below.\n// !\n// !   D1MACH(1) = B**(EMIN-1), the smallest positive magnitude.\n// !   D1MACH(2) = B**EMAX*(1 - B**(-T)), the largest magnitude.\n// !   D1MACH(3) = B**(-T), the smallest relative spacing.\n// !   D1MACH(4) = B**(1-T), the largest relative spacing.\n// !   D1MACH(5) = LOG10(B)\n// !\n// !   Assume single precision numbers are represented in the T-digit,\n// !   base-B form\n// !\n// !              sign (B**E)*( (X(1)/B) + ... + (X(T)/B**T) )\n// !\n// !   where 0 .LE. X(I) .LT. B for I=1,...,T, 0 .LT. X(1), and\n// !   EMIN .LE. E .LE. EMAX.\n// !\n// !   The values of B, T, EMIN and EMAX are provided in I1MACH as\n// !   follows:\n// !   I1MACH(10) = B, the base.\n// !   I1MACH(11) = T, the number of base-B digits.\n// !   I1MACH(12) = EMIN, the smallest exponent E.\n// !   I1MACH(13) = EMAX, the largest exponent E.\n// !\n// !\n// !***REFERENCES  P. A. Fox, A. D. Hall and N. L. Schryer, Framework for\n// !                 a portable library, ACM Transactions on Mathematical\n// !                 Software 4, 2 (June 1978), pp. 177-188.\n// !***ROUTINES CALLED  XERMSG\n// !***REVISION HISTORY  (YYMMDD)\n// !   790101  DATE WRITTEN\n// !   960329  Modified for Fortran 90 (BE after suggestions by EHG)\n// !***END PROLOGUE  D1MACH\n// !\nfunction d1mach(input) {\n  switch (input) {\n    case 1:\n      return Number.MIN_VALUE;\n    case 2:\n      return Number.MAX_VALUE;\n    case 3:\n      return Number.EPSILON / 2; // the smallest relative spacing.\n    case 4:\n      return Number.EPSILON; // the largest relative spacing.\n    case 5:\n      return Math.log10(2);\n    default:\n      throw new Error('d1mach expects an integer 1-5.');\n  }\n}\n},{}],92:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.i1mach = i1mach;\n// import * as py from '../../utils/pythonHelpers.js';\n// !DECK I1MACH\n//       INTEGER FUNCTION I1MACH (I)\n//       IMPLICIT NONE\n//       INTEGER :: I\n//       REAL :: X\n//       DOUBLE PRECISION :: XX\n// !***BEGIN PROLOGUE  I1MACH\n// !***PURPOSE  Return integer machine dependent constants.\n// !***LIBRARY   SLATEC\n// !***CATEGORY  R1\n// !***TYPE      INTEGER (I1MACH-I)\n// !***KEYWORDS  MACHINE CONSTANTS\n// !***AUTHOR  Fox, P. A., (Bell Labs)\n// !           Hall, A. D., (Bell Labs)\n// !           Schryer, N. L., (Bell Labs)\n// !***DESCRIPTION\n// !\n// !   I1MACH can be used to obtain machine-dependent parameters for the\n// !   local machine environment.  It is a function subprogram with one\n// !   (input) argument and can be referenced as follows:\n// !\n// !        K = I1MACH(I)\n// !\n// !   where I=1,...,16.  The (output) value of K above is determined by\n// !   the (input) value of I.  The results for various values of I are\n// !   discussed below.\n// !\n// !   I/O unit numbers:\n// !     I1MACH( 1) = the standard input unit.\n// !     I1MACH( 2) = the standard output unit.\n// !     I1MACH( 3) = the standard punch unit.\n// !     I1MACH( 4) = the standard error message unit.\n// !\n// !   Words:\n// !     I1MACH( 5) = the number of bits per integer storage unit.\n// !     I1MACH( 6) = the number of characters per integer storage unit.\n// !\n// !   Integers:\n// !     assume integers are represented in the S-digit, base-A form\n// !\n// !                sign ( X(S-1)*A**(S-1) + ... + X(1)*A + X(0) )\n// !\n// !                where 0 .LE. X(I) .LT. A for I=0,...,S-1.\n// !     I1MACH( 7) = A, the base.\n// !     I1MACH( 8) = S, the number of base-A digits.\n// !     I1MACH( 9) = A**S - 1, the largest magnitude.\n// !\n// !   Floating-Point Numbers:\n// !     Assume floating-point numbers are represented in the T-digit,\n// !     base-B form\n// !                sign (B**E)*( (X(1)/B) + ... + (X(T)/B**T) )\n// !\n// !                where 0 .LE. X(I) .LT. B for I=1,...,T,\n// !                0 .LT. X(1), and EMIN .LE. E .LE. EMAX.\n// !     I1MACH(10) = B, the base.\n// !\n// !   Single-Precision:\n// !     I1MACH(11) = T, the number of base-B digits.\n// !     I1MACH(12) = EMIN, the smallest exponent E.\n// !     I1MACH(13) = EMAX, the largest exponent E.\n// !\n// !   Double-Precision:\n// !     I1MACH(14) = T, the number of base-B digits.\n// !     I1MACH(15) = EMIN, the smallest exponent E.\n// !     I1MACH(16) = EMAX, the largest exponent E.\n// !\n// !   To alter this function for a particular environment, the desired\n// !   set of DATA statements should be activated by removing the C from\n// !   column 1.  Also, the values of I1MACH(1) - I1MACH(4) should be\n// !   checked for consistency with the local operating system.\n// !\n// !***REFERENCES  P. A. Fox, A. D. Hall and N. L. Schryer, Framework for\n// !                 a portable library, ACM Transactions on Mathematical\n// !                 Software 4, 2 (June 1978), pp. 177-188.\n// !***ROUTINES CALLED  (NONE)\n// !***REVISION HISTORY  (YYMMDD)\n// !   750101  DATE WRITTEN\n// !   960411  Modified for Fortran 90 (BE after suggestions by EHG).\n// !   980727  Modified value of I1MACH(6) (BE after suggestion by EHG).\n// !***END PROLOGUE  I1MACH\n// !\nfunction i1mach(input) {\n  var bitSize = 64; // JS is always 64bit\n  // The following can be computed with the help of the frexp function in\n  // utils/pythonHelpers:\n  var digits = 53; // py.frexp(Number.MAX_SAFE_INTEGER)[1];\n  var maxExponent = 1024; // py.frexp(Number.MAX_VALUE)[1];\n  var minExponent = -1073; // py.frexp(Number.MIN_VALUE)[1];\n  switch (input) {\n    case 1:\n      return 5;\n    case 2:\n      return 6;\n    case 3:\n      return 0;\n    case 4:\n      return 0;\n    case 5:\n      return bitSize;\n    case 6:\n      return 4;\n    case 7:\n      return 2;\n    case 8:\n      return bitSize - 1;\n    case 9:\n      return Number.MAX_VALUE;\n    case 10:\n      return 2;\n    case 11:\n      return digits;\n    case 12:\n      return minExponent;\n    case 13:\n      return maxExponent;\n    case 14:\n      return digits;\n    case 15:\n      return minExponent;\n    case 16:\n      return maxExponent;\n    default:\n      throw new Error('i1mach expects an integer 1-16.');\n  }\n}\n},{}],93:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// https://gcc.gnu.org/onlinedocs/gcc-3.4.4/g77/Sign-Intrinsic.html#Sign-Intrinsic\nfunction sign(a, b) {\n  var s = b >= 0 ? 1 : -1;\n  return Math.abs(a) * s;\n}\n\nexports.sign = sign;\n},{}],94:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// Python has some built-in stuff that javascript doesn't.\n\n// frexp and ldexp from:\n// http://croquetweak.blogspot.com/2014/08/deconstructing-floats-frexp-and-ldexp.html\nfunction frexp(value) {\n  if (value === 0) return [value, 0];\n  var data = new DataView(new ArrayBuffer(8));\n  data.setFloat64(0, value);\n  var bits = data.getUint32(0) >>> 20 & 0x7FF;\n  if (bits === 0) {\n    // denormal\n    data.setFloat64(0, value * Math.pow(2, 64)); // exp + 64\n    bits = (data.getUint32(0) >>> 20 & 0x7FF) - 64;\n  }\n  var exponent = bits - 1022;\n  var mantissa = ldexp(value, -exponent);\n  return [mantissa, exponent];\n}\n\nfunction ldexp(mantissa, exponent) {\n  var steps = Math.min(3, Math.ceil(Math.abs(exponent) / 1023));\n  var result = mantissa;\n  for (var i = 0; i < steps; i++) {\n    result *= Math.pow(2, Math.floor((exponent + i) / steps));\n  }\n  return result;\n}\n\nfunction range(start, end, step) {\n  var _end = end || start;\n  var _start = end ? start : 0;\n  var _step = step || 1;\n  return Array((_end - _start) / _step).fill(0).map(function (v, i) {\n    return _start + i * _step;\n  });\n}\n\n// * It doesn't handle variadic arguments, that could be supported by js has some perf\n// issues with ... (so I've heard). That could be handled like\n// zip([[arr1], [arr2], [arr3]]) and then:\n// (...rows) => [...rows[0]].map((_,c) => rows.map(row => row[c]))\n// * It isn't it's own inverse like the python version. For that, use unzip\nfunction zip(arr1, arr2) {\n  return arr1.map(function (_, index) {\n    return [arr1[index], arr2[index]];\n  });\n}\n\n// Does the reverse of zip: [letters, numbers] = unzip( [['a',1], ['b', 2]] )\n// letters = ['a', 'b']\n// numbers = [1, 2]\nfunction unzip(arr) {\n  var res0 = [];\n  var res1 = [];\n  arr.map(function (pair) {\n    res0.push(pair[0]);\n    res1.push(pair[1]);\n  });\n  return [res0, res1];\n}\n\n// It is common to want to combine zip with the python pattern that iterates and creates arrays ([func(a) for a in alpha_s] similar to `map` in js). So this function combines the two a little more smoothly.\nfunction zipmap(arr1, arr2, func) {\n  return arr1.map(function (_, index) {\n    return func(arr1[index], arr2[index]);\n  });\n}\n\n// sum all elements of an array. This is much faster than reduce: https://jsperf.com/js-sum-3367890876\nfunction sum(numbers) {\n  var total = 0;\n  for (var i = 0; i < numbers.length; i++) {\n    total += numbers[i];\n  }\n  return total;\n}\n\n// Mimick python's get method for easier translation\nfunction get(obj, key) {\n  var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  if (obj.hasOwnProperty(key)) {\n    return obj[key];\n  } else {\n    return defaultValue;\n  }\n}\n\nfunction mod(x, y) {\n  return (x % y + y) % y;\n}\n\n// divmod\nfunction divmod(x, y) {\n  return [Math.floor(x / y), mod(x, y)];\n}\n\nexports.frexp = frexp;\nexports.ldexp = ldexp;\nexports.range = range;\nexports.zip = zip;\nexports.zipmap = zipmap;\nexports.unzip = unzip;\nexports.sum = sum;\nexports.get = get;\nexports.mod = mod;\nexports.divmod = divmod;\n},{}],95:[function(require,module,exports){\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _chebyshev = require('./lib/special/chebyshev.js');\n\nvar _chebyshev2 = _interopRequireDefault(_chebyshev);\n\nvar _complex = require('./lib/utils/complex.js');\n\nvar _complex2 = _interopRequireDefault(_complex);\n\nvar _complexNumber = require('./lib/utils/complexNumber.js');\n\nvar _complexNumber2 = _interopRequireDefault(_complexNumber);\n\nvar _cephes = require('./lib/special/cephes.js');\n\nvar _cephes2 = _interopRequireDefault(_cephes);\n\nvar _bessel = require('./lib/special/mpmath/functions/bessel.js');\n\nvar _quadpack = require('./lib/integration/quadpack.js');\n\nvar _amos = require('./lib/special/amos.js');\n\nvar amos = _interopRequireWildcard(_amos);\n\nvar _struve = require('./lib/special/c_misc/struve.js');\n\nvar struve = _interopRequireWildcard(_struve);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = {\n  Chebyshev: _chebyshev2.default,\n  Complex: _complex2.default,\n  ComplexNumber: _complexNumber2.default,\n  Cephes: _cephes2.default,\n  besseli: _bessel.besseli,\n  besselk: _bessel.besselk,\n  struvel: _bessel.struvel,\n  quad: _quadpack.quad,\n  amos: amos,\n  struve: struve\n};\n},{\"./lib/integration/quadpack.js\":2,\"./lib/special/amos.js\":9,\"./lib/special/c_misc/struve.js\":47,\"./lib/special/cephes.js\":48,\"./lib/special/chebyshev.js\":82,\"./lib/special/mpmath/functions/bessel.js\":85,\"./lib/utils/complex.js\":89,\"./lib/utils/complexNumber.js\":90}]},{},[1]);\n;\n      let element = args[args.length - 3]\n      let step = args[args.length - 2]\n      let n = args[args.length - 1]\n      let results = []\n      for (let i = 0; i < n; i++) {\n        progress(i/n)\n        let fnArgs = args.slice(0, -3)\n        fnArgs[element] += step * i\n        let result  = [ fnArgs[0], fnArgs[1], (axialForce(...fnArgs) || 0), (radialForce(...fnArgs) || 0) ]\n        results.push(result)\n      }\n      progress(1)\n      return results\n    }\n  )(...data, ...arguments)\n                postMessage({\n                  request: 'complete',\n                  result:  result\n                });\n              } catch (error) {\n                console.warn('550: Uncaught exception inside worker:', error)\n                postMessage({\n                  request: 'uncaughtException',\n                  error: {\n                    message: error.message,\n                    name: error.name,\n                    lineNumber: error.lineNumber,\n                    columnNumber: error.columnNumber,\n                    stack: error.stack\n                  }\n                })\n              }\n              break;\n            }\n          });\n        });","type":"ad-hoc","options":{},"payment":1,"feeStructure":{"maxPerRequest":"0.000500000000000000","maxTotal":"500.001000000000000000","maxRequests":1000002,"escrow":true},"timing":1,"to":"0x616d3cb23cd335e84f03002a0bf89d4227e60f4e","timestamp":1565121185751,"version":"0.1.1","deployCost":8.658095703125e-7,"owner":"0x42753dddcebe079b25d5a19eb3f479347080e502","sort":0,"maxSort":1000001,"address":"0xfe6539f4a7a8fa8be0ab35ccf932066607f879ec3697b70c807ce0180e58933b4ea032e1768ebb278913ba488f627e4b845509503a48c34d9aa70ccedb74b2a827"}